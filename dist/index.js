'use strict';

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Andreas Walter,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph and JSXCompressor.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.
    JSXCompressor is free software dual licensed under the GNU LGPL or Apache License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT
      OR
      * Apache License Version 2.0

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License, Apache
    License, and the MIT License along with JSXGraph. If not, see
    <https://www.gnu.org/licenses/>, <https://www.apache.org/licenses/LICENSE-2.0.html>,
    and <https://opensource.org/licenses/MIT/>.

 */
///////// start of global function that pollute the namespace
///////// addresses 'temporal dead zone'
///////// fix is to remove registration and  reference every possible class
var JXG_elements;
/**
 * This registers a new construction element to JSXGraph for the construction via the {@link this.Board.create}
 * interface.
 * @param {String} element The elements name. This is case-insensitive, existing elements with the same name
 * will be overwritten.
 * @param {Function} creator A reference to a function taking three parameters: First the board, the element is
 * to be created on, a parent element array, and an attributes object. See {@link this.createPoint} or any other
 * <tt>this.create...</tt> function for an example.
 */
function JXG_registerElement(element, creator) {
    if (JXG_elements == undefined) { // static so must intialize
        JXG_elements = {};
    }
    element = element.toLowerCase();
    JXG_elements[element] = creator;
}
// export function JXG_createElement(elementType: string,parents:any[],attributes:object) {
//     if (!JXG_elements.hasOwnProperty(elementType)) {
//         throw new Error('JSXGraph: create: Unknown element type given: ' + elementType);
//     }
//     let el: GeometryElement
//     if (Type.isFunction(JXG_elements[elementType])) {
//         el = JXG_elements[elementType](this, parents, attributes);
//     } else {
//         throw new Error('JSXGraph: create: Unknown element type given: ' + elementType);
//     }
//     if (!Type.exists(el)) {
//         throw new Error('JSXGraph: create: failure creating ' + elementType);
//         // JXG.debug('JSXGraph: create: failure creating ' + elementType);
//         return el;
//     }
// }
///////// end of two global function that pollute the namespace
// this file now incorporates parts of constants.js, type.js
const VERSION = '1.12.1-beta';
/**
 * JXG is the top object of JSXGraph and defines the namespace
 */
class JXG {
    // We need the following two methods "extend" and "shortcut" to create the JXG object via this.extend.
    /**
     * Copy all properties of the <tt>extension</tt> object to <tt>object</tt>.
     * @param  object
     * @param  extension
     * @param  [onlyOwn=false] Only consider properties that belong to extension itself, not any inherited properties.
     * @param  [toLower=false] If true the keys are convert to lower case. This is needed for visProp, see JXG#copyAttributes
     */
    static extend(object, extension, onlyOwn = false, toLower = false) {
        var e, e2;
        console.warn('Extend - Eliminate this');
        onlyOwn = onlyOwn || false;
        toLower = toLower || false;
        // the purpose of this for...in loop is indeed to use hasOwnProperty only if the caller
        // explicitly wishes so.
        for (e in extension) {
            if (!onlyOwn || (onlyOwn && extension.hasOwnProperty(e))) {
                if (toLower) {
                    e2 = e.toLowerCase();
                }
                else {
                    e2 = e;
                }
                object[e2] = extension[e];
            }
        }
    }
    ;
    /**
     * Set a constant <tt>name</tt> in <tt>object</tt> to <tt>value</tt>. The value can't be changed after declaration.
     * @param  object
     * @param  name
     * @param  value
     * @param  ignoreRedefine This should be left at its default: false.
     */
    // THIS IS ONLY USED IN 'extendConstants' which we also don't want
    // defineConstant(object: Object, name: string, value: number | string | boolean, ignoreRedefine = false) {
    //     if (ignoreRedefine && !object[name]) {
    //         return;
    //     }
    //     Object.defineProperty(object, name, {
    //         value: value,
    //         writable: false,
    //         enumerable: true,
    //         configurable: false
    //     });
    // };
    /**
     * Copy all properties of the <tt>constants</tt> object in <tt>object</tt> as a constant.
     * @param {Object} object
     * @param {Object} constants
     * @param {Boolean} [onlyOwn=false] Only consider properties that belong to extension itself, not any inherited properties.
     * @param {Boolean} [toUpper=false] If true the keys are convert to lower case. This is needed for visProp, see JXG#copyAttributes
     */
    // TODO: eliminate this
    // extendConstants(object, constants, onlyOwn, toUpper) {
    //     var e, e2;
    //     onlyOwn = onlyOwn || false;
    //     toUpper = toUpper || false;
    //     // The purpose of this for...in loop is indeed to use hasOwnProperty only if the caller explicitly wishes so.
    //     for (e in constants) {
    //         if (!onlyOwn || (onlyOwn && constants.hasOwnProperty(e))) {
    //             if (toUpper) {
    //                 e2 = e.toUpperCase();
    //             } else {
    //                 e2 = e;
    //             }
    //             this.defineConstant(object, e2, constants[e]);
    //         }
    //     }
    // };
    /**
     * This registers a new construction element to JSXGraph for the construction via the {@link this.Board.create}
     * interface.
     * @param {String} element The elements name. This is case-insensitive, existing elements with the same name
     * will be overwritten.
     * @param {Function} creator A reference to a function taking three parameters: First the board, the element is
     * to be created on, a parent element array, and an attributes object. See {@link this.createPoint} or any other
     * <tt>this.create...</tt> function for an example.
     */
    static registerElement(element, creator) {
        element = element.toLowerCase();
        this.elements[element] = creator;
    }
    /**
     * Register a file reader.
     * @param {function} reader A file reader. This object has to provide two methods: <tt>prepareString()</tt>
     *  and <tt>read()</tt>.
     * @param {Array} ext
     */
    // TODO is this used in JSXGraph (sees to be for geogebra)
    // registerReader(reader:FileReader, ext) {
    //     var i, e;
    //     for (i = 0; i < ext.length; i++) {
    //         e = ext[i].toLowerCase();
    //         if (typeof this.readers[e] !== "function") {
    //             this.readers[e] = reader;
    //         }
    //     }
    // }
    /**
     * Creates a shortcut to a method, e.g. {@link this.Board#createElement} is a shortcut to {@link this.Board#create}.
     * Sometimes the target is undefined by the time you want to define the shortcut so we need this little helper.
     * @param obj The object the method we want to create a shortcut for belongs to.
     * @param funct The method we want to create a shortcut for.
     * @returns A function that calls the given method.
     */
    /////// in ES6 you can create a shortcut easily
    // import {func1, func2, func3} from "./functions"
    // class MyClass {
    //    public foo: string = "bar"
    //    public func1 = func1.bind(this)
    //    public func2 = func2.bind(this)
    //    public func3 = func3.bind(this)
    //}
    static shortcut(obj, funct) {
        return () => {
            obj[funct].apply(obj, funct);
        };
    }
    // /**
    //  * s may be a string containing the name or id of an element or even a reference
    //  * to the element itself. This function returns a reference to the element. Search order: id, name.
    //  * @param board Reference to the board the element belongs to.
    //  * @param s String or reference to a JSXGraph element.
    //  * @returns  Reference to the object given in parameter object
    //  * @deprecated Use {@link this.Board#select}
    //  */
    // static getRef(board: Board, s: string) {
    //     this.deprecated('this.getRef()', 'Board.select()');
    //     return board.select(s, false); //TODO second param should be unnecesary (default in select() -here and other p)
    // }
    // /**
    //  * This is just a shortcut to {@link this.getRef}.
    //  * @deprecated Use {@link this.Board#select}.
    //  */
    // static getReference(board: Board, s: string) {
    //     this.deprecated('this.getReference()', 'Board.select()');
    //     return board.select(s, false);
    // }
    /**
     * s may be the string containing the id of an HTML tag that hosts a JSXGraph board.
     * This function returns the reference to the board.
     * @param  s String of an HTML tag that hosts a JSXGraph board
     * @returns Reference to the board or null.
     */
    static getBoardByContainerId(s) {
        for (const [key, value] of Object.entries(this.boards)) {
            if (value.container === s) {
                return value;
            }
        }
        return null;
    }
    /**
     * This method issues a warning to the developer that the given function is deprecated
     * and, if available, offers an alternative to the deprecated function.
     * @param  what Describes the function that is deprecated
     * @param  [replacement] The replacement that should be used instead.
     */
    static deprecated(what, replacement) {
        var warning = what + ' is deprecated.';
        if (replacement) {
            warning += ' Please use ' + replacement + ' instead.';
        }
        this.warn(warning);
    }
    /**
     * Outputs a warning via console.warn(), if available. If console.warn() is
     * unavailable this function will look for an HTML element with the id 'warning'
     * and append the warning to this element's innerHTML.
     * @param warning The warning text
     */
    static warn(warning) {
        if (typeof window === 'object' && window.console && console.warn) {
            console.warn('WARNING:', warning);
        }
        else if (typeof document === 'object') {
            let warning = document.getElementById('warning');
            if (warning) {
                warning.innerHTML += 'WARNING: ' + warning + '<br />';
            }
        }
    }
    /**
     * Add something to the debug log. If available a JavaScript debug console is used. Otherwise
     * we're looking for a HTML div with id "debug". If this doesn't exist, too, the output is omitted.
     * @param s An arbitrary number of parameters.
     * @see this.debugWST
     */
    static debugInt(...s) {
        for (let i = 0; i < arguments.length; i++) {
            let p = arguments[i];
            if (window) {
                if (typeof window === 'object' && window.console && console.log) {
                    console.log(p);
                }
            }
            else if (document) {
                if (typeof document === 'object') {
                    let debug = document.getElementById('debug');
                    if (debug) {
                        debug.innerHTML += p + '<br/>';
                    }
                }
            }
        }
    }
    /**
     * Add something to the debug log. If available a JavaScript debug console is used. Otherwise
     * we're looking for a HTML div with id "debug". If this doesn't exist, too, the output is omitted.
     * This method adds a stack trace (if available).
     * @param s An arbitrary number of parameters.
     * @see this.debug
     */
    static debugWST(...s) {
        var e = new Error();
        for (let i = 0; i < arguments.length; i++) {
            this.debugInt.apply(this, arguments[i]);
        }
        if (e && e.stack) {
            this.debugInt('stacktrace');
            this.debugInt(e.stack.split('\n').slice(1).join('\n'));
        }
    }
    /**
     * Add something to the debug log. If available a JavaScript debug console is used. Otherwise
     * we're looking for a HTML div with id "debug". If this doesn't exist, too, the output is omitted.
     * This method adds a line of the stack trace (if available).
     *
     * @param s An arbitrary number of parameters.
     * @see this.debug
     */
    static debugLine(...s) {
        var e = new Error();
        for (let i = 0; i < arguments.length; i++) {
            this.debugInt.apply(this, arguments[i]);
        }
        if (e && e.stack) {
            this.debugInt('Called from', e.stack.split('\n').slice(2, 3).join('\n'));
        }
    }
    /**
     * Add something to the debug log. If available a JavaScript debug console is used. Otherwise
     * we're looking for a HTML div with id "debug". If this doesn't exist, too, the output is omitted.
     * @param s An arbitrary number of parameters.
     * @see this.debugWST
     * @see this.debugLine
     * @see this.debugInt
     */
    static debug(...s) {
        // TODO  This is opaque without knowing who 'this' is
        for (let i = 0; i < arguments.length; i++) {
            console.warn(arguments[i]);
            // this.debugInt.apply(this, arguments[i]);
        }
    }
}
/**  Constant: the currently used JSXGraph version.  */
JXG.version = VERSION; // -dev  -beta ??
/**
 * Store a reference to every board in this central list. This will at some point
 * replace this.JSXGraph.boards.
 * @type Object
 */
JXG.boards = {};
/**
 * Store the available file readers in this structure.
 * @type Object
 */
JXG.readers = {};
/**
 * Associative array that keeps track of all constructable elements registered
 * via {@link this.registerElement}.
 * @type Object
 */
JXG.elements = {};
JXG.themes = {};

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Andreas Walter,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */
var COORDS_BY;
(function (COORDS_BY) {
    /**  Constant: user coordinates relative to the coordinates system defined by the bounding box.  */
    COORDS_BY[COORDS_BY["SCREEN"] = 1] = "SCREEN";
    /** Constant: screen coordinates in pixel relative to the upper left corner of the div element. */
    COORDS_BY[COORDS_BY["USER"] = 2] = "USER";
})(COORDS_BY || (COORDS_BY = {}));
var OBJECT_TYPE;
(function (OBJECT_TYPE) {
    // object types
    OBJECT_TYPE[OBJECT_TYPE["ARC"] = 0] = "ARC";
    OBJECT_TYPE[OBJECT_TYPE["ARROW"] = 1] = "ARROW";
    OBJECT_TYPE[OBJECT_TYPE["AXIS"] = 2] = "AXIS";
    OBJECT_TYPE[OBJECT_TYPE["AXISPOINT"] = 3] = "AXISPOINT";
    OBJECT_TYPE[OBJECT_TYPE["TICKS"] = 4] = "TICKS";
    OBJECT_TYPE[OBJECT_TYPE["CIRCLE"] = 5] = "CIRCLE";
    OBJECT_TYPE[OBJECT_TYPE["CONIC"] = 6] = "CONIC";
    OBJECT_TYPE[OBJECT_TYPE["CURVE"] = 7] = "CURVE";
    OBJECT_TYPE[OBJECT_TYPE["GLIDER"] = 8] = "GLIDER";
    OBJECT_TYPE[OBJECT_TYPE["IMAGE"] = 9] = "IMAGE";
    OBJECT_TYPE[OBJECT_TYPE["LINE1"] = 10] = "LINE1";
    OBJECT_TYPE[OBJECT_TYPE["POINT"] = 11] = "POINT";
    OBJECT_TYPE[OBJECT_TYPE["SLIDER"] = 12] = "SLIDER";
    OBJECT_TYPE[OBJECT_TYPE["CAS"] = 13] = "CAS";
    OBJECT_TYPE[OBJECT_TYPE["GXTCAS"] = 14] = "GXTCAS";
    OBJECT_TYPE[OBJECT_TYPE["POLYGON"] = 15] = "POLYGON";
    OBJECT_TYPE[OBJECT_TYPE["SECTOR"] = 16] = "SECTOR";
    OBJECT_TYPE[OBJECT_TYPE["TEXT"] = 17] = "TEXT";
    OBJECT_TYPE[OBJECT_TYPE["ANGLE"] = 18] = "ANGLE";
    OBJECT_TYPE[OBJECT_TYPE["INTERSECTION"] = 19] = "INTERSECTION";
    OBJECT_TYPE[OBJECT_TYPE["TURTLE"] = 20] = "TURTLE";
    OBJECT_TYPE[OBJECT_TYPE["VECTOR"] = 21] = "VECTOR";
    OBJECT_TYPE[OBJECT_TYPE["OPROJECT"] = 22] = "OPROJECT";
    OBJECT_TYPE[OBJECT_TYPE["GRID"] = 23] = "GRID";
    OBJECT_TYPE[OBJECT_TYPE["TANGENT"] = 24] = "TANGENT";
    OBJECT_TYPE[OBJECT_TYPE["HTMLSLIDER"] = 25] = "HTMLSLIDER";
    OBJECT_TYPE[OBJECT_TYPE["CHECKBOX"] = 26] = "CHECKBOX";
    OBJECT_TYPE[OBJECT_TYPE["INPUT"] = 27] = "INPUT";
    OBJECT_TYPE[OBJECT_TYPE["BUTTON"] = 28] = "BUTTON";
    OBJECT_TYPE[OBJECT_TYPE["TRANSFORMATION"] = 29] = "TRANSFORMATION";
    OBJECT_TYPE[OBJECT_TYPE["FOREIGNOBJECT"] = 30] = "FOREIGNOBJECT";
    OBJECT_TYPE[OBJECT_TYPE["VIEW3D"] = 31] = "VIEW3D";
    OBJECT_TYPE[OBJECT_TYPE["POINT3D"] = 32] = "POINT3D";
    OBJECT_TYPE[OBJECT_TYPE["LINE3D"] = 33] = "LINE3D";
    OBJECT_TYPE[OBJECT_TYPE["PLANE3D"] = 34] = "PLANE3D";
    OBJECT_TYPE[OBJECT_TYPE["CURVE3D"] = 35] = "CURVE3D";
    OBJECT_TYPE[OBJECT_TYPE["SURFACE3D"] = 36] = "SURFACE3D";
    OBJECT_TYPE[OBJECT_TYPE["MEASUREMENT"] = 37] = "MEASUREMENT";
    OBJECT_TYPE[OBJECT_TYPE["INTERSECTION_LINE3D"] = 38] = "INTERSECTION_LINE3D";
    OBJECT_TYPE[OBJECT_TYPE["SPHERE3D"] = 39] = "SPHERE3D";
    OBJECT_TYPE[OBJECT_TYPE["CIRCLE3D"] = 40] = "CIRCLE3D";
    OBJECT_TYPE[OBJECT_TYPE["INTERSECTION_CIRCLE3D"] = 41] = "INTERSECTION_CIRCLE3D";
    OBJECT_TYPE[OBJECT_TYPE["TEXT3D"] = 42] = "TEXT3D";
    OBJECT_TYPE[OBJECT_TYPE["FACE3D"] = 43] = "FACE3D";
    OBJECT_TYPE[OBJECT_TYPE["POLYHEDRON3D"] = 44] = "POLYHEDRON3D";
    OBJECT_TYPE[OBJECT_TYPE["POLYGON3D"] = 45] = "POLYGON3D";
    OBJECT_TYPE[OBJECT_TYPE["NOTYETASSIGNED"] = 46] = "NOTYETASSIGNED";
})(OBJECT_TYPE || (OBJECT_TYPE = {}));
// IMPORTANT:
// ----------
// For being able to differentiate between the (sketchometry specific) SPECIAL_OBJECT_TYPEs and
// (core specific) OBJECT_TYPEs, the non-sketchometry types MUST NOT be changed
// to values > 100.
var OBJECT_CLASS;
(function (OBJECT_CLASS) {
    // object classes
    OBJECT_CLASS[OBJECT_CLASS["POINT"] = 0] = "POINT";
    OBJECT_CLASS[OBJECT_CLASS["LINE"] = 1] = "LINE";
    OBJECT_CLASS[OBJECT_CLASS["CIRCLE"] = 2] = "CIRCLE";
    OBJECT_CLASS[OBJECT_CLASS["CURVE"] = 3] = "CURVE";
    OBJECT_CLASS[OBJECT_CLASS["AREA"] = 4] = "AREA";
    OBJECT_CLASS[OBJECT_CLASS["OTHER"] = 5] = "OTHER";
    OBJECT_CLASS[OBJECT_CLASS["TEXT"] = 6] = "TEXT";
    OBJECT_CLASS[OBJECT_CLASS["_3D"] = 7] = "_3D";
})(OBJECT_CLASS || (OBJECT_CLASS = {}));
var BOARD_MODE;
(function (BOARD_MODE) {
    /**
     * Board is in no special mode, objects are highlighted on mouse over and objects may be
     * clicked to start drag&drop.
     * @type Number
     * @constant
     */
    BOARD_MODE[BOARD_MODE["NONE"] = 0] = "NONE";
    /**
     * Board is in drag mode, objects aren't highlighted on mouse over and the object referenced in
     * {@link JXG.Board#mouse} is updated on mouse movement.
     * @type Number
     * @constant
     */
    BOARD_MODE[BOARD_MODE["DRAG"] = 1] = "DRAG";
    /**
     * In this mode a mouse move changes the origin's screen coordinates.
     * @type Number
     * @constant
     */
    BOARD_MODE[BOARD_MODE["MOVE_ORIGIN"] = 2] = "MOVE_ORIGIN";
    /**
     * Update is made with high quality, e.g. graphs are evaluated at much more points.
     * @type Number
     * @constant
     * @see JXG.Board#updateQuality
     */
    BOARD_MODE[BOARD_MODE["ZOOM"] = 17] = "ZOOM";
})(BOARD_MODE || (BOARD_MODE = {}));
var BOARD_QUALITY;
(function (BOARD_QUALITY) {
    /**
     * Update is made with low quality, e.g. graphs are evaluated at a lesser amount of points.
     * @type Number
     * @constant
     * @see JXG.Board#updateQuality
     */
    BOARD_QUALITY[BOARD_QUALITY["LOW"] = 1] = "LOW";
    BOARD_QUALITY[BOARD_QUALITY["HIGHLOW"] = 1] = "HIGHLOW";
    /**
     * Update is made with high quality, e.g. graphs are evaluated at much more points.
     * @type Number
     * @constant
     * @see JXG.Board#updateQuality
     */
    BOARD_QUALITY[BOARD_QUALITY["HIGH"] = 2] = "HIGH";
})(BOARD_QUALITY || (BOARD_QUALITY = {}));

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Carsten Miller,
        Andreas Walter,
        Alfred Wassermann

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */
/*global JXG: true, define: true*/
/*jslint nomen: true, plusplus: true*/
/*eslint no-loss-of-precision: off */
/**
 * Probability functions, e.g. error function,
 * see: https://en.wikipedia.org/wiki/Error_function
 * Ported from
 * by https://github.com/jeremybarnes/cephes/blob/master/cprob/ndtr.c,
 *
 * Cephes Math Library Release 2.9:  November, 2000
 * Copyright 1984, 1987, 1988, 1992, 2000 by Stephen L. Moshier
 *
 * @name JXG.Math.ProbFuncs
 * @exports Mat.ProbFuncs as JXG.Math.ProbFuncs
 * @namespace
 */
class ProbFuncs {
    /**
     *
     *	Exponential of squared argument
     *
     * SYNOPSIS:
     *
     * double x, y, expx2();
     * int sign;
     *
     * y = expx2( x, sign );
     *
     *
     *
     * DESCRIPTION:
     *
     * Computes y = exp(x*x) while suppressing error amplification
     * that would ordinarily arise from the inexactness of the
     * exponential argument x*x.
     *
     * If sign < 0, the result is inverted; i.e., y = exp(-x*x) .
     *
     *
     * ACCURACY:
     *
     *                      Relative error:
     * arithmetic    domain     # trials      peak         rms
     *   IEEE      -26.6, 26.6    10^7       3.9e-16     8.9e-17
     *
     * @private
     * @param  {Number} x
     * @param  {Number} sign (int)
     * @returns {Number}
     */
    static expx2(x, sign) {
        // double x;
        // int sign;
        var u, u1, m, f;
        x = Math.abs(x);
        if (sign < 0) {
            x = -x;
        }
        // Represent x as an exact multiple of M plus a residual.
        //    M is a power of 2 chosen so that exp(m * m) does not overflow
        //    or underflow and so that |x - m| is small.
        m = this.MINV * Math.floor(this.M * x + 0.5);
        f = x - m;
        // x^2 = m^2 + 2mf + f^2
        u = m * m;
        u1 = 2 * m * f + f * f;
        if (sign < 0) {
            u = -u;
            u1 = -u1;
        }
        if (u + u1 > this.MAXLOG) {
            return Infinity;
        }
        // u is exact, u1 is small.
        u = Math.exp(u) * Math.exp(u1);
        return u;
    }
    /**
     *
     *	Evaluate polynomial
     *
     * SYNOPSIS:
     *
     * int N;
     * double x, y, coef[N+1], polevl[];
     *
     * y = polevl( x, coef, N );
     *
     * DESCRIPTION:
     *
     * Evaluates polynomial of degree N:
     *
     *                     2          N
     * y  =  C  + C x + C x  +...+ C x
     *        0    1     2          N
     *
     * Coefficients are stored in reverse order:
     *
     * coef[0] = C  , ..., coef[N] = C  .
     *            N                   0
     *
     *  The function p1evl() assumes that coef[N] = 1.0 and is
     * omitted from the array.  Its calling arguments are
     * otherwise the same as polevl().
     *
     *
     * SPEED:
     *
     * In the interest of speed, there are no checks for out
     * of bounds arithmetic.  This routine is used by most of
     * the functions in the library.  Depending on available
     * equipment features, the user may wish to rewrite the
     * program in microcode or assembly language.
     *
     * @private
     * @param  {Number} x
     * @param  {Number} coef
     * @param  {Number} N
     * @returns {Number}
     */
    static polevl(x, coef, N) {
        var ans, i;
        if (Type.exists(coef.reduce)) {
            return coef.reduce(function (acc, c) {
                return acc * x + c;
            }, 0);
        }
        // Polyfill
        for (i = 0, ans = 0; i <= N; i++) {
            ans = ans * x + coef[i];
        }
        return ans;
    }
    /**
     * Evaluate polynomial when coefficient of x is 1.0.
     * Otherwise same as polevl.
     *
     * @private
     * @param  {Number} x
     * @param  {Number} coef
     * @param  {Number} N
     * @returns {Number}
     */
    static p1evl(x, coef, N) {
        var ans, i;
        if (Type.exists(coef.reduce)) {
            return coef.reduce(function (acc, c) {
                return acc * x + c;
            }, 1);
        }
        // Polyfill
        for (i = 0, ans = 1; i < N; i++) {
            ans = ans * x + coef[i];
        }
        return ans;
    }
    /**
     *
     *	Normal distribution function
     *
     * SYNOPSIS:
     *
     * y = ndtr( x );
     *
     * DESCRIPTION:
     *
     * Returns the area under the Gaussian probability density
     * function, integrated from minus infinity to x:
     *
     *                            x
     *                             -
     *                   1        | |          2
     *    ndtr(x)  = ---------    |    exp( - t /2 ) dt
     *               sqrt(2pi)  | |
     *                           -
     *                          -inf.
     *
     *             =  ( 1 + erf(z) ) / 2
     *             =  erfc(z) / 2
     *
     * where z = x/sqrt(2). Computation is via the functions
     * erf and erfc with care to avoid error amplification in computing exp(-x^2).
     *
     *
     * ACCURACY:
     *
     *                      Relative error:
     * arithmetic   domain     # trials      peak         rms
     *    IEEE     -13,0        30000       1.3e-15     2.2e-16
     *
     *
     * ERROR MESSAGES:
     *
     *   message         condition         value returned
     * erfc underflow    x > 37.519379347       0.0
     *
     * @param  {Number} a
     * @returns {Number}
     */
    static ndtr(a) {
        // a: double, return double
        var x, y, z;
        x = a * this.SQRTH;
        z = Math.abs(x);
        if (z < 1.0) {
            y = 0.5 + 0.5 * this.erf(x);
        }
        else {
            y = 0.5 * this.erfce(z);
            /* Multiply by exp(-x^2 / 2)  */
            z = this.expx2(a, -1);
            y = y * Math.sqrt(z);
            if (x > 0) {
                y = 1.0 - y;
            }
        }
        return y;
    }
    /**
     * @private
     * @param  {Number} a
     * @returns {Number}
     */
    static _underflow(a) {
        console.log("erfc", "UNDERFLOW");
        if (a < 0) {
            return 2.0;
        }
        return 0.0;
    }
    /**
     *
     *	Complementary error function
     *
     * SYNOPSIS:
     *
     * double x, y, erfc();
     *
     * y = erfc( x );
     *
     *
     *
     * DESCRIPTION:
     *
     *
     *  1 - erf(x) =
     *
     *                           inf.
     *                             -
     *                  2         | |          2
     *   erfc(x)  =  --------     |    exp( - t  ) dt
     *               sqrt(pi)   | |
     *                           -
     *                            x
     *
     *
     * For small x, erfc(x) = 1 - erf(x); otherwise rational
     * approximations are computed.
     *
     * A special function expx2.c is used to suppress error amplification
     * in computing exp(-x^2).
     *
     *
     * ACCURACY:
     *
     *                      Relative error:
     * arithmetic   domain     # trials      peak         rms
     *    IEEE      0,26.6417   30000       1.3e-15     2.2e-16
     *
     *
     * ERROR MESSAGES:
     *
     *   message         condition              value returned
     * erfc underflow    x > 9.231948545 (DEC)       0.0
     *
     * @param  {Number} a
     * @returns {Number}
     */
    static erfc(a) {
        var p, q, x, y, z;
        if (a < 0.0) {
            x = -a;
        }
        else {
            x = a;
        }
        if (x < 1.0) {
            return 1.0 - this.erf(a);
        }
        z = -a * a;
        if (z < -this.MAXLOG) {
            return this._underflow(a);
        }
        z = this.expx2(a, -1); // Compute z = exp(z).
        if (x < 8.0) {
            p = ProbFuncs.polevl(x, ProbFuncs.P, 8);
            q = ProbFuncs.p1evl(x, ProbFuncs.Q, 8);
        }
        else {
            p = ProbFuncs.polevl(x, this.R, 5);
            q = ProbFuncs.p1evl(x, this.S, 6);
        }
        y = (z * p) / q;
        if (a < 0) {
            y = 2.0 - y;
        }
        if (y === 0.0) {
            return this._underflow(a);
        }
        return y;
    }
    /**
     * Exponentially scaled erfc function
     *   exp(x^2) erfc(x)
     *   valid for x > 1.
     *   Use with ndtr and expx2.
     *
     * @private
     * @param {Number} x
     * @returns {Number}
     */
    static erfce(x) {
        var p, q;
        if (x < 8.0) {
            p = ProbFuncs.polevl(x, ProbFuncs.P, 8);
            q = ProbFuncs.p1evl(x, ProbFuncs.Q, 8);
        }
        else {
            p = ProbFuncs.polevl(x, this.R, 5);
            q = ProbFuncs.p1evl(x, this.S, 6);
        }
        return p / q;
    }
    /**
     *	Error function
     *
     * SYNOPSIS:
     *
     * double x, y, erf();
     *
     * y = erf( x );
     *
     *
     *
     * DESCRIPTION:
     *
     * The integral is
     *
     *                           x
     *                            -
     *                 2         | |          2
     *   erf(x)  =  --------     |    exp( - t  ) dt.
     *              sqrt(pi)   | |
     *                          -
     *                           0
     *
     * For 0 <= |x| < 1, erf(x) = x * P4(x**2)/Q5(x**2); otherwise
     * erf(x) = 1 - erfc(x).
     *
     *
     * ACCURACY:
     *
     *                      Relative error:
     * arithmetic   domain     # trials      peak         rms
     *    DEC       0,1         14000       4.7e-17     1.5e-17
     *    IEEE      0,1         30000       3.7e-16     1.0e-16
     *
     * @param  {Number} x
     * @returns {Number}
     */
    static erf(x) {
        var y, z;
        if (Math.abs(x) > 1.0) {
            return 1.0 - ProbFuncs.erfc(x);
        }
        z = x * x;
        y = (x * ProbFuncs.polevl(z, this.T, 4)) / ProbFuncs.p1evl(z, this.U, 5);
        return y;
    }
    /**
     *
     *	Inverse of Normal distribution function
     *
     * SYNOPSIS:
     *
     * double x, y, ndtri();
     *
     * x = ndtri( y );
     *
     * DESCRIPTION:
     *
     * Returns the argument, x, for which the area under the
     * Gaussian probability density function (integrated from
     * minus infinity to x) is equal to y.
     *
     *
     * For small arguments 0 < y < exp(-2), the program computes
     * z = sqrt( -2.0 * log(y) );  then the approximation is
     * x = z - log(z)/z  - (1/z) P(1/z) / Q(1/z).
     * There are two rational functions P/Q, one for 0 < y < exp(-32)
     * and the other for y up to exp(-2).  For larger arguments,
     * w = y - 0.5, and  x/sqrt(2pi) = w + w**3 R(w**2)/S(w**2)).
     *
     *
     * ACCURACY:
     *
     *                      Relative error:
     * arithmetic   domain        # trials      peak         rms
     *    DEC      0.125, 1         5500       9.5e-17     2.1e-17
     *    DEC      6e-39, 0.135     3500       5.7e-17     1.3e-17
     *    IEEE     0.125, 1        20000       7.2e-16     1.3e-16
     *    IEEE     3e-308, 0.135   50000       4.6e-16     9.8e-17
     *
     *
     * ERROR MESSAGES:
     *
     *   message         condition    value returned
     * ndtri domain       x <= 0        -MAXNUM
     * ndtri domain       x >= 1         MAXNUM
     *
     * @param  {Number} y0
     * @returns {Number}
     */
    static ndtri(y0) {
        var x, y, z, y2, x0, x1, code;
        if (y0 <= 0.0) {
            //console.log("ndtri", "DOMAIN ");
            return -Infinity; // -this.MAXNUM;
        }
        if (y0 >= 1.0) {
            // console.log("ndtri", "DOMAIN");
            return Infinity; // this.MAXNUM;
        }
        code = 1;
        y = y0;
        if (y > 1.0 - 0.13533528323661269189) {
            // 0.135... = exp(-2)
            y = 1.0 - y;
            code = 0;
        }
        if (y > 0.13533528323661269189) {
            y = y - 0.5;
            y2 = y * y;
            x = y + y * ((y2 * ProbFuncs.polevl(y2, ProbFuncs.P0, 4)) / ProbFuncs.p1evl(y2, ProbFuncs.Q0, 8));
            x = x * ProbFuncs.s2pi;
            return x;
        }
        x = Math.sqrt(-2 * Math.log(y));
        x0 = x - Math.log(x) / x;
        z = 1.0 / x;
        if (x < 8.0) {
            // y > exp(-32) = 1.2664165549e-14
            x1 = (z * ProbFuncs.polevl(z, ProbFuncs.P1, 8)) / ProbFuncs.p1evl(z, ProbFuncs.Q1, 8);
        }
        else {
            x1 = (z * ProbFuncs.polevl(z, ProbFuncs.P2, 8)) / ProbFuncs.p1evl(z, ProbFuncs.Q2, 8);
        }
        x = x0 - x1;
        if (code !== 0) {
            x = -x;
        }
        return x;
    }
    /**
     * Inverse of error function erf.
     *
     * @param  {Number} x
     * @returns {Number}
     */
    static erfi(x) {
        return this.ndtri((x + 1) * 0.5) * ProbFuncs.SQRTH;
    }
}
ProbFuncs.MAXNUM = 1.701411834604692317316873e38; // 2**127
ProbFuncs.SQRTH = 7.07106781186547524401e-1; // sqrt(2)/2
ProbFuncs.SQRT2 = 1.4142135623730950488; // sqrt(2)
ProbFuncs.MAXLOG = 7.08396418532264106224e2; // log 2**1022
ProbFuncs.P = [
    2.46196981473530512524e-10, 5.64189564831068821977e-1, 7.46321056442269912687,
    4.86371970985681366614e1, 1.96520832956077098242e2, 5.26445194995477358631e2,
    9.3452852717195760754e2, 1.02755188689515710272e3, 5.57535335369399327526e2
];
ProbFuncs.Q = [
    1.32281951154744992508e1, 8.67072140885989742329e1, 3.54937778887819891062e2,
    9.75708501743205489753e2, 1.82390916687909736289e3, 2.24633760818710981792e3,
    1.65666309194161350182e3, 5.57535340817727675546e2
];
ProbFuncs.R = [
    5.64189583547755073984e-1, 1.27536670759978104416, 5.01905042251180477414,
    6.16021097993053585195, 7.4097426995044893916, 2.9788666537210024067
];
ProbFuncs.S = [
    2.2605286322011727659, 9.39603524938001434673, 1.20489539808096656605e1,
    1.70814450747565897222e1, 9.60896809063285878198, 3.3690764510008151605
];
ProbFuncs.T = [
    9.60497373987051638749, 9.00260197203842689217e1, 2.23200534594684319226e3,
    7.00332514112805075473e3, 5.55923013010394962768e4
];
ProbFuncs.U = [
    3.35617141647503099647e1, 5.21357949780152679795e2, 4.59432382970980127987e3,
    2.26290000613890934246e4, 4.92673942608635921086e4
];
// UTHRESH: 37.519379347,
ProbFuncs.M = 128.0;
ProbFuncs.MINV = 0.0078125;
ProbFuncs.s2pi = 2.50662827463100050242; // sqrt(2pi)
// approximation for 0 <= |y - 0.5| <= 3/8 */
ProbFuncs.P0 = [
    -59.96335010141079, 9.80010754185999661536e1, -56.67628574690703,
    1.39312609387279679503e1, -1.2391658386738125
];
ProbFuncs.Q0 = [
    1.95448858338141759834, 4.67627912898881538453, 8.63602421390890590575e1,
    -225.46268785411937, 2.00260212380060660359e2, -82.03722561683334,
    1.59056225126211695515e1, -1.1833162112133
];
//  Approximation for interval z = sqrt(-2 log y ) between 2 and 8
//  i.e., y between exp(-2) = .135 and exp(-32) = 1.27e-14.
ProbFuncs.P1 = [
    4.05544892305962419923, 3.15251094599893866154e1, 5.71628192246421288162e1,
    4.408050738932008347e1, 1.46849561928858024014e1, 2.18663306850790267539,
    -0.1402560791713545, -0.03504246268278482, -8574567851546854e-19
];
ProbFuncs.Q1 = [
    1.57799883256466749731e1, 4.53907635128879210584e1, 4.1317203825467203044e1,
    1.50425385692907503408e1, 2.50464946208309415979, -0.14218292285478779,
    -0.03808064076915783, -9332594808954574e-19
];
// Approximation for interval z = sqrt(-2 log y ) between 8 and 64
// i.e., y between exp(-32) = 1.27e-14 and exp(-2048) = 3.67e-890.
ProbFuncs.P2 = [
    3.2377489177694603597, 6.91522889068984211695, 3.93881025292474443415,
    1.33303460815807542389, 2.01485389549179081538e-1, 1.23716634817820021358e-2,
    3.01581553508235416007e-4, 2.65806974686737550832e-6, 6.2397453918498329373e-9
];
ProbFuncs.Q2 = [
    6.02427039364742014255, 3.67983563856160859403, 1.37702099489081330271,
    2.1623699359449663589e-1, 1.34204006088543189037e-2, 3.28014464682127739104e-4,
    2.89247864745380683936e-6, 6.79019408009981274425e-9
];

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */
/*
* In TypeScript, the concept of a "static class" as it exists in languages like C# (where you explicitly
* declare a class with the static keyword) does not directly apply. In TypeScript (and JavaScript), you
* cannot declare an entire class as static.
*
 * Instead, you achieve a similar effect by making all members (properties and methods) within a class
 * static. This means that these members belong to the class itself, rather than to instances of the class.
 * You can then access these members directly using the class name, without needing to create an object from
 * the class.
 *
 * JSXMath is a static class
*/
/*global JXG: true, define: true, Float32Array: true */
/*jslint nomen: true, plusplus: true, bitwise: true*/
/**
 * @fileoverview In this file the namespace JXG.Math is defined, which is the base namespace
 * for namespaces like JXG.Math.Numerics, JXG.Math.Plot, JXG.Math.Statistics, JXG.Math.Clip etc.
 */
// import { JXG } from "../jxg.js";
/**
 * Math namespace. Contains mathematics related methods which are
 * specific to JSXGraph or which extend the JavaScript Math class.
 * @namespace
 */
class JSXMath {
    /**
     * Determine the relative difference between two numbers.
     * @returns {Number}  Relative difference between a and b: |a-b| / max(|a|, |b|)
     */
    static relDif(a, b) {
        var c = Math.abs(a), d = Math.abs(b);
        d = Math.max(c, d);
        return d === 0.0 ? 0.0 : Math.abs(a - b) / d;
    }
    /**
     * The JavaScript implementation of the % operator returns the symmetric modulo.
     * mod and "%" are both identical if a >= 0 and m >= 0 but the results differ if a or m < 0.
     * @param {Number} a
     * @param {Number} m
     * @returns {Number} Mathematical modulo <tt>a mod m</tt>
     */
    static mod(a, m) {
        return a - Math.floor(a / m) * m;
    }
    /**
     * Translate <code>x</code> into the interval <code>[a, b)</code> by adding
     * a multiple of <code>b - a</code>.
     */
    static wrap(x, a, b) {
        return a + this.mod(x - a, b - a);
    }
    /**
     * Clamp <code>x</code> within the interval <code>[a, b]</code>. If
     * <code>x</code> is below <code>a</code>, increase it to <code>a</code>. If
     * it's above <code>b</code>, decrease it to <code>b</code>.
     */
    static clamp(x, a, b) {
        return Math.min(Math.max(x, a), b);
    }
    /**
     * A way of clamping a periodic variable. If <code>x</code> is congruent mod
     * <code>period</code> to a point in <code>[a, b]</code>, return that point.
     * Otherwise, wrap it into <code>[mid - period/2, mid + period/2]</code>,
     * where <code>mid</code> is the mean of <code>a</code> and <code>b</code>,
     * and then clamp it to <code>[a, b]</code> from there.
     */
    static wrapAndClamp(x, a, b, period) {
        var mid = 0.5 * (a + b), half_period = 0.5 * period;
        return this.clamp(this.wrap(x, mid - half_period, mid + half_period), a, b);
    }
    /**
     * Initializes a vector of size <tt>n</tt> wih coefficients set to the init value (default 0)
     * @param {Number} n Length of the vector
     * @param {Number} [init=0] Initial value for each coefficient
     * @returns {Array} An array of length <tt>n</tt>
     */
    static vector(n, init = 0) {
        let r = [];
        for (let i = 0; i < n; i++) {
            r[i] = init;
        }
        return r;
    }
    /**
     * Initializes a matrix as an array of rows with the given value.
     * @param  n Number of rows
     * @param  [m=n] Number of columns
     * @param  [init=0] Initial value for each coefficient
     * @returns  A <tt>n</tt> times <tt>m</tt>-matrix represented by a
     * two-dimensional array. The inner arrays hold the columns, the outer array holds the rows.
     */
    static matrix(n, m, init = 0) {
        m = m || n;
        let r = [];
        for (let i = 0; i < n; i++) {
            r[i] = [];
            for (let j = 0; j < m; j++) {
                r[i][j] = init;
            }
        }
        return r;
    }
    /**
     * Generates an identity matrix. If n is a number and m is undefined or not a number, a square matrix is generated,
     * if n and m are both numbers, an nxm matrix is generated.
     * @param  n Number of rows
     * @param  m Number of columns
     * @returns {Array} A square matrix of length <tt>n</tt> with all coefficients equal to 0 except a_(i,i), i out of (1, ..., n), if <tt>m</tt> is undefined or not a number
     * or a <tt>n</tt> times <tt>m</tt>-matrix with a_(i,j) = 0 and a_(i,i) = 1 if m is a number.
     */
    static identity(n, m) {
        m = m || n; // square if not defined
        let r = this.matrix(n, m);
        for (let i = 0; i < Math.min(n, m); i++) {
            r[i][i] = 1;
        }
        return r;
    }
    /**
     * Generates a 4x4 matrix for 3D to 2D projections.
     * @param  l Left
     * @param  r Right
     * @param  t Top
     * @param  b Bottom
     * @param  n Near
     * @param  f Far
     * @returns {Array} 4x4 Matrix
     */
    static frustum(l, r, b, t, n, f) {
        let ret = this.matrix(4, 4);
        ret[0][0] = (n * 2) / (r - l);
        ret[0][1] = 0;
        ret[0][2] = (r + l) / (r - l);
        ret[0][3] = 0;
        ret[1][0] = 0;
        ret[1][1] = (n * 2) / (t - b);
        ret[1][2] = (t + b) / (t - b);
        ret[1][3] = 0;
        ret[2][0] = 0;
        ret[2][1] = 0;
        ret[2][2] = -(f + n) / (f - n);
        ret[2][3] = -(f * n * 2) / (f - n);
        ret[3][0] = 0;
        ret[3][1] = 0;
        ret[3][2] = -1;
        ret[3][3] = 0;
        return ret;
    }
    /**
     * Generates a 4x4 matrix for 3D to 2D projections.
     * @param  fov Field of view in vertical direction, given in rad.
     * @param  ratio Aspect ratio of the projection plane.
     * @param  n Near
     * @param  f Far
     * @returns {Array} 4x4 Projection Matrix
     */
    static projection(fov, ratio, n, f) {
        let t = n * Math.tan(fov / 2), r = t * ratio;
        return this.frustum(-r, r, -t, t, n, f);
    }
    /**
     * Multiplies a vector vec to a matrix mat: mat * vec. The matrix is interpreted by this function as an array of rows.
     * Please note: This
     * function does not check if the dimensions match.
     * @param {Array} mat Two-dimensional array of numbers. The inner arrays describe the columns, the outer ones the matrix' rows.
     * @param {Array} vec Array of numbers
     * @returns {Array} Array of numbers containing the result
     * @example
     * var A = [[2, 1],
     *          [2, 3]],
     *     b = [4, 5],
     *     c;
     * c = JXG.Math.matVecMult(A, b);
     * // c === [13, 23];
     */
    static matVecMult(mat, vec) {
        var i, k, s, m = mat.length, n = vec.length, res = [];
        if (n === 3) {
            for (i = 0; i < m; i++) {
                res[i] = mat[i][0] * vec[0] + mat[i][1] * vec[1] + mat[i][2] * vec[2];
            }
        }
        else {
            for (i = 0; i < m; i++) {
                s = 0;
                for (k = 0; k < n; k++) {
                    s += mat[i][k] * vec[k];
                }
                res[i] = s;
            }
        }
        return res;
    }
    /**
     * Multiplies a vector vec to a matrix mat from the left: vec * mat.
     * The matrix is interpreted by this function as an array of rows.
     * Please note: This function does not check if the dimensions match.
     * @param {Array} vec Array of numbers
     * @param {Array} mat Two-dimensional array of numbers. The inner arrays describe the columns,
     *  the outer ones the matrix' rows.
     * @returns {Array} Array of numbers containing the result
     * @example
     * var A = [[2, 1],
     *          [2, 3]],
     *     b = [4, 5],
     *     c;
     * c = JXG.Math.vecMatMult(b, A);
     * // c === [18, 16];
     */
    static vecMatMult(vec, mat) {
        var i, k, s, m = mat.length, n = vec.length, res = [];
        if (n === 3) {
            for (i = 0; i < m; i++) {
                res[i] = vec[0] * mat[0][i] + vec[1] * mat[1][i] + vec[2] * mat[2][i];
            }
        }
        else {
            for (i = 0; i < n; i++) {
                s = 0;
                for (k = 0; k < m; k++) {
                    s += vec[k] * mat[k][i];
                }
                res[i] = s;
            }
        }
        return res;
    }
    /**
     * Computes the product of the two matrices: mat1 * mat2.
     * Returns a new matrix array.
     *
     * @param {Array} mat1 Two-dimensional array of numbers
     * @param {Array} mat2 Two-dimensional array of numbers
     * @returns {Array} Two-dimensional Array of numbers containing result
     */
    static matMatMult(mat1, mat2) {
        var i, j, s, k, m = mat1.length, n = m > 0 ? mat2[0].length : 0, m2 = mat2.length, res = this.matrix(m, n);
        for (i = 0; i < m; i++) {
            for (j = 0; j < n; j++) {
                s = 0;
                for (k = 0; k < m2; k++) {
                    s += mat1[i][k] * mat2[k][j];
                }
                res[i][j] = s;
            }
        }
        return res;
    }
    /**
     * Multiply a matrix mat by a scalar alpha: mat * scalar
     *
     * @param {Array} mat Two-dimensional array of numbers
     * @param {Number} alpha Scalar
     * @returns {Array} Two-dimensional Array of numbers containing result
     */
    static matNumberMult(mat, alpha) {
        var i, j, m = mat.length, n = m > 0 ? mat[0].length : 0, res = this.matrix(m, n);
        for (i = 0; i < m; i++) {
            for (j = 0; j < n; j++) {
                res[i][j] = mat[i][j] * alpha;
            }
        }
        return res;
    }
    /**
     * Compute the sum of two matrices: mat1 + mat2.
     * Returns a new matrix object.
     *
     * @param {Array} mat1 Two-dimensional array of numbers
     * @param {Array} mat2 Two-dimensional array of numbers
     * @returns {Array} Two-dimensional Array of numbers containing result
     */
    static matMatAdd(mat1, mat2) {
        var i, j, m = mat1.length, n = m > 0 ? mat1[0].length : 0, res = this.matrix(m, n);
        for (i = 0; i < m; i++) {
            for (j = 0; j < n; j++) {
                res[i][j] = mat1[i][j] + mat2[i][j];
            }
        }
        return res;
    }
    /**
     * Transposes a matrix given as a two-dimensional array.
     * @param {Array} M The matrix to be transposed
     * @returns {Array} The transpose of M
     */
    static transpose(M) {
        var MT, i, j, m, n;
        // number of rows of M
        m = M.length;
        // number of columns of M
        n = M.length > 0 ? M[0].length : 0;
        MT = this.matrix(n, m);
        for (i = 0; i < n; i++) {
            for (j = 0; j < m; j++) {
                MT[i][j] = M[j][i];
            }
        }
        return MT;
    }
    /**
     * Compute the inverse of an <i>(n x n)</i>-matrix by Gauss elimination.
     *
     * @param {Array} A matrix
     * @returns {Array} Inverse matrix of A or empty array (i.e. []) in case A is singular.
     */
    static inverse(Ain) {
        var i, j, k, r, s, eps = this.eps * this.eps, ma, swp, n = Ain.length, A = [], p = [], hv = [];
        for (i = 0; i < n; i++) {
            A[i] = [];
            for (j = 0; j < n; j++) {
                A[i][j] = Ain[i][j];
            }
            p[i] = i;
        }
        for (j = 0; j < n; j++) {
            // Pivot search
            ma = Math.abs(A[j][j]);
            r = j;
            for (i = j + 1; i < n; i++) {
                if (Math.abs(A[i][j]) > ma) {
                    ma = Math.abs(A[i][j]);
                    r = i;
                }
            }
            // Singular matrix
            if (ma <= eps) {
                console.warn('JXG.Math.inverse: singular matrix');
                return [];
            }
            // swap rows:
            if (r > j) {
                for (k = 0; k < n; k++) {
                    swp = A[j][k];
                    A[j][k] = A[r][k];
                    A[r][k] = swp;
                }
                swp = p[j];
                p[j] = p[r];
                p[r] = swp;
            }
            // transformation:
            s = 1.0 / A[j][j];
            for (i = 0; i < n; i++) {
                A[i][j] *= s;
            }
            A[j][j] = s;
            for (k = 0; k < n; k++) {
                if (k !== j) {
                    for (i = 0; i < n; i++) {
                        if (i !== j) {
                            A[i][k] -= A[i][j] * A[j][k];
                        }
                    }
                    A[j][k] = -s * A[j][k];
                }
            }
        }
        // swap columns:
        for (i = 0; i < n; i++) {
            for (k = 0; k < n; k++) {
                hv[p[k]] = A[i][k];
            }
            for (k = 0; k < n; k++) {
                A[i][k] = hv[k];
            }
        }
        return A;
    }
    /**
     * Trace of a square matrix, given as a two-dimensional array.
     * @param {Array} M Square matrix
     * @returns {Number} The trace of M, NaN if M is not square.
     */
    static trace(M) {
        var i, m, n, t = 0.0;
        // number of rows of M
        m = M.length;
        // number of columns of M
        n = M.length > 0 ? M[0].length : 0;
        if (m !== n) {
            return NaN;
        }
        for (i = 0; i < n; i++) {
            t += M[i][i];
        }
        return t;
    }
    /**
     * Inner product of two vectors a and b. n is the length of the vectors.
     * @param {Array} a Vector
     * @param {Array} b Vector
     * @param {Number} [n] Length of the Vectors. If not given the length of the first vector is taken.
     * @returns {Number} The inner product of a and b.
     */
    static innerProduct(a, b, n) {
        var i, s = 0;
        if (n === undefined || !Type.isNumber(n)) {
            n = a.length;
        }
        for (i = 0; i < n; i++) {
            s += a[i] * b[i];
        }
        return s;
    }
    /**
     * Calculates the cross product of two vectors both of length three.
     * In case of homogeneous coordinates this is either
     * <ul>
     * <li>the intersection of two lines</li>
     * <li>the line through two points</li>
     * </ul>
     * @param {Array} c1 Homogeneous coordinates of line or point 1
     * @param {Array} c2 Homogeneous coordinates of line or point 2
     * @returns {Array} vector of length 3: homogeneous coordinates of the resulting point / line.
     */
    static crossProduct(c1, c2) {
        return [
            c1[1] * c2[2] - c1[2] * c2[1],
            c1[2] * c2[0] - c1[0] * c2[2],
            c1[0] * c2[1] - c1[1] * c2[0]
        ];
    }
    /**
     * Euclidean norm of a vector.
     *
     * @param a Array containing a vector.
     * @param  n (Optional) length of the array.
     * @returns Euclidean norm of the vector.
     */
    static norm(a, n) {
        let sum = 0.0;
        n = n !== null && n !== void 0 ? n : a.length;
        for (let i = 0; i < n; i++) {
            sum += a[i] * a[i];
        }
        return Math.sqrt(sum);
    }
    /**
     * Compute a * x + y for a scalar a and vectors x and y.
     *
     * @param {Number} a
     * @param {Array} x
     * @param {Array} y
     * @returns {Array}
     */
    static axpy(a, x, y) {
        var i, le = x.length, p = [];
        for (i = 0; i < le; i++) {
            p[i] = a * x[i] + y[i];
        }
        return p;
    }
    /**
     * Compute the factorial of a positive integer. If a non-integer value
     * is given, the fraction will be ignored.
     * @function
     * @param {Number} n
     * @returns {Number} n! = n*(n-1)*...*2*1
     */
    static factorial(n) {
        if (n < 0) {
            return NaN;
        }
        n = Math.floor(n);
        if (n === 0 || n === 1) {
            return 1;
        }
        return n * this.factorial(n - 1);
    }
    /**
     * Computes the binomial coefficient n over k.
     * @function
     * @param {Number} n Fraction will be ignored
     * @param {Number} k Fraction will be ignored
     * @returns {Number} The binomial coefficient n over k
     */
    static binomial(n, k) {
        var b, i;
        if (k > n || k < 0) {
            return NaN;
        }
        k = Math.round(k);
        n = Math.round(n);
        if (k === 0 || k === n) {
            return 1;
        }
        b = 1;
        for (i = 0; i < k; i++) {
            b *= n - i;
            b /= i + 1;
        }
        return b;
    }
    /**
     * Calculates the cosine hyperbolicus of x.
     * @function
     * @param {Number} x The number the cosine hyperbolicus will be calculated of.
     * @returns {Number} Cosine hyperbolicus of the given value.
     */
    static cosh(x) {
        return Math.cosh(x);
    }
    /**
     * Sine hyperbolicus of x.
     * @function
     * @param {Number} x The number the sine hyperbolicus will be calculated of.
     * @returns {Number} Sine hyperbolicus of the given value.
     */
    static sinh(x) {
        return Math.sinh(x);
    }
    /**
     * Hyperbolic arc-cosine of a number.
     * @function
     * @param {Number} x
     * @returns {Number}
     */
    static acosh(x) {
        return Math.acosh(x);
    }
    /**
     * Hyperbolic arcsine of a number
     * @function
     * @param {Number} x
     * @returns {Number}
     */
    static asinh(x) {
        return Math.asinh(x);
    }
    //   ||
    //     function (x) {
    //         if (x === -Infinity) {
    //             return x;
    //         }
    //         return Math.log(x + Math.sqrt(x * x + 1));
    //     }
    /**
     * Computes the cotangent of x.
     * @function
     * @param {Number} x The number the cotangent will be calculated of.
     * @returns {Number} Cotangent of the given value.
     */
    static cot(x) {
        return 1 / Math.tan(x);
    }
    /**
     * Computes the inverse cotangent of x.
     * @param {Number} x The number the inverse cotangent will be calculated of.
     * @returns {Number} Inverse cotangent of the given value.
     */
    static acot(x) {
        return (x >= 0 ? 0.5 : -0.5) * Math.PI - Math.atan(x);
    }
    /**
     * Compute n-th real root of a real number. n must be strictly positive integer.
     * If n is odd, the real n-th root exists and is negative.
     * For n even, for negative valuees of x NaN is returned
     * @param  {Number} x radicand. Must be non-negative, if n even.
     * @param  {Number} n index of the root. must be strictly positive integer.
     * @returns {Number} returns real root or NaN
     *
     * @example
     * nthroot(16, 4): 2
     * nthroot(-27, 3): -3
     * nthroot(-4, 2): NaN
     */
    static nthroot(x, n) {
        var inv = 1 / n;
        if (n <= 0 || Math.floor(n) !== n) {
            return NaN;
        }
        if (x === 0.0) {
            return 0.0;
        }
        if (x > 0) {
            return Math.exp(inv * Math.log(x));
        }
        // From here on, x is negative
        if (n % 2 === 1) {
            return -Math.exp(inv * Math.log(-x));
        }
        // x negative, even root
        return NaN;
    }
    /**
     * Computes cube root of real number
     * Polyfill for Math.cbrt().
     *
     * @function
     * @param  {Number} x Radicand
     * @returns {Number} Cube root of x.
     */
    static cbrt(x) {
        return Math.cbrt(x); //|| (x)=> { this.nthroot(x, 3) };
    }
    /**
     * Compute base to the power of exponent.
     * @param {Number} base
     * @param {Number} exponent
     * @returns {Number} base to the power of exponent.
     */
    static pow(base, exponent) {
        if (base === 0) {
            if (exponent === 0) {
                return 1;
            }
            return 0;
        }
        // exponent is an integer
        if (Math.floor(exponent) === exponent) {
            return Math.pow(base, exponent);
        }
        // exponent is not an integer
        if (base > 0) {
            return Math.exp(exponent * Math.log(base));
        }
        return NaN;
    }
    /**
     * Compute base to the power of the rational exponent m / n.
     * This function first reduces the fraction m/n and then computes
     * JXG.Math.pow(base, m/n).
     *
     * This function is necessary to have the same results for e.g.
     * (-8)^(1/3) = (-8)^(2/6) = -2
     * @param {Number} base
     * @param {Number} m numerator of exponent
     * @param {Number} n denominator of exponent
     * @returns {Number} base to the power of exponent.
     */
    static ratpow(base, m, n) {
        var g;
        if (m === 0) {
            return 1;
        }
        if (n === 0) {
            return NaN;
        }
        g = this.gcd(m, n);
        return this.nthroot(this.pow(base, m / g), n / g);
    }
    /**
     * Logarithm to base 10.
     * @param {Number} x
     * @returns {Number} log10(x) Logarithm of x to base 10.
     */
    static log10(x) {
        return Math.log(x) / Math.log(10.0);
    }
    /**
     * Logarithm to base 2.
     * @param {Number} x
     * @returns {Number} log2(x) Logarithm of x to base 2.
     */
    static log2(x) {
        return Math.log(x) / Math.log(2.0);
    }
    /**
     * Logarithm to arbitrary base b. If b is not given, natural log is taken, i.e. b = e.
     * @param {Number} x
     * @param {Number} b base
     * @returns {Number} log(x, b) Logarithm of x to base b, that is log(x)/log(b).
     */
    static log(x, b) {
        if (b !== undefined && Type.isNumber(b)) {
            return Math.log(x) / Math.log(b);
        }
        return Math.log(x);
    }
    /**
     * The sign() function returns the sign of a number, indicating whether the number is positive, negative or zero.
     *
     * @function
     * @param  {Number} x A Number
     * @returns {Number}  This function has 5 kinds of return values,
     *    1, -1, 0, -0, NaN, which represent "positive number", "negative number", "positive zero", "negative zero"
     *    and NaN respectively.
     */
    static sign(x) {
        return Math.sign(x);
    }
    /**
     * A square & multiply algorithm to compute base to the power of exponent.
     * Implementated by Wolfgang Riedl.
     *
     * @param {Number} base
     * @param {Number} exponent
     * @returns {Number} Base to the power of exponent
     */
    static squampow(base, exponent) {
        var result;
        if (Math.floor(exponent) === exponent) {
            // exponent is integer (could be zero)
            result = 1;
            if (exponent < 0) {
                // invert: base
                base = 1.0 / base;
                exponent *= -1;
            }
            while (exponent !== 0) {
                if (exponent & 1) {
                    result *= base;
                }
                exponent >>= 1;
                base *= base;
            }
            return result;
        }
        return this.pow(base, exponent);
    }
    /**
     * Greatest common divisor (gcd) of two numbers.
     * See {@link <a href="https://rosettacode.org/wiki/Greatest_common_divisor#JavaScript">rosettacode.org</a>}.
     *
     * @param  {Number} a First number
     * @param  {Number} b Second number
     * @returns {Number}   gcd(a, b) if a and b are numbers, NaN else.
     */
    static gcd(a, b) {
        var tmp, endless = true;
        a = Math.abs(a);
        b = Math.abs(b);
        if (!(Type.isNumber(a) && Type.isNumber(b))) {
            return NaN;
        }
        if (b > a) {
            tmp = a;
            a = b;
            b = tmp;
        }
        while (endless) {
            a %= b;
            if (a === 0) {
                return b;
            }
            b %= a;
            if (b === 0) {
                return a;
            }
        }
    }
    /**
     * Least common multiple (lcm) of two numbers.
     *
     * @param  {Number} a First number
     * @param  {Number} b Second number
     * @returns {Number}   lcm(a, b) if a and b are numbers, NaN else.
     */
    static lcm(a, b) {
        var ret;
        if (!(Type.isNumber(a) && Type.isNumber(b))) {
            return NaN;
        }
        ret = a * b;
        if (ret !== 0) {
            return ret / this.gcd(a, b);
        }
        return 0;
    }
    /**
     * Special use of Math.round function to round not only to integers but also to chosen decimal values.
     *
     * @param  value Value to be rounded.
     * @param  step Distance between the values to be rounded to. (default: 1.0)
     * @param  [min] If set, it will be returned the maximum of value and min.
     * @param  [max] If set, it will be returned the minimum of value and max.
     * @returns Fitted value.
     */
    static roundToStep(value, step = 1, min, max) {
        var n = value, tmp, minOr0;
        // for performance
        if (step == 1 && !min && !max) { // step is never false,check for ==1 instead
            return n;
        }
        // TODO: what is this?
        // if (!max) {
        //     n = Math.min(n, max);
        // }
        // if (!min) {
        //     n = Math.max(n, min);
        // }
        minOr0 = min || 0;
        //        if (!step) {
        tmp = (n - minOr0) / step;
        if (Number.isInteger(tmp)) {
            return n;
        }
        tmp = Math.round(tmp);
        n = minOr0 + tmp * step;
        // }
        // TODO what is this?
        // if (!max) {
        //     n = Math.min(n, max);
        // }
        // if (!min) {
        //     n = Math.max(n, min);
        // }
        return n;
    }
    /**
     *  Error function, see {@link https://en.wikipedia.org/wiki/Error_function}.
     *
     * @see JXG.Math.ProbFuncs.erf
     * @param  {Number} x
     * @returns {Number}
     */
    static erf(x) {
        return ProbFuncs.erf(x);
    }
    /**
     * Complementary error function, i.e. 1 - erf(x).
     *
     * @see JXG.Math.erf
     * @see JXG.Math.ProbFuncs.erfc
     * @param  {Number} x
     * @returns {Number}
     */
    static erfc(x) {
        return ProbFuncs.erfc(x);
    }
    /**
     * Inverse of error function
     *
     * @see JXG.Math.erf
     * @see JXG.Math.ProbFuncs.erfi
     * @param  {Number} x
     * @returns {Number}
     */
    static erfi(x) {
        return ProbFuncs.erfi(x);
    }
    /**
     * Normal distribution function
     *
     * @see JXG.Math.ProbFuncs.ndtr
     * @param  {Number} x
     * @returns {Number}
     */
    static ndtr(x) {
        return ProbFuncs.ndtr(x);
    }
    /**
     * Inverse of normal distribution function
     *
     * @see JXG.Math.ndtr
     * @see JXG.Math.ProbFuncs.ndtri
     * @param  {Number} x
     * @returns {Number}
     */
    static ndtri(x) {
        return ProbFuncs.ndtri(x);
    }
    /**
     * Returns sqrt(a * a + b * b) for a variable number of arguments.
     * This is a naive implementation which might be faster than Math.hypot.
     * The latter is numerically more stable.
     *
     * @param {Number} a Variable number of arguments.
     * @returns Number
     */
    static hypot(...a) {
        return Math.hypot(...a);
        // var i, le, a, sum;
        // le = arguments.length;
        // for (i = 0, sum = 0.0; i < le; i++) {
        //     a = arguments[i];
        //     sum += a * a;
        // }
        // return Math.sqrt(sum);
    }
    /**
     * Heaviside unit step function. Returns 0 for x &lt;, 1 for x &gt; 0, and 0.5 for x == 0.
     *
     * @param {Number} x
     * @returns Number
     */
    static hstep(x) {
        return (x > 0.0) ? 1 :
            ((x < 0.0) ? 0.0 : 0.5);
    }
    /**
     * Gamma function for real parameters by Lanczos approximation.
     * Implementation straight from {@link https://en.wikipedia.org/wiki/Lanczos_approximation}.
     *
     * @param {Number} z
     * @returns Number
     */
    static gamma(z) {
        var x, y, t, i, le, g = 7, 
        // n = 9,
        p = [
            1.0,
            676.5203681218851,
            -1259.1392167224028,
            771.32342877765313,
            -176.6150291621406,
            12.507343278686905,
            -0.13857109526572012,
            9.9843695780195716e-6,
            1.5056327351493116e-7
        ];
        if (z < 0.5) {
            y = Math.PI / (Math.sin(Math.PI * z) * this.gamma(1 - z)); // Reflection formula
        }
        else {
            z -= 1;
            x = p[0];
            le = p.length;
            for (i = 1; i < le; i++) {
                x += p[i] / (z + i);
            }
            t = z + g + 0.5;
            y = Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
        }
        return y;
    }
    /* ********************  Comparisons and logical operators ************** */
    /**
     * Logical test: a < b?
     *
     * @param {Number} a
     * @param {Number} b
     * @returns {Boolean}
     */
    static lt(a, b) {
        return a < b;
    }
    /**
     * Logical test: a <= b?
     *
     * @param {Number} a
     * @param {Number} b
     * @returns {Boolean}
     */
    static leq(a, b) {
        return a <= b;
    }
    /**
     * Logical test: a > b?
     *
     * @param {Number} a
     * @param {Number} b
     * @returns {Boolean}
     */
    static gt(a, b) {
        return a > b;
    }
    /**
     * Logical test: a >= b?
     *
     * @param {Number} a
     * @param {Number} b
     * @returns {Boolean}
     */
    static geq(a, b) {
        return a >= b;
    }
    /**
     * Logical test: a === b?
     *
     * @param {Number} a
     * @param {Number} b
     * @returns {Boolean}
     */
    static eq(a, b) {
        return a === b;
    }
    /**
     * Logical test: a !== b?
     *
     * @param {Number} a
     * @param {Number} b
     * @returns {Boolean}
     */
    static neq(a, b) {
        return a !== b;
    }
    /**
     * Logical operator: a && b?
     *
     * @param {Boolean} a
     * @param {Boolean} b
     * @returns {Boolean}
     */
    static and(a, b) {
        return a && b;
    }
    /**
     * Logical operator: !a?
     *
     * @param {Boolean} a
     * @returns {Boolean}
     */
    static not(a) {
        return !a;
    }
    /**
     * Logical operator: a || b?
     *
     * @param {Boolean} a
     * @param {Boolean} b
     * @returns {Boolean}
     */
    static or(a, b) {
        return a || b;
    }
    /**
     * Logical operator: either a or b?
     *
     * @param {Boolean} a
     * @param {Boolean} b
     * @returns {Boolean}
     */
    static xor(a, b) {
        return (a || b) && !(a && b);
    }
    /**
     *
     * Convert a floating point number to sign + integer + fraction.
     * fraction is given as nominator and denominator.
     * <p>
     * Algorithm: approximate the floating point number
     * by a continued fraction and simultaneously keep track
     * of its convergents.
     * Inspired by {@link https://kevinboone.me/rationalize.html}.
     *
     * @param  x Number which is to be converted
     * @param  [order=0.001] Small number determining the approximation precision.
     * @returns {Array} [sign, leading, nominator, denominator] where sign is 1 or -1.
     * @see JXG.toFraction
     *
     * @example
     * JXG.Math.decToFraction(0.33333333);
     * // Result: [ 1, 0, 1, 3 ]
     *
     * JXG.Math.decToFraction(0);
     * // Result: [ 1, 0, 0, 1 ]
     *
     * JXG.Math.decToFraction(-10.66666666666667);
     * // Result: [-1, 10, 2, 3 ]
    */
    static decToFraction(x, order) {
        var lead, sign, a, n, n1, n2, d, d1, d2, it = 0, maxit = 20;
        order = Type.def(order, 0.001);
        // Round the number.
        // Otherwise, 0.999999999 would result in [0, 1, 1].
        x = Math.round(x * 1.e12) * 1.e-12;
        // Negative numbers:
        // The minus sign is handled in sign.
        sign = (x < 0) ? -1 : 1;
        x = Math.abs(x);
        // From now on we consider x to be nonnegative.
        lead = Math.floor(x);
        x -= Math.floor(x);
        a = 0.0;
        n2 = 1.0;
        n = n1 = a;
        d2 = 0.0;
        d = d1 = 1.0;
        while (x - Math.floor(x) > order && it < maxit) {
            x = 1 / (x - a);
            a = Math.floor(x);
            n = n2 + a * n1;
            d = d2 + a * d1;
            n2 = n1;
            d2 = d1;
            n1 = n;
            d1 = d;
            it++;
        }
        return [sign, lead, n, d];
    }
    /* *************************** Normalize *************************** */
    /**
     * Normalize the standard form [c, b0, b1, a, k, r, q0, q1].
     * @private
     * @param {Array} stdform The standard form to be normalized.
     * @returns {Array} The normalized standard form.
     */
    static normalize(stdform) {
        var n, signr, a2 = 2 * stdform[3], r = stdform[4] / a2;
        stdform[5] = r;
        stdform[6] = -stdform[1] / a2;
        stdform[7] = -stdform[2] / a2;
        if (!isFinite(r)) {
            n = this.hypot(stdform[1], stdform[2]);
            stdform[0] /= n;
            stdform[1] /= n;
            stdform[2] /= n;
            stdform[3] = 0;
            stdform[4] = 1;
        }
        else if (Math.abs(r) >= 1) {
            stdform[0] = (stdform[6] * stdform[6] + stdform[7] * stdform[7] - r * r) / (2 * r);
            stdform[1] = -stdform[6] / r;
            stdform[2] = -stdform[7] / r;
            stdform[3] = 1 / (2 * r);
            stdform[4] = 1;
        }
        else {
            signr = r <= 0 ? -1 : 1;
            stdform[0] =
                signr * (stdform[6] * stdform[6] + stdform[7] * stdform[7] - r * r) * 0.5;
            stdform[1] = -signr * stdform[6];
            stdform[2] = -signr * stdform[7];
            stdform[3] = signr / 2;
            stdform[4] = signr * r;
        }
        return stdform;
    }
    /**
     * Converts a two-dimensional array to a one-dimensional Float32Array that can be processed by WebGL.
     * @param {Array} m A matrix in a two-dimensional array.
     * @returns {Float32Array} A one-dimensional array containing the matrix in column wise notation. Provides a fall
     * back to the default JavaScript Array if Float32Array is not available.
     */
    static toGL(m) {
        var v, i, j;
        if (typeof Float32Array === "function") {
            v = new Float32Array(16);
        }
        else {
            v = new Array(16);
        }
        if (m.length !== 4 && m[0].length !== 4) {
            return v;
        }
        for (i = 0; i < 4; i++) {
            for (j = 0; j < 4; j++) {
                v[i + 4 * j] = m[i][j];
            }
        }
        return v;
    }
    /**
     * Theorem of Vieta: Given a set of simple zeroes x_0, ..., x_n
     * of a polynomial f, compute the coefficients s_k, (k=0,...,n-1)
     * of the polynomial of the form. See {@link https://de.wikipedia.org/wiki/Elementarsymmetrisches_Polynom}.
     * <p>
     *  f(x) = (x-x_0)*...*(x-x_n) =
     *  x^n + sum_{k=1}^{n} (-1)^(k) s_{k-1} x^(n-k)
     * </p>
     * @param  x Simple zeroes of the polynomial.
     * @returns  Coefficients of the polynomial.
     *
     */
    static Vieta(x) {
        var n = x.length, s = [], m, k, y;
        s = x.slice();
        for (m = 1; m < n; ++m) {
            y = s[m];
            s[m] *= s[m - 1];
            for (k = m - 1; k >= 1; --k) {
                s[k] += s[k - 1] * y;
            }
            s[0] += y;
        }
        return s;
    }
}
/**
 * eps defines the closeness to zero. If the absolute value of a given number is smaller
 * than eps, it is considered to be equal to zero.
 * @type Number
 */
JSXMath.eps = 0.000001;

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */
/*global JXG: true, define: true, AMprocessNode: true, MathJax: true, document: true */
/*jslint nomen: true, plusplus: true*/
/**
 * @fileoverview In this file the Coords object is defined, a class to manage all
 * properties and methods coordinates usually have.
 */
let Coords$1 = class Coords {
    /**
     * Constructs a new Coordinates object.
     * @class This is the Coordinates class.
     * All members a coordinate has to provide
     * are defined here.
     * @param {Number} method The type of coordinates given by the user. Accepted values are <b>COORDS_BY_SCREEN</b> and <b>COORDS_BY_USER</b>.
     * @param {Array} coordinates An array of affine coordinates.
     * @param {Board} board A reference to a board.
     * @param {Boolean} [emitter=true]
     * @constructor
     */
    constructor(method, coordinates, board, emitter = true) {
        /**
         * If true, this coordinates object will emit update events every time
         * the coordinates are set.
         * @type boolean
         * @default true
         */
        this.emitter = true;
        if (board === undefined)
            throw new Error('who did not send Board??');
        // super(board,{})
        this.board = board;
        this.method = method;
        if (method === COORDS_BY.USER) {
            this.usrCoords = [1, coordinates[0], coordinates[1]];
            this.usr2screen();
        }
        else {
            this.scrCoords = [1, coordinates[0], coordinates[1]];
            this.screen2usr();
        }
        // this.board = board;
        // this.method = method
        // this.usrCoords = [];
        // //this.usrCoords = new Float64Array(3);
        // this.scrCoords = [];
        //this.scrCoords = new Float64Array(3);
        // if (this.emitter) {
        // EventEmitter.eventify(this);  // tb now handled by class hierarchy
        // }
        // this.setCoordinates(this.method, coordinates, false, true);
    }
    ;
    /**
     * Normalize homogeneous coordinates
     * @private
     */
    normalizeUsrCoords() {
        if (Math.abs(this.usrCoords[0]) > JSXMath.eps) {
            this.usrCoords[1] /= this.usrCoords[0];
            this.usrCoords[2] /= this.usrCoords[0];
            this.usrCoords[0] = 1.0;
        }
    }
    /**
     * Compute screen coordinates out of given user coordinates.
     * @private
     */
    usr2screen(doRound = false) {
        let b = this.board, uc = this.usrCoords, oc = b.origin.scrCoords;
        this.scrCoords = [];
        if (doRound === true) {
            this.scrCoords[0] = Math.round(uc[0]);
            this.scrCoords[1] = Math.round(uc[0] * oc[1] + uc[1] * b.unitX);
            this.scrCoords[2] = Math.round(uc[0] * oc[2] - uc[2] * b.unitY);
        }
        else {
            this.scrCoords[0] = uc[0];
            this.scrCoords[1] = uc[0] * oc[1] + uc[1] * b.unitX;
            this.scrCoords[2] = uc[0] * oc[2] - uc[2] * b.unitY;
        }
    }
    /**
     * Compute user coordinates out of given screen coordinates.
     * @private
     */
    screen2usr() {
        var o = this.board.origin.scrCoords, sc = this.scrCoords, b = this.board;
        this.usrCoords = [];
        this.usrCoords[0] = 1.0;
        this.usrCoords[1] = (sc[1] - o[1]) / b.unitX;
        this.usrCoords[2] = (o[2] - sc[2]) / b.unitY;
    }
    /**
     * Calculate distance of one point to another.
     * @param {Number} coord_type The type of coordinates used here. Possible values are <b>COORDS_BY.USER</b> and <b>COORDS_BY.SCREEN</b>.
     * @param {JXG.Coords} coordinates The Coords object to which the distance is calculated.
     * @returns {Number} The distance
     */
    distance(coord_type, coordinates) {
        var sum = 0, c, ucr = this.usrCoords, scr = this.scrCoords, f;
        if (coord_type === COORDS_BY.USER) {
            c = coordinates.usrCoords;
            f = ucr[0] - c[0];
            sum = f * f;
            if (sum > JSXMath.eps * JSXMath.eps) {
                return Number.POSITIVE_INFINITY;
            }
            return JSXMath.hypot(ucr[1] - c[1], ucr[2] - c[2]);
        }
        else {
            c = coordinates.scrCoords;
            return JSXMath.hypot(scr[1] - c[1], scr[2] - c[2]);
        }
    }
    /**
     * Set coordinates by either user coordinates or screen coordinates and recalculate the other one.
     * @param {Number} coord_type The type of coordinates used here. Possible values are <b>COORDS_BY_USER</b> and <b>COORDS_BY_SCREEN</b>.
     * @param {Array} coordinates An array of affine coordinates the Coords object is set to.
     * @param {Boolean} [doRound=true] flag If true or null round the coordinates in usr2screen. This is used in smooth curve plotting.
     * The IE needs rounded coordinates. Id doRound==false we have to round in updatePathString.
     * @param {Boolean} [noevent=false]
     * @returns {JXG.Coords} Reference to the coords object.
     */
    setCoordinates(coord_type, coordinates, doRound = true, noevent = false) {
        var uc = this.usrCoords, sc = this.scrCoords; 
        // Original values
        [uc[0], uc[1], uc[2]]; var os = [sc[0], sc[1], sc[2]];
        if (coord_type === COORDS_BY.USER) {
            if (coordinates.length === 2) {
                // Euclidean coordinates
                uc[0] = 1.0;
                uc[1] = coordinates[0];
                uc[2] = coordinates[1];
            }
            else {
                // Homogeneous coordinates (normalized)
                uc[0] = coordinates[0];
                uc[1] = coordinates[1];
                uc[2] = coordinates[2];
                this.normalizeUsrCoords();
            }
            this.usr2screen(doRound);
        }
        else {
            if (coordinates.length === 2) {
                // Euclidean coordinates
                sc[1] = coordinates[0];
                sc[2] = coordinates[1];
            }
            else {
                // Homogeneous coordinates (normalized)
                sc[1] = coordinates[1];
                sc[2] = coordinates[2];
            }
            this.screen2usr();
        }
        if (this.emitter && !noevent && (os[1] !== sc[1] || os[2] !== sc[2])) {
            // TODO: move triggerEventHandlers out of Coords !!
            // this.triggerEventHandlers(["update"], [ou, os]);
            throw new Error('move triggerEventHandlers out of Coords !!');
        }
        return this;
    }
    /**
     * Copy array, either scrCoords or usrCoords
     * Uses slice() in case of standard arrays and set() in case of
     * typed arrays.
     * @private
     * @param {String} obj Either 'scrCoords' or 'usrCoords'
     * @param {Number} offset Offset, defaults to 0 if not given
     * @returns {Array} Returns copy of the coords array either as standard array or as
     *   typed array.
     */
    copy(obj, offset) {
        if (offset === undefined) {
            offset = 0;
        }
        return this[obj].slice(offset);
    }
    /**
     * Test if one of the usrCoords is NaN or the coordinates are infinite.
     * @returns {Boolean} true if the coordinates are finite, false otherwise.
     */
    computeIsReal() {
        return (!isNaN(this.usrCoords[1] + this.usrCoords[2]) &&
            Math.abs(this.usrCoords[0]) > JSXMath.eps);
    }
    /**
     * Triggered whenever the coordinates change.
     * @name JXG.Coords#update
     * @param {Array} ou Old user coordinates
     * @param {Array} os Old screen coordinates
     * @event
     */
    __evt__update(ou, os) { }
    /**
     * @ignore
     */
    __evt() { }
};

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Andreas Walter,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */
var _a;
class Color {
    /**
     * Converts a valid HTML/CSS color string into a rgb value array. This is the base
     * function for the following wrapper functions which only adjust the output to
     * different flavors like an object, string or hex values.
     * @param {String|Array|Number} color A valid HTML or CSS styled color value, e.g. '#12ab21', '#abc', 'black'
     * or 'rgb(12, 132, 233)'. This can also be an array containing three color values either from 0.0 to 1.0 or
     * from 0 to 255. They will be interpreted as red, green, and blue values. In case this is a number this method
     * expects the parameters ag and ab.
     * @param {Number} ag
     * @param {Number} ab
     * @returns {Array} RGB color values as an array [r, g, b] with values ranging from 0 to 255.
     */
    static rgbParser(color, ag, ab) {
        var color_string, channels, re, processor, bits, i, r, g, b, values = color, testFloat;
        if (!Type.exists(color)) {
            return [];
        }
        if (Type.exists(ag) && Type.exists(ab)) {
            values = [color, ag, ab];
        }
        color_string = values;
        testFloat = false;
        if (Array.isArray(color_string)) {
            for (i = 0; i < 3; i++) {
                testFloat = testFloat || /\./.test(values[i].toString());
            }
            for (i = 0; i < 3; i++) {
                testFloat = testFloat && values[i] >= 0.0 && values[i] <= 1.0;
            }
            if (testFloat) {
                return [
                    Math.ceil(values[0] * 255),
                    Math.ceil(values[1] * 255),
                    Math.ceil(values[2] * 255)
                ];
            }
            return values;
        }
        if (typeof values === "string") {
            color_string = values;
        }
        // strip any leading #
        if (color_string.charAt(0) === "#") {
            // remove # if any
            color_string = color_string.slice(1, 7);
        }
        color_string = color_string.replace(/ /g, "").toLowerCase();
        // before getting into regexps, try simple matches
        // and overwrite the input
        color_string = this.simpleColors[color_string] || color_string;
        // search through the colorDefs definitions to find a match
        for (i = 0; i < this.colorDefs.length; i++) {
            re = this.colorDefs[i].re;
            processor = this.colorDefs[i].process;
            bits = re.exec(color_string);
            if (bits) {
                channels = processor(bits);
                r = channels[0];
                g = channels[1];
                b = channels[2];
            }
        }
        if (isNaN(r) || isNaN(g) || isNaN(b)) {
            return [];
        }
        // validate/cleanup values
        r = r < 0 || isNaN(r) ? 0 : r > 255 ? 255 : r;
        g = g < 0 || isNaN(g) ? 0 : g > 255 ? 255 : g;
        b = b < 0 || isNaN(b) ? 0 : b > 255 ? 255 : b;
        return [r, g, b];
    }
    ;
    static isColor(strColor) {
        var s = new Option().style;
        s.color = strColor;
        return s.color !== '';
    }
    ;
    /**
     * Converts a valid HTML/CSS color string into a string of the 'rgb(r, g, b)' format.
     * @param {String|Array|Number} color A valid HTML or CSS styled color value, e.g. '#12ab21', '#abc', 'black'
     * or 'rgb(12, 132, 233)'. This can also be an array containing three color values either from 0.0 to 1.0 or
     * from 0 to 255. They will be interpreted as red, green, and blue values. In case this is a number this method
     * expects the parameters ag and ab.
     * @param {Number} ag
     * @param {Number} ab
     * @returns {String} A 'rgb(r, g, b)' formatted string
     */
    static rgb2css(color, ag, ab) {
        var r;
        r = this.rgbParser(color, ag, ab);
        return "rgb(" + r[0] + ", " + r[1] + ", " + r[2] + ")";
    }
    ;
    /**
     * Converts a valid HTML/CSS color string into a HTML rgb string.
     * @param {String|Array|Number} color A valid HTML or CSS styled color value, e.g. '#12ab21', '#abc', 'black'
     * or 'rgb(12, 132, 233)'. This can also be an array containing three color values either from 0.0 to 1.0 or
     * from 0 to 255. They will be interpreted as red, green, and blue values. In case this is a number this method
     * expects the parameters ag and ab.
     * @param {Number} ag
     * @param {Number} ab
     * @returns {String} A '#rrggbb' formatted string
     */
    static rgb2hex(color, ag, ab) {
        var r, g, b;
        r = this.rgbParser(color, ag, ab);
        g = r[1];
        b = r[2];
        r = r[0];
        r = r.toString(16);
        g = g.toString(16);
        b = b.toString(16);
        if (r.length === 1) {
            r = "0" + r;
        }
        if (g.length === 1) {
            g = "0" + g;
        }
        if (b.length === 1) {
            b = "0" + b;
        }
        return "#" + r + g + b;
    }
    ;
    /**
     * Converts a valid HTML/CSS color string from the '#rrggbb' format into the 'rgb(r, g, b)' format.
     * @param {String} hex A valid HTML or CSS styled color value, e.g. '#12ab21', '#abc', or 'black'
     * @deprecated Use {@link JXG#rgb2css} instead.
     * @returns {String} A 'rgb(r, g, b)' formatted string
     */
    static hex2rgb(hex) {
        Env.deprecated("JXG.hex2rgb()", "JXG.rgb2css()");
        return this.rgb2css(hex);
    }
    ;
    /**
     * Converts HSV color to RGB color.
     * Based on C Code in "Computer Graphics -- Principles and Practice,"
     * Foley et al, 1996, p. 593.
     * See also https://www.had2know.org/technology/hsv-rgb-conversion-formula-calculator.html
     * @param {Number} H value between 0 and 360
     * @param {Number} S value between 0.0 (shade of gray) to 1.0 (pure color)
     * @param {Number} V value between 0.0 (black) to 1.0 (white)
     * @returns {String} RGB color string
     */
    static hsv2rgb(H, S, V) {
        var R, G, B, f, i, hTemp, p, q, t;
        H = ((H % 360.0) + 360.0) % 360;
        if (S === 0) {
            if (isNaN(H) || H < JSXMath.eps) {
                R = V;
                G = V;
                B = V;
            }
            else {
                return "#ffffff";
            }
        }
        else {
            if (H >= 360) {
                hTemp = 0.0;
            }
            else {
                hTemp = H;
            }
            // h is now IN [0,6)
            hTemp = hTemp / 60;
            // largest integer <= h
            i = Math.floor(hTemp);
            // fractional part of h
            f = hTemp - i;
            p = V * (1.0 - S);
            q = V * (1.0 - S * f);
            t = V * (1.0 - S * (1.0 - f));
            switch (i) {
                case 0:
                    R = V;
                    G = t;
                    B = p;
                    break;
                case 1:
                    R = q;
                    G = V;
                    B = p;
                    break;
                case 2:
                    R = p;
                    G = V;
                    B = t;
                    break;
                case 3:
                    R = p;
                    G = q;
                    B = V;
                    break;
                case 4:
                    R = t;
                    G = p;
                    B = V;
                    break;
                case 5:
                    R = V;
                    G = p;
                    B = q;
                    break;
            }
        }
        R = Math.round(R * 255).toString(16);
        R = R.length === 2 ? R : R.length === 1 ? "0" + R : "00";
        G = Math.round(G * 255).toString(16);
        G = G.length === 2 ? G : G.length === 1 ? "0" + G : "00";
        B = Math.round(B * 255).toString(16);
        B = B.length === 2 ? B : B.length === 1 ? "0" + B : "00";
        return ["#", R, G, B].join("");
    }
    ;
    /**
     * Converts a color from the RGB color space into the HSV space. Input can be any valid HTML/CSS color definition.
     * @param {String|Array|Number} color A valid HTML or CSS styled color value, e.g. '#12ab21', '#abc', 'black'
     * or 'rgb(12, 132, 233)'. This can also be an array containing three color values either from 0.0 to 1.0 or
     * from 0 to 255. They will be interpreted as red, green, and blue values. In case this is a number this method
     * expects the parameters ag and ab. See <a href="https://www.had2know.org/technology/hsv-rgb-conversion-formula-calculator.html">https://www.had2know.org/technology/hsv-rgb-conversion-formula-calculator.html</a>.
     * @param {Number} ag
     * @param {Number} ab
     * @returns {Array} Contains the h, s, and v value in this order.
     *
     */
    static rgb2hsv(color, ag, ab) {
        var r, g, b, fr, fg, fb, fmax, fmin, h, s, v, max, min;
        r = this.rgbParser(color, ag, ab);
        g = r[1];
        b = r[2];
        r = r[0];
        fr = r / 255.0;
        fg = g / 255.0;
        fb = b / 255.0;
        max = Math.max(r, g, b);
        min = Math.min(r, g, b);
        fmax = max / 255.0;
        fmin = min / 255.0;
        v = fmax;
        s = 0.0;
        if (v > 0) {
            s = (v - fmin) / v;
        }
        h = 1.0 / (fmax - fmin);
        if (s > 0) {
            if (max === r) {
                h = (fg - fb) * h;
            }
            else if (max === g) {
                h = 2 + (fb - fr) * h;
            }
            else {
                h = 4 + (fr - fg) * h;
            }
        }
        h *= 60;
        if (h < 0) {
            h += 360;
        }
        if (max === min) {
            h = 0.0;
        }
        return [h, s, v];
    }
    ;
    /**
     * Converts a color from the RGB color space into the LMS space. Input can be any valid HTML/CSS color definition.
     * @param {String|Array|Number} color A valid HTML or CSS styled color value, e.g. '#12ab21', '#abc', 'black'
     * or 'rgb(12, 132, 233)'. This can also be an array containing three color values either from 0.0 to 1.0 or
     * from 0 to 255. They will be interpreted as red, green, and blue values. In case this is a number this method
     * expects the parameters ag and ab.
     * @param {Number} ag
     * @param {Number} ab
     * @returns {Array} Contains the l, m, and s value in this order.
     */
    static rgb2LMS(color, ag, ab) {
        var r, g, b, l, m, s, ret, 
        // constants
        matrix = [
            [0.05059983, 0.08585369, 0.0095242],
            [0.01893033, 0.08925308, 0.01370054],
            [0.00292202, 0.00975732, 0.07145979]
        ];
        r = this.rgbParser(color, ag, ab);
        g = r[1];
        b = r[2];
        r = r[0];
        // de-gamma
        // Maybe this can be made faster by using a cache
        r = Math.pow(r, 0.476190476);
        g = Math.pow(g, 0.476190476);
        b = Math.pow(b, 0.476190476);
        l = r * matrix[0][0] + g * matrix[0][1] + b * matrix[0][2];
        m = r * matrix[1][0] + g * matrix[1][1] + b * matrix[1][2];
        s = r * matrix[2][0] + g * matrix[2][1] + b * matrix[2][2];
        ret = [l, m, s];
        ret.l = l;
        ret.m = m;
        ret.s = s;
        return ret;
    }
    ;
    /**
     * Convert color information from LMS to RGB color space.
     * @param {Number} l
     * @param {Number} m
     * @param {Number} s
     * @returns {Array} Contains the r, g, and b value in this order.
     */
    static LMS2rgb(l, m, s) {
        var r, g, b, ret, 
        // constants
        matrix = [
            [30.830854, -29.832659, 1.610474],
            [-6.481468, 17.715578, -2.532642],
            [-0.37569, -1.199062, 14.273846]
        ], 
        // re-gamma, inspired by GIMP modules/display-filter-color-blind.c:
        // Copyright (C) 2002-2003 Michael Natterer <mitch@gimp.org>,
        //                         Sven Neumann <sven@gimp.org>,
        //                         Robert Dougherty <bob@vischeck.com> and
        //                         Alex Wade <alex@vischeck.com>
        // This code is an implementation of an algorithm described by Hans Brettel,
        // Francoise Vienot and John Mollon in the Journal of the Optical Society of
        // America V14(10), pg 2647. (See http://vischeck.com/ for more info.)
        lut_lookup = function (value) {
            var offset = 127, step = 64;
            while (step > 0) {
                if (Math.pow(offset, 0.476190476) > value) {
                    offset -= step;
                }
                else {
                    if (Math.pow(offset + 1, 0.476190476) > value) {
                        return offset;
                    }
                    offset += step;
                }
                step /= 2;
            }
            /*  the algorithm above can't reach 255  */
            if (offset === 254 && 13.994955247 < value) {
                return 255;
            }
            return offset;
        };
        // transform back to rgb
        r = l * matrix[0][0] + m * matrix[0][1] + s * matrix[0][2];
        g = l * matrix[1][0] + m * matrix[1][1] + s * matrix[1][2];
        b = l * matrix[2][0] + m * matrix[2][1] + s * matrix[2][2];
        r = lut_lookup(r);
        g = lut_lookup(g);
        b = lut_lookup(b);
        ret = [r, g, b];
        ret.r = r;
        ret.g = g;
        ret.b = b;
        return ret;
    }
    ;
    /**
     * Splits a RGBA color value like #112233AA into it's RGB and opacity parts.
     * @param {String} rgba A RGBA color value
     * @returns {Array} An array containing the rgb color value in the first and the opacity in the second field.
     */
    static rgba2rgbo(rgba) {
        var opacity;
        if (rgba.length === 9 && rgba.charAt(0) === "#") {
            opacity = parseInt(rgba.slice(7, 9).toUpperCase(), 16) / 255;
            rgba = rgba.slice(0, 7);
        }
        else {
            opacity = 1;
        }
        return [rgba, opacity];
    }
    ;
    /**
     * Generates a RGBA color value like #112233AA from it's RGB and opacity parts.
     * @param {String|Array} rgb A valid HTML or CSS styled color value, e.g. '#12ab21', '#abc', 'black'
     * or 'rgb(12, 132, 233)'. This can also be an array containing three color values either from 0.0 to 1.0 or
     * from 0 to 255. They will be interpreted as red, green, and blue values.
     * @param {Number} o The desired opacity >=0, <=1.
     * @returns {String} The RGBA color value.
     */
    static rgbo2rgba(rgb, o) {
        var rgba;
        if (rgb === "none" || rgb === "transparent") {
            return rgb;
        }
        rgba = Math.round(o * 255).toString(16);
        if (rgba.length === 1) {
            rgba = "0" + rgba;
        }
        return this.rgb2hex(rgb) + rgba;
    }
    ;
    /**
     * Decolorizes the given color.
     * @param {String} color HTML string containing the HTML color code.
     * @returns {String} Returns a HTML color string
     */
    rgb2bw(color) {
        var x, tmp, arr, HexChars = "0123456789ABCDEF";
        if (color === "none") {
            return color;
        }
        arr = _a.rgbParser(color);
        x = Math.floor(0.3 * arr[0] + 0.59 * arr[1] + 0.11 * arr[2]);
        // rgbParser and Math.floor ensure that x is 0 <= x <= 255.
        // Bitwise operators can be used.
        /*jslint bitwise: true*/
        tmp = HexChars.charAt((x >> 4) & 0xf) + HexChars.charAt(x & 0xf);
        color = "#" + tmp + tmp + tmp;
        return color;
    }
    ;
    /**
     * Converts a color into how a colorblind human approximately would see it.
     * @param {String} color HTML string containing the HTML color code.
     * @param {String} deficiency The type of color blindness. Possible
     * options are <i>protanopia</i>, <i>deuteranopia</i>, and <i>tritanopia</i>.
     * @returns {String} Returns a HTML color string
     */
    static rgb2cb(color, deficiency) {
        var rgb, l, m, s, lms, tmp, a1, b1, c1, a2, b2, c2, inflection, HexChars = "0123456789ABCDEF";
        if (color === "none") {
            return color;
        }
        lms = this.rgb2LMS(color);
        l = lms[0];
        m = lms[1];
        s = lms[2];
        deficiency = deficiency.toLowerCase();
        switch (deficiency) {
            case "protanopia":
                a1 = -0.06150039994295001;
                b1 = 0.08277001656812001;
                c1 = -0.013200141220000003;
                a2 = 0.05858939668799999;
                b2 = -0.07934519995360001;
                c2 = 0.013289415272000003;
                inflection = 0.6903216543277437;
                tmp = s / m;
                if (tmp < inflection) {
                    l = -(b1 * m + c1 * s) / a1;
                }
                else {
                    l = -(b2 * m + c2 * s) / a2;
                }
                break;
            case "tritanopia":
                a1 = -58973116217e-14;
                b1 = 0.007690316482;
                c1 = -0.01011703519052;
                a2 = 0.025495080838999994;
                b2 = -0.0422740347;
                c2 = 0.017005316784;
                inflection = 0.8349489908460004;
                tmp = m / l;
                if (tmp < inflection) {
                    s = -(a1 * l + b1 * m) / c1;
                }
                else {
                    s = -(a2 * l + b2 * m) / c2;
                }
                break;
            default:
                a1 = -0.06150039994295001;
                b1 = 0.08277001656812001;
                c1 = -0.013200141220000003;
                a2 = 0.05858939668799999;
                b2 = -0.07934519995360001;
                c2 = 0.013289415272000003;
                inflection = 0.5763833686400911;
                tmp = s / l;
                if (tmp < inflection) {
                    m = -(a1 * l + c1 * s) / b1;
                }
                else {
                    m = -(a2 * l + c2 * s) / b2;
                }
                break;
        }
        rgb = this.LMS2rgb(l, m, s);
        // LMS2rgb returns an array of values ranging from 0 to 255 (both included)
        // bitwise operators are safe to use.
        /*jslint bitwise: true*/
        tmp = HexChars.charAt((rgb[0] >> 4) & 0xf) + HexChars.charAt(rgb[0] & 0xf);
        color = "#" + tmp;
        tmp = HexChars.charAt((rgb[1] >> 4) & 0xf) + HexChars.charAt(rgb[1] & 0xf);
        color += tmp;
        tmp = HexChars.charAt((rgb[2] >> 4) & 0xf) + HexChars.charAt(rgb[2] & 0xf);
        color += tmp;
        return color;
    }
    ;
    /**
     * Lightens (percent > 0) or darkens (percent < 0) the color by the specified factor.
     * @param {String} color
     * @param {Number} percent
     * @returns {String}
     */
    static shadeColor(color, percent) {
        var arr = this.rgbParser(color), r = arr[0], g = arr[1], b = arr[2];
        r = parseInt(r + 255 * percent);
        g = parseInt(g + 255 * percent);
        b = parseInt(b + 255 * percent);
        r = (r > 0) ? r : 0;
        g = (g > 0) ? g : 0;
        b = (b > 0) ? b : 0;
        r = (r < 255) ? r : 255;
        g = (g < 255) ? g : 255;
        b = (b < 255) ? b : 255;
        r = Math.round(r);
        g = Math.round(g);
        b = Math.round(b);
        return this.rgb2hex([r, g, b]);
    }
    ;
    /**
     * Lightens the color by the specified factor.
     * @param {String} color
     * @param {Number} percent
     * @returns {String}
     *
     * @see JXG.shadeColor
     */
    static lightenColor(color, percent) {
        return this.shadeColor(color, percent);
    }
    ;
    /**
     * Darkens the color by the specified factor.
     * @param {String} color
     * @param {Number} percent
     * @returns {String}
     *
     * @see JXG.shadeColor
     */
    static darkenColor(color, percent) {
        return this.shadeColor(color, -1 * percent);
    }
    ;
    /**
     * Determines highlight color to a given color. Done by reducing (or increasing) the opacity.
     * @param {String} color HTML RGBA string containing the HTML color code.
     * @returns {String} Returns a HTML RGBA color string
     */
    static autoHighlight(colstr) {
        var col = this.rgba2rgbo(colstr), c = col[0], opa = col[1];
        if (colstr.charAt(0) === "#") {
            if (opa < 0.3) {
                opa *= 1.8;
            }
            else {
                opa *= 0.4;
            }
            return this.rgbo2rgba(c, opa);
        }
        return colstr;
    }
    ;
    /**
     * Calculate whether a light or a dark color is needed as a contrast.
     * Especially useful to determine whether white or black font goes
     * better with a given background color.
     * @param {String} hexColor HEX value of color.
     * @param {String} [darkColor="#000000"] HEX string for a dark color.
     * @param {String} [lightColor="#ffffff"] HEX string for a light color.
     * @param {Number} [threshold=8]
     * @returns {String} Returns darkColor or lightColor.
     */
    static contrast(hexColor, darkColor, lightColor, threshold) {
        var rgb, black = "#000000", rgbBlack, l1, l2, contrastRatio;
        darkColor = darkColor || "#000000";
        lightColor = lightColor || "#ffffff";
        threshold = threshold || 7;
        // hexColor RGB
        rgb = this.rgbParser(hexColor);
        // Black RGB
        rgbBlack = this.rgbParser(black);
        // Calc contrast ratio
        l1 =
            0.2126 * Math.pow(rgb[0] / 255, 2.2) +
                0.7152 * Math.pow(rgb[1] / 255, 2.2) +
                0.0722 * Math.pow(rgb[2] / 255, 2.2);
        l2 =
            0.2126 * Math.pow(rgbBlack[0] / 255, 2.2) +
                0.7152 * Math.pow(rgbBlack[1] / 255, 2.2) +
                0.0722 * Math.pow(rgbBlack[2] / 255, 2.2);
        if (l1 > l2) {
            contrastRatio = Math.floor((l1 + 0.05) / (l2 + 0.05));
        }
        else {
            contrastRatio = Math.floor((l2 + 0.05) / (l1 + 0.05));
        }
        contrastRatio = contrastRatio - 1;
        // If contrast is more than threshold, return darkColor
        if (contrastRatio > threshold) {
            return darkColor;
        }
        // if not, return lightColor.
        return lightColor;
    }
    ;
    /**
     * Use the color scheme of JSXGraph up to version 1.3.2.
     * This method has to be called before JXG.JSXGraph.initBoard();
     *
     * @see JXG.palette
     * @see JXG.paletteWong
     *
     * @example
     *
     * JXG.setClassicColors();
     * var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 5, 5,-5]});
     *
     */
    setClassicColors() {
        throw new Error('fix me with set-attribute!!');
        // Options.elements.strokeColor = "blue";
        // Options.elements.fillColor = "red";
        // Options.hatch.strokeColor = "blue";
        // Options.angle.fillColor = "#ff7f00";
        // Options.angle.highlightFillColor = "#ff7f00";
        // Options.angle.strokeColor = "#ff7f00";
        // Options.angle.label.strokeColor = "blue";
        // Options.arc.strokeColor = "blue";
        // Options.circle.center.fillColor = "red";
        // Options.circle.center.strokeColor = "blue";
        // Options.circumcircle.strokeColor = "blue";
        // Options.circumcircle.center.fillColor = "red";
        // Options.circumcircle.center.strokeColor = "blue";
        // Options.circumcirclearc.strokeColor = "blue";
        // Options.circumcirclesector.strokeColor = "blue";
        // Options.circumcirclesector.fillColor = "green";
        // Options.circumcirclesector.highlightFillColor = "green";
        // Options.conic.strokeColor = "blue";
        // Options.curve.strokeColor = "blue";
        // Options.incircle.strokeColor = "blue";
        // Options.incircle.center.fillColor = "red";
        // Options.incircle.center.strokeColor = "blue";
        // Options.inequality.fillColor = "red";
        // Options.integral.fillColor = "red";
        // Options.integral.curveLeft.color = "red";
        // Options.integral.curveRight.color = "red";
        // Options.line.strokeColor = "blue";
        // Options.point.fillColor = "red";
        // Options.point.strokeColor = "red";
        // Options.polygon.fillColor = "green";
        // Options.polygon.highlightFillColor = "green";
        // Options.polygon.vertices.strokeColor = "red";
        // Options.polygon.vertices.fillColor = "red";
        // Options.regularpolygon.fillColor = "green";
        // Options.regularpolygon.highlightFillColor = "green";
        // Options.regularpolygon.vertices.strokeColor = "red";
        // Options.regularpolygon.vertices.fillColor = "red";
        // Options.riemannsum.fillColor = "yellow";
        // Options.sector.fillColor = "green";
        // Options.sector.highlightFillColor = "green";
        // Options.semicircle.center.fillColor = "red";
        // Options.semicircle.center.strokeColor = "blue";
        // Options.slopetriangle.fillColor = "red";
        // Options.slopetriangle.highlightFillColor = "red";
        // Options.turtle.arrow.strokeColor = "blue";
    }
    ;
}
_a = Color;
// private constants and helper functions
// simple colors contains string color constants that can be used in various browser
// in javascript
Color.simpleColors = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "00ffff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000000",
    blanchedalmond: "ffebcd",
    blue: "0000ff",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "00ffff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dodgerblue: "1e90ff",
    feldspar: "d19275",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "ff00ff",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgrey: "d3d3d3",
    lightgreen: "90ee90",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslateblue: "8470ff",
    lightslategray: "778899",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "00ff00",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "ff00ff",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370d8",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "d87093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    red: "ff0000",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    venetianred: "ae181e",
    violet: "ee82ee",
    violetred: "d02090",
    wheat: "f5deb3",
    white: "ffffff",
    whitesmoke: "f5f5f5",
    yellow: "ffff00",
    yellowgreen: "9acd32"
};
// array of color definition objects
Color.colorDefs = [
    {
        re: /^\s*rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*([\d.]{1,3})\s*\)\s*$/,
        example: ["rgba(123, 234, 45, 0.5)", "rgba(255,234,245,1.0)"],
        process: function (bits) {
            return [parseInt(bits[1], 10), parseInt(bits[2], 10), parseInt(bits[3], 10)];
        }
    },
    {
        re: /^\s*rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)\s*$/,
        example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],
        process: function (bits) {
            return [parseInt(bits[1], 10), parseInt(bits[2], 10), parseInt(bits[3], 10)];
        }
    },
    {
        re: /^(\w{2})(\w{2})(\w{2})$/,
        example: ["#00ff00", "336699"],
        process: function (bits) {
            return [parseInt(bits[1], 16), parseInt(bits[2], 16), parseInt(bits[3], 16)];
        }
    },
    {
        re: /^(\w{1})(\w{1})(\w{1})$/,
        example: ["#fb0", "f0f"],
        process: function (bits) {
            return [
                parseInt(bits[1] + bits[1], 16),
                parseInt(bits[2] + bits[2], 16),
                parseInt(bits[3] + bits[3], 16)
            ];
        }
    }
];
/**
 * Bang Wong color palette,
 * optimized for various type
 * of color blindness.
 * It contains values for
 * <ul>
 * <li> 'black'
 * <li> 'orange'
 * <li> 'skyblue'
 * <li> 'bluishgreen'
 * <li> 'yellow'
 * <li> 'darkblue'
 * <li> 'vermillion'
 * <li> 'reddishpurple'
 * </ul>
 *
 * As substitutes for standard colors, it contains the following aliases:
 *
 * <ul>
 * <li> black (= #000000)
 * <li> blue (= darkblue)
 * <li> green (= bluishgreen)
 * <li> purple (= reddishpurple)
 * <li> red (= vermillion)
 * <li> white (= #ffffff)
 * </ul>
 *
 * See <a href="https://www.nature.com/articles/nmeth.1618">Bang Wong: "Points of view: Color blindness"</a>
 * and
 * <a href="https://davidmathlogic.com/colorblind/">https://davidmathlogic.com/colorblind/</a>.
 *
 * @name JXG.paletteWong
 * @type Object
 * @see JXG.palette
 * @example
 * var p = board.create('line', [[-1, 1], [2, -3]], {strokeColor: JXG.paletteWong.yellow});
 */
Color.paletteWong = {
    black: "#000000",
    orange: "#E69F00",
    skyblue: "#56B4E9",
    bluishgreen: "#009E73",
    yellow: "#F0E442",
    darkblue: "#0072B2",
    vermillion: "#D55E00",
    reddishpurple: "#CC79A7",
    blue: "#0072B2",
    red: "#D55E00", // vermillion
    green: "#009E73", // bluishgreen
    purple: "#CC79A7", // reddishpurple
    white: "#ffffff"
};
/**
 * Default color palette.
 * Contains at least color values for
 * <ul>
 * <li> black
 * <li> blue
 * <li> green
 * <li> purple
 * <li> red
 * <li> white
 * <li> yellow
 * </ul>
 *
 * @name JXG.palette
 * @type Object
 * @default JXG.paletteWong
 * @see JXG.paletteWong
 *
 * @example
 *
 * var p = board.create('line', [[-1, 1], [2, -3]], {strokeColor: JXG.palette.yellow});
 *
 */
Color.palette = _a.paletteWong;

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRAN
    TY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */
/*global JXG:true define: true*/
/*jslint nomen: true plusplus: true*/
// import { JXG } from "./jxg.js";
// import { Board } from "./base/board.js";
/**
 * Options Namespace
 * @description These are the default options of the board and of all geometry elements.
 * @namespace
 * @name JXG.Options
 */
// Board and GeometryElement extend Events.  CoordsElement extends Coords.
class Options {
    /**
     * Holds all possible properties and the according validators for geometry elements.
     * A validator is either a function
     * which takes one parameter and returns true if the value is valid for the property,
     * or it is false if no validator is required.
     */
    static Validator() {
        var i;
        let validatePixel = function (v) { return (/^[0-9]+px$/).test(v); };
        let validateDisplay = function (v) { return (v === 'html' || v === 'internal'); };
        let validateColor = function (v) { return Type.isString(v); }; // for now this should do it...
        let validatePointFace = (v) => { return Type.exists(this.normalizePointFace(v)); };
        let validateNumber = function (v) { return Type.isNumber(v, true, false); };
        let validateInteger = function (v) { return (Math.abs(v - Math.round(v)) < JSXMath.eps); };
        let validateNotNegativeInteger = function (v) { return validateInteger(v) && v >= 0; };
        let validatePositiveInteger = function (v) { return validateInteger(v) && v > 0; };
        // validateScreenCoords = function (v) {
        //     return v.length >= 2 && validateInteger(v[0]) && validateInteger(v[1]);
        // }
        let validateRenderer = function (v) { return (v === 'vml' || v === 'svg' || v === 'canvas' || v === 'no'); };
        let validatePositive = function (v) { return v > 0; };
        let validateNotNegative = function (v) { return v >= 0; };
        let v = {};
        let validators = {
            attractorDistance: validateNotNegative,
            color: validateColor,
            // defaultDistance: validateNumber,
            display: validateDisplay,
            doAdvancedPlot: false,
            draft: false,
            drawLabels: false,
            drawZero: false,
            face: validatePointFace,
            factor: validateNumber,
            fillColor: validateColor,
            fillOpacity: validateNumber,
            firstArrow: false,
            fontSize: validateInteger,
            dash: validateInteger,
            gridX: validateNumber,
            gridY: validateNumber,
            // POI: Do we have to add something here?
            hasGrid: false,
            highlightFillColor: validateColor,
            highlightFillOpacity: validateNumber,
            highlightStrokeColor: validateColor,
            highlightStrokeOpacity: validateNumber,
            insertTicks: false,
            //: validateScreenCoords,
            lastArrow: false,
            layer: validateNotNegativeInteger,
            majorHeight: validateInteger,
            minorHeight: validateInteger,
            minorTicks: validateNotNegative,
            minTicksDistance: validatePositiveInteger,
            numberPointsHigh: validatePositiveInteger,
            numberPointsLow: validatePositiveInteger,
            opacity: validateNumber,
            radius: validateNumber,
            RDPsmoothing: false,
            renderer: validateRenderer,
            right: validatePixel,
            showCopyright: false,
            showInfobox: false,
            showNavigation: false,
            size: validateNotNegative, //validateInteger,
            snapSizeX: validatePositive,
            snapSizeY: validatePositive,
            snapWidth: validateNumber,
            snapToGrid: false,
            snatchDistance: validateNotNegative,
            straightFirst: false,
            straightLast: false,
            stretch: false,
            strokeColor: validateColor,
            strokeOpacity: validateNumber,
            strokeWidth: validateNotNegative, //validateInteger,
            takeFirst: false,
            takeSizeFromFile: false,
            to10: false,
            toOrigin: false,
            translateTo10: false,
            translateToOrigin: false,
            useASCIIMathML: false,
            useDirection: false,
            useMathJax: false,
            withLabel: false,
            withTicks: false,
            zoom: false,
        };
        // this seems like a redundant step but it makes sure that
        // all properties in the validator object have lower case names
        // and the validator object is easier to read.
        for (i in validators) {
            if (validators.hasOwnProperty(i)) {
                v[i.toLowerCase()] = validators[i];
            }
        }
        return v;
    }
    /**
     * All point faces can be defined with more than one name, e.g. a cross faced point can be given
     * by face equal to 'cross' or equal to 'x'. This method maps all possible values to fixed ones to
     * simplify if- and switch-clauses regarding point faces. The translation table is as follows:
     * <table>
     * <tr><th>Input</th><th>Output</th></tr>
     * <tr><td>cross</td><td>x</td></tr>
     * <tr><td>circle</td><td>o</td></tr>
     * <tr><td>square, []</td><td>[]</td></tr>
     * <tr><td>plus</td><td>+</td></tr>
     * <tr><td>minus</td><td>-</td></tr>
     * <tr><td>divide</td><td>|</td></tr>
     * <tr><td>diamond</td><td>&lt;&gt;</td></tr>
     * <tr><td>triangleup</td><td>^, a, A</td></tr>
     * <tr><td>triangledown</td><td>v</td></tr>
     * <tr><td>triangleleft</td><td>&lt;</td></tr>
     * <tr><td>triangleright</td><td>&gt;</td></tr>
     * </table>
     * @param {String} s A string which should determine a valid point face.
     * @returns {String} Returns a normalized string or undefined if the given string is not a valid
     * point face.
     */
    static normalizePointFace(s) {
        var map = {
            cross: 'x',
            x: 'x',
            circle: 'o',
            o: 'o',
            square: '[]',
            '[]': '[]',
            plus: '+',
            '+': '+',
            divide: '|',
            '|': '|',
            minus: '-',
            '-': '-',
            diamond: '<>',
            '<>': '<>',
            diamond2: '<<>>',
            '<<>>': '<<>>',
            triangleup: '^',
            A: '^',
            a: '^',
            '^': '^',
            triangledown: 'v',
            v: 'v',
            triangleleft: '<',
            '<': '<',
            triangleright: '>',
            '>': '>'
        };
        return map[s];
    }
    ;
}
Options.dummyOption = {
    dummy: true,
    jc: { enabled: false }
};
Options.jc = {
    enabled: true,
    compile: true,
};
Options.layer = {
    numlayers: 20, // only important in SVG
    unused9: 19,
    unused8: 18,
    unused7: 17,
    unused6: 16,
    unused5: 15,
    unused4: 14,
    unused3: 13,
    unused2: 12,
    unused1: 11,
    unused0: 10,
    text: 9,
    point: 9,
    glider: 9,
    arc: 8,
    line: 7,
    circle: 6,
    curve: 5,
    turtle: 5,
    polygon: 3,
    sector: 3,
    angle: 3,
    integral: 3,
    axis: 2,
    ticks: 2,
    grid: 1,
    image: 0,
    trace: 0,
    board: 0,
};
// TODO: GEONEXT ??  // static jc: JcOptions = {
// TODO: GEONEXT ??  //     enabled: true,
// TODO: GEONEXT ??  //     compile: true,
// TODO: GEONEXT ??  // }
/*
 * Options that are used directly within the board class
 */
Options.board = {
    animationDelay: 35,
    axis: false,
    boundingBox: [-5, 5, 5, -5],
    browserPan: false,
    clickDelay: 600,
    dblClickSuppressClick: false,
    defaultAxes: {
        x: {
            name: 'x',
            fixed: true,
            needsRegularUpdate: false,
            ticks: {
                label: {
                    visible: 'inherit',
                    anchorX: 'middle',
                    anchorY: 'top',
                    fontSize: 12,
                    offset: [0, -3]
                },
                tickEndings: [0, 1],
                majorTickEndings: [1, 1],
                drawZero: false,
                visible: 'inherit'
            }
        },
        y: {
            name: 'y',
            fixed: true,
            needsRegularUpdate: false,
            ticks: {
                label: {
                    visible: 'inherit',
                    anchorX: 'right',
                    anchorY: 'middle',
                    fontSize: 12,
                    offset: [-6, 0]
                },
                tickEndings: [1, 0],
                majorTickEndings: [1, 1],
                drawZero: false,
                visible: 'inherit',
            }
        }
    },
    document: null,
    drag: { enabled: true },
    fullscreen: {
        symbol: '<svg height="1em" width="1em" version="1.1" viewBox="10 10 18 18"><path fill="#666" d="m 10,16 2,0 0,-4 4,0 0,-2 L 10,10 l 0,6 0,0 z"></path><path fill="#666" d="m 20,10 0,2 4,0 0,4 2,0 L 26,10 l -6,0 0,0 z"></path><path fill="#666" d="m 24,24 -4,0 0,2 L 26,26 l 0,-6 -2,0 0,4 0,0 z"></path><path fill="#666" d="M 12,20 10,20 10,26 l 6,0 0,-2 -4,0 0,-4 0,0 z"></path></svg>',
        // symbol: '\u26f6', // '\u26f6' (not supported by MacOS),
        scale: 0.85,
        id: null
    },
    ignoreLabels: true,
    intl: { enabled: false },
    keepAspectRatio: false,
    keyboard: { enabled: true, dx: 10, dy: 10, panShift: true, panCtrl: false },
    logging: { enabled: false },
    minimizeReflow: 'none',
    maxBoundingBox: [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY],
    maxFrameRate: 40,
    maxNameLength: 1,
    moveTarget: null,
    offsetX: 0,
    offsetY: 0,
    pan: { enabled: true, needShift: true, needTwoFingers: false, },
    registerEvents: true,
    renderer: 'auto',
    resize: { enabled: true, throttle: 10, },
    screenshot: {
        scale: 1,
        type: 'png',
        symbol: '\u2318', //'\u22b9', //'\u26f6',
        css: 'background-color:#eeeeee; opacity:1.0; border:2px solid black; border-radius:10px; text-align:center',
        cssButton: 'padding: 4px 10px; border: solid #356AA0 1px; border-radius: 5px; position: absolute; right: 2ex; top: 2ex; background-color: rgba(255, 255, 255, 0.3);'
    },
    selection: {
        enabled: false, name: 'selectionPolygon', needShift: false, needCtrl: true, fillColor: '#ffff00',
        // immutable:
        visible: false, withLines: false, vertices: { visible: false, },
    },
    showClearTraces: false,
    showCopyright: true,
    showFullscreen: false,
    showInfobox: true,
    showLogo: false,
    showNavigation: true,
    showReload: false,
    showScreenshot: false,
    showZoom: true,
    takeFirst: false,
    takeSizeFromFile: false,
    theme: 'default',
    title: '',
    zoom: {
        enabled: true,
        factorX: 1.25,
        factorY: 1.25,
        wheel: true,
        needShift: true,
        center: 'auto',
        min: 0.0001,
        max: 10000.0,
        pinch: true,
        pinchHorizontal: true,
        pinchVertical: true,
        pinchSensitivity: 7,
    },
    zoomX: 1,
    zoomY: 1,
};
Options.navbar = {
    strokeColor: '#333333',
    fillColor: 'transparent', //#f5f5f5',
    highlightFillColor: '#aaaaaa',
    padding: '2px',
    position: 'absolute',
    fontSize: '14px',
    cursor: 'pointer',
    zIndex: '100',
    right: '5px',
    bottom: '5px'
};
Options.elements = {
    aria: { enabled: false, label: '', live: 'assertive', },
    cssClass: '',
    highlightCssClass: '',
    dash: 0,
    dashScale: false,
    draft: { draft: false, strokeColor: '#565656', fillColor: '#565656', strokeOpacity: 0.8, fillOpacity: 0.8, strokeWidth: 1, },
    dragToTopOfLayer: false,
    element3D: null,
    fillColor: Color.palette.red,
    fillOpacity: 1,
    fixed: false,
    frozen: false,
    gradient: null,
    gradientAngle: 0,
    gradientCX: 0.5,
    gradientCY: 0.5,
    gradientEndOffset: 1.0,
    gradientFX: 0.5,
    gradientFY: 0.5,
    gradientFR: 0.0,
    gradientR: 0.5,
    gradientSecondColor: '#ffffff',
    gradientSecondOpacity: 1,
    gradientStartOffset: 0.0,
    highlight: true,
    highlightFillColor: 'none',
    highlightFillOpacity: 1,
    highlightStrokeColor: '#c3d9ff',
    highlightStrokeOpacity: 1,
    highlightStrokeWidth: 2,
    isLabel: false,
    layer: 0,
    lineCap: 'butt',
    needsRegularUpdate: true,
    nonnegativeOnly: false,
    precision: 'inherit',
    priv: false,
    rotatable: true,
    scalable: true,
    shadow: { enabled: false, color: [0, 0, 0], opacity: 1, blur: 3, blend: 0.1, offset: [5, 5] },
    snapToGrid: false,
    strokeColor: Color.palette.blue,
    strokeOpacity: 1,
    strokeWidth: 2,
    tabindex: -1,
    trace: false,
    traceAttributes: {},
    transitionDuration: 100,
    transitionProperties: ['fill', 'fill-opacity', 'stroke', 'stroke-opacity', 'stroke-width'],
    visible: true,
    withLabel: false,
    ignoreForLabelAutoposition: false
};
Options.text = {
    fontSize: 12,
    fontUnit: 'px',
    formatNumber: false,
    digits: 2,
    intl: {
        enabled: 'inherit',
        options: {
            minimumFractionDigits: 0,
            maximumFractionDigits: 2,
        }
    },
    parse: true,
    useCaja: false,
    isLabel: false,
    strokeColor: '#000000',
    highlightStrokeColor: '#000000',
    highlightStrokeOpacity: 0.666666,
    cssDefaultStyle: 'font-family: Arial, Helvetica, Geneva, sans-serif;',
    highlightCssDefaultStyle: 'font-family: Arial, Helvetica, Geneva, sans-serif;',
    cssStyle: '',
    highlightCssStyle: '',
    transitionProperties: ['color', 'opacity'],
    useASCIIMathML: false,
    useMathJax: false,
    useKatex: false,
    katexMacros: {},
    toFraction: false,
    display: 'html',
    anchor: null,
    anchorX: 'left',
    anchorY: 'middle',
    cssClass: 'JXGtext',
    highlightCssClass: 'JXGtext',
    dragArea: 'all',
    withLabel: false,
    rotate: 0,
    visible: true,
    snapSizeX: 1,
    snapSizeY: 1,
    attractors: []
};
Options.point = {
    withLabel: true,
    label: {},
    style: 5,
    face: 'o',
    size: 3,
    sizeUnit: 'screen',
    strokeWidth: 2,
    transitionProperties: ['fill', 'fill-opacity', 'stroke', 'stroke-opacity', 'stroke-width', 'width', 'height', 'rx', 'ry'],
    fillColor: Color.palette.red,
    strokeColor: Color.palette.red,
    highlightFillColor: '#c3d9ff',
    highlightStrokeColor: '#c3d9ff',
    zoom: false,
    showInfobox: 'inherit',
    infoboxDigits: 'auto',
    draft: false,
    attractors: [],
    attractorUnit: 'user',
    attractorDistance: 0.0,
    snatchDistance: 0.0,
    snapToGrid: false,
    attractToGrid: false,
    snapSizeX: 1,
    snapSizeY: 1,
    snapToPoints: false,
    ignoredSnapToPoints: [],
};
Options.grid = {
    needsRegularUpdate: false,
    hasGrid: false, // Used in standardoptions
    highlight: false,
    majorStep: 'auto',
    minorElements: 0,
    forceSquare: false,
    includeBoundaries: false,
    size: undefined,
    face: undefined,
    margin: undefined,
    drawZero: undefined,
    polygonVertices: undefined,
    major: { size: 5, margin: 0, drawZero: true, polygonVertices: 6 },
    minor: { visible: 'inherit', size: 3, face: 'point', margin: 0, drawZero: true, polygonVertices: 6 },
    snapToGrid: false,
    strokeColor: '#c0c0c0',
    strokeWidth: 1,
    strokeOpacity: 0.5,
    dash: 0,
    theme: 0,
    themes: [
        {
        // default values
        },
        {
            forceSquare: 'min',
            major: {
                face: 'line'
            }
        },
        {
            major: {
                face: 'line'
            },
            minor: {
                size: 3,
                face: 'point'
            },
            minorElements: 'auto'
        },
        {
            major: {
                face: 'line'
            },
            minor: {
                face: 'line',
                strokeOpacity: 0.25
            },
            minorElements: 'auto'
        },
        {
            major: {
                face: 'line'
            },
            minor: {
                face: '+',
                size: '95%'
            },
            minorElements: 'auto'
        },
        {
            major: {
                face: '+',
                size: 10,
                strokeOpacity: 1
            },
            minor: {
                face: 'point',
                size: 3
            },
            minorElements: 'auto'
        },
        {
            major: {
                face: 'circle',
                size: 8,
                fillColor: '#c0c0c0'
            },
            minor: {
                face: 'point',
                size: 3
            },
            minorElements: 'auto'
        },
    ]
};
Options.label = {
    visible: 'inherit',
    strokeColor: '#000000',
    strokeOpacity: 1,
    highlightStrokeOpacity: 0.666666,
    highlightStrokeColor: '#000000',
    fixed: true,
    tabindex: null,
    position: 'urt',
    distance: 1.5,
    offset: [10, 10],
    autoPosition: false,
    autoPositionMinDistance: 12,
    autoPositionMaxDistance: 28,
    autoPositionWhitelist: [],
};
/* special legend options */
Options.legend = {
    style: 'vertical',
    labels: ['1', '2', '3', '4', '5', '6', '7', '8'],
    colors: ['#B02B2C', '#3F4C6B', '#C79810', '#D15600', '#FFFF88', '#c3d9ff', '#4096EE', '#008C00'],
    lineLength: 1,
    strokeOpacity: [1],
    rowHeight: 20,
    strokeWidth: 5,
    frozen: false,
};
/*
 *  Generic options used by {@link JXG.Ticks}
 */
Options.ticks = {
    generateLabelText: null,
    generateLabelValue: null,
    drawLabels: false,
    label: { tabindex: null, layer: 7, highlight: false, autoPosition: false }, // line layer
    beautifulScientificTickLabels: false,
    useUnicodeMinus: true,
    anchor: 'left',
    drawZero: false,
    insertTicks: false,
    minTicksDistance: 10,
    minorHeight: 4,
    majorHeight: 10,
    tickEndings: [1, 1],
    majorTickEndings: [1, 1],
    ignoreInfiniteTickEndings: true,
    minorTicks: 4,
    ticksPerLabel: false,
    scale: 1,
    scaleSymbol: '',
    labels: [],
    maxLabelLength: 5,
    precision: 3,
    digits: 3,
    ticksDistance: 1,
    face: '|',
    strokeOpacity: 1,
    strokeWidth: 1,
    strokeColor: '#000000',
    highlightStrokeColor: '#888888',
    fillColor: 'none',
    highlightFillColor: 'none',
    visible: 'inherit',
    includeBoundaries: false,
    type: 'linear',
    intl: {
        enabled: 'inherit',
        options: {}
    },
    // TODO implementation and documentation
    minorTicksInArrow: false,
    majorTicksInArrow: true,
    labelInArrow: true,
    minorTicksInMargin: false,
    majorTicksInMargin: true,
    labelInMargin: true,
    ignoreForLabelAutoposition: true,
    // close the meta tag
    /**#@-*/
};
/*
 *  Generic options used by {@link JXG.Hatch}
 */
Options.hatch = {
    drawLabels: false,
    drawZero: true,
    majorHeight: 20,
    anchor: 'middle',
    face: '|',
    strokeWidth: 2,
    strokeColor: Color.palette.blue,
    ticksDistance: 0.2
};
/**
 * Precision options, defining how close a pointer device (mouse, finger, pen) has to be
 * to an object such that the object is highlighted or can be dragged.
 * These values are board-wide and can be overwritten for individual elements by
 * changing their precision attribute.
 *
 * The default values are
 * <pre>
 * JXG.Options.precision: {
 *   touch: 30,
 *   touchMax: 100,
 *   mouse: 4,
 *   pen: 4,
 *   epsilon: 0.0001,
 *   hasPoint: 4
 * }
 * </pre>
 *
 * @type Object
 * @name JXG.Options#precision
 * @see JXG.GeometryElement#precision
 */
Options.precision = {
    touch: 30,
    touchMax: 100,
    mouse: 4,
    pen: 4,
    epsilon: 0.0001, // Unused
    hasPoint: 4
};
/* special angle options */
Options.angle = {
    withLabel: true,
    radius: 'auto',
    type: 'sector',
    orthoType: 'square',
    orthoSensitivity: 1.0,
    fillColor: Color.palette.orange,
    highlightFillColor: Color.palette.orange,
    strokeColor: Color.palette.orange,
    fillOpacity: 0.3,
    highlightFillOpacity: 0.3,
    radiuspoint: { withLabel: false, visible: false, name: '', },
    pointsquare: { withLabel: false, visible: false, name: '', },
    dot: { visible: false, strokeColor: 'none', fillColor: '#000000', size: 2, face: 'o', withLabel: false, name: '', },
    label: { position: 'top', offset: [0, 0], strokeColor: Color.palette.blue, },
    arc: { visible: false, fillColor: 'none', },
};
/* special arc options */
Options.arc = {
    selection: 'auto',
    hasInnerPoints: false,
    label: { anchorX: 'auto', anchorY: 'auto', },
    firstArrow: false,
    lastArrow: false,
    fillColor: 'none',
    highlightFillColor: 'none',
    strokeColor: Color.palette.blue,
    highlightStrokeColor: '#c3d9ff',
    useDirection: false,
    center: null, // was {}
    radiusPoint: null, // was {}
    anglePoint: null, // was {}
    /**#@-*/
};
/* special arrow options */
Options.arrow = {
    firstArrow: false,
    lastArrow: { type: 1, highlightSize: 6, size: 6 },
};
/* special arrowparallel options */
Options.arrowparallel = {
    firstArrow: false,
    lastArrow: { type: 1, highlightSize: 6, size: 6 },
};
/* special axis options */
Options.axis = {
    name: '', // By default, do not generate names for axes.
    needsRegularUpdate: false, // Axes only updated after zooming and moving of the origin.
    strokeWidth: 1,
    lastArrow: { type: 1, highlightSize: 8, size: 8 },
    strokeColor: '#666666',
    highlightStrokeWidth: 1,
    highlightStrokeColor: '#888888',
    position: 'static',
    anchor: '',
    anchorDist: '10%',
    ticksAutoPos: false,
    ticksAutoPosThreshold: '5%',
    withTicks: true,
    straightFirst: true,
    straightLast: true,
    margin: -4,
    withLabel: false,
    scalable: false,
    /**
     * Attributes for ticks of the axis.
     *
     * @type Ticks
     * @name Axis#ticks
     */
    ticks: {
        // [4,-15] seems to be a good offset for 12 point fonts
        label: { offset: [4, -15], parse: false, needsRegularUpdate: false, display: 'internal', visible: 'inherit', layer: 9, },
        visible: 'inherit',
        needsRegularUpdate: false,
        strokeWidth: 1,
        strokeColor: '#666666',
        highlightStrokeColor: '#888888',
        drawLabels: true,
        drawZero: false,
        insertTicks: true,
        minTicksDistance: 5,
        minorHeight: 10, // if <0: full width and height
        majorHeight: -1, // if <0: full width and height
        tickEndings: [0, 1],
        majorTickEndings: [1, 1],
        minorTicks: 4,
        ticksDistance: 1, // TODO doc
        strokeOpacity: 0.25
    },
    point1: { needsRegularUpdate: false, visible: false, }, // Default values for point1 if created by line
    point2: { needsRegularUpdate: false, visible: false, },
    tabindex: -1,
    label: { position: 'lft', offset: [10, 10], },
    ignoreForLabelAutoposition: true
};
/* special options for angle bisector of 3 points */
Options.bisector = {
    strokeColor: '#000000', // Bisector line
    point: {
        visible: false,
        fixed: false,
        withLabel: false,
        name: '',
    }
};
/* special options for the 2 bisectors of 2 lines */
Options.bisectorlines = {
    line1: { strokeColor: '#000000', },
    line2: { strokeColor: '#000000', },
};
/* special options for boxplot curves */
Options.boxplot = {
    dir: 'vertical',
    smallWidth: 0.5,
    strokeWidth: 2,
    strokeColor: Color.palette.blue,
    fillColor: Color.palette.blue,
    fillOpacity: 0.2,
    highlightStrokeWidth: 2,
    highlightStrokeColor: Color.palette.blue,
    highlightFillColor: Color.palette.blue,
    highlightFillOpacity: 0.1
};
/* special button options */
Options.button = {
    disabled: false,
    display: 'html'
};
/* special cardinal spline options */
Options.cardinalspline = {
    createPoints: true,
    isArrayOfCoordinates: true,
    points: {
        strokeOpacity: 0.05,
        fillOpacity: 0.05,
        highlightStrokeOpacity: 1.0,
        highlightFillOpacity: 1.0,
        withLabel: false,
        name: '',
        fixed: false
    }
};
/* special chart options */
Options.chart = {
    chartStyle: 'line',
    colors: ['#B02B2C', '#3F4C6B', '#C79810', '#D15600', '#FFFF88', '#c3d9ff', '#4096EE', '#008C00'],
    highlightcolors: [],
    fillColor: 'none',
    highlightonsector: false,
    highlightbysize: false,
    fillOpacity: 0.6,
    withLines: false,
    label: {}
};
/* special html slider options */
Options.checkbox = {
    disabled: false,
    checked: false,
    display: 'html'
};
/*special circle options */
Options.circle = {
    hasInnerPoints: false,
    fillColor: 'none',
    highlightFillColor: 'none',
    strokeColor: Color.palette.blue,
    highlightStrokeColor: '#c3d9ff',
    center: {
        visible: false,
        withLabel: false,
        fixed: false,
        fillColor: Color.palette.red,
        strokeColor: Color.palette.red,
        highlightFillColor: '#c3d9ff',
        highlightStrokeColor: '#c3d9ff',
        layer: 9,
        name: '',
    },
    point2: {
        fillColor: Color.palette.red,
        strokeColor: Color.palette.red,
        highlightFillColor: '#c3d9ff',
        highlightStrokeColor: '#c3d9ff',
        layer: 9,
        visible: false,
        withLabel: false,
        fixed: false,
        name: '',
    },
    label: { position: 'urt', }
    /**#@-*/
};
/* special options for circumcircle of 3 points */
Options.circumcircle = {
    fillColor: 'none',
    highlightFillColor: 'none',
    strokeColor: Color.palette.blue,
    highlightStrokeColor: '#c3d9ff',
    center: {
        visible: false,
        fixed: false,
        withLabel: false,
        fillColor: Color.palette.red,
        strokeColor: Color.palette.red,
        highlightFillColor: '#c3d9ff',
        highlightStrokeColor: '#c3d9ff',
        name: ''
    }
    /**#@-*/
};
Options.circumcirclearc = {
    fillColor: 'none',
    highlightFillColor: 'none',
    strokeColor: Color.palette.blue,
    highlightStrokeColor: '#c3d9ff',
    useDirection: true,
    center: {
        visible: false,
        withLabel: false,
        fixed: false,
        name: '',
    }
    /**#@-*/
};
/* special options for circumcircle sector of 3 points */
Options.circumcirclesector = {
    useDirection: true,
    fillColor: Color.palette.yellow,
    highlightFillColor: Color.palette.yellow,
    fillOpacity: 0.3,
    highlightFillOpacity: 0.3,
    strokeColor: Color.palette.blue,
    highlightStrokeColor: '#c3d9ff',
    /**
     * Attributes for center point.
     *
     * @type Point
     * @name Circle#point
     */
    point: {
        visible: false,
        fixed: false,
        withLabel: false,
        name: '',
    }
    /**#@-*/
};
/* special options for comb */
Options.comb = {
    frequency: 0.2,
    width: 0.4,
    angle: 1.04719755, // Math.PI /3   // TS doesn't like Math (namespace) or computations here
    reverse: false,
    point1: { visible: false, withLabel: false, fixed: false, name: '', },
    point2: { visible: false, withLabel: false, fixed: false, name: '', },
    strokeWidth: 1,
    strokeColor: '#0000ff',
    fillColor: 'none'
};
/* special conic options */
Options.conic = {
    fillColor: 'none',
    highlightFillColor: 'none',
    strokeColor: Color.palette.blue,
    highlightStrokeColor: '#c3d9ff',
    foci: { fixed: false, visible: false, withLabel: false, name: '', },
    center: { visible: false, withLabel: false, name: '', },
    point: { withLabel: false, name: '', },
    line: { visible: false, },
};
/* special curve options */
Options.curve = {
    /**#@+
     * @visprop
     */
    strokeWidth: 1,
    strokeColor: Color.palette.blue,
    fillColor: 'none',
    fixed: true,
    curveType: null,
    doAdvancedPlot: true,
    doAdvancedPlotOld: false,
    firstArrow: false,
    handDrawing: false,
    label: { position: 'lft' },
    lastArrow: false,
    lineCap: 'round',
    numberPointsHigh: 1600, // Number of points on curves after mouseUp
    numberPointsLow: 400, // Number of points on curves after mousemove
    plotVersion: 2,
    recursionDepthHigh: 17,
    recursionDepthLow: 15
};
/* special foreignObject options */
Options.foreignobject = {
    fixed: true,
    visible: true,
    needsRegularUpdate: false,
    attractors: [],
    evaluateOnlyOnce: false
};
/* special functiongraph options */
Options.functiongraph = {
/**#@+
 * @visprop
 */
/**#@-*/
};
/* special glider options */
Options.glider = {
    /**#@+
     * @visprop
     */
    label: {}
    /**#@-*/
};
Options.group = {
    needsRegularUpdate: true
};
/* special html slider options */
Options.htmlslider = {
    widthRange: 100,
    widthOut: 34,
    step: 0.01,
    frozen: true,
    isLabel: false,
    strokeColor: '#000000',
    display: 'html',
    anchorX: 'left',
    anchorY: 'middle',
    withLabel: false,
};
/* special image options */
Options.image = {
    imageString: null,
    fillOpacity: 1.0,
    highlightFillOpacity: 0.6,
    cssClass: 'JXGimage',
    highlightCssClass: 'JXGimageHighlight',
    rotate: 0,
    snapSizeX: 1,
    snapSizeY: 1,
    attractors: []
};
/* special implicitcurve options */
Options.implicitcurve = {
    margin: 1,
    resolution_outer: 5,
    resolution_inner: 5,
    max_steps: 1024,
    alpha_0: 0.05,
    tol_u0: 0.000001, // JSXMath.eps,
    tol_newton: 1.0e-7,
    tol_cusp: 0.05,
    tol_progress: 0.0001,
    qdt_box: 0.2,
    kappa_0: 0.2,
    delta_0: 0.05,
    h_initial: 0.1,
    h_critical: 0.001,
    h_max: 0.5,
    loop_dist: 0.09,
    loop_dir: 0.99,
    loop_detection: true
};
/* special options for incircle of 3 points */
Options.incircle = {
    fillColor: 'none',
    highlightFillColor: 'none',
    strokeColor: Color.palette.blue,
    highlightStrokeColor: '#c3d9ff',
    center: {
        visible: false,
        fixed: false,
        withLabel: false,
        fillColor: Color.palette.red,
        strokeColor: Color.palette.red,
        highlightFillColor: '#c3d9ff',
        highlightStrokeColor: '#c3d9ff',
        name: ''
    }
};
Options.inequality = {
    fillColor: Color.palette.red,
    fillOpacity: 0.2,
    strokeColor: 'none',
    inverse: false
};
Options.infobox = {
    distanceX: -20,
    distanceY: 25,
    intl: { enabled: 'inherit', options: {}, },
    fontSize: 12,
    isLabel: false,
    strokeColor: '#bbbbbb',
    display: 'html', // 'html' or 'internal'
    anchorX: 'left', //  'left', 'middle', or 'right': horizontal alignment
    //  of the text.
    anchorY: 'middle', //  'top', 'middle', or 'bottom': vertical alignment
    //  of the text.
    cssClass: 'JXGinfobox',
    rotate: 0, // works for non-zero values only in combination
    // with display=='internal'
    visible: true,
    parse: false,
    transitionDuration: 0,
    needsRegularUpdate: false,
    tabindex: null,
    viewport: [0, 0, 0, 0],
    ignoreForLabelAutoposition: true
    /**#@-*/
};
/* special options for integral */
Options.integral = {
    axis: 'x', // 'x' or 'y'
    withLabel: true, // Show integral value as text
    fixed: true,
    strokeWidth: 0,
    strokeOpacity: 0,
    fillColor: Color.palette.red,
    fillOpacity: 0.3,
    highlightFillColor: Color.palette.red,
    highlightFillOpacity: 0.2,
    curveLeft: {
        visible: true,
        withLabel: false,
        color: Color.palette.red,
        fillOpacity: 0.8,
        layer: 9,
    },
    baseLeft: {
        visible: false,
        fixed: false,
        withLabel: false,
        name: '',
    },
    curveRight: {
        visible: true,
        withLabel: false,
        color: Color.palette.red,
        fillOpacity: 0.8,
        layer: 9,
    },
    baseRight: {
        visible: false,
        fixed: false,
        withLabel: false,
        name: '',
    },
    label: {
        fontSize: 20,
        digits: 4,
        intl: {
            enabled: false,
            options: {},
        },
    },
};
/* special input options */
Options.input = {
    disabled: false,
    maxlength: 524288,
    display: 'html',
};
/* special intersection point options */
Options.intersection = {
    alwaysIntersect: true
};
/* special line options */
Options.line = {
    firstArrow: false,
    lastArrow: false,
    margin: 0,
    straightFirst: true,
    straightLast: true,
    fillColor: 'none', // Important for VML on IE
    highlightFillColor: 'none', // Important for VML on IE
    strokeColor: Color.palette.blue,
    highlightStrokeColor: '#c3d9ff',
    withTicks: false,
    point1: {
        fillColor: Color.palette.red,
        strokeColor: Color.palette.red,
        highlightFillColor: '#c3d9ff',
        highlightStrokeColor: '#c3d9ff',
        layer: 9,
        visible: false,
        withLabel: false,
        fixed: false,
        name: '',
    },
    point2: {
        fillColor: Color.palette.red,
        strokeColor: Color.palette.red,
        highlightFillColor: '#c3d9ff',
        highlightStrokeColor: '#c3d9ff',
        layer: 9,
        visible: false,
        withLabel: false,
        fixed: false,
        name: '',
    },
    ticks: {
        drawLabels: true,
        label: {
            offset: [4, -15] // This seems to be a good offset for 12 point fonts
        },
        drawZero: false,
        insertTicks: false,
        ticksDistance: 1,
        minTicksDistance: 50,
        minorHeight: 4, // if <0: full width and height
        majorHeight: -1, // if <0: full width and height
        minorTicks: 4,
        strokeOpacity: 0.3,
        visible: 'inherit'
    },
    label: {
        position: 'llft',
    },
    snapToGrid: false,
    snapSizeX: 1,
    snapSizeY: 1,
    touchFirstPoint: false,
    touchLastPoint: false,
};
/* special options for locus curves */
Options.locus = {
    translateToOrigin: false,
    translateTo10: false,
    stretch: false,
    toOrigin: null,
    to10: null,
};
/* special measurement options */
Options.measurement = {
    baseUnit: '',
    units: {},
    showPrefix: true,
    showSuffix: true,
    prefix: '',
    suffix: '',
    dim: null,
    formatCoords: (self, x, y, z) => (parseFloat(z) !== 1) ? 'Infinit coords' : '(' + x + ', ' + y + ')',
    formatDirection: (self, x, y) => '(' + x + ', ' + y + ')'
};
/* special metapost spline options */
Options.metapostspline = {
    createPoints: true,
    isArrayOfCoordinates: true,
    points: {
        strokeOpacity: 0.5,
        fillOpacity: 0.5,
        highlightStrokeOpacity: 1.0,
        highlightFillOpacity: 1.0,
        withLabel: false,
        name: '',
        fixed: false,
    }
};
/* special mirrorelement options */
Options.mirrorelement = {
    fixed: true,
    point: {},
    center: {},
    type: 'Euclidean'
};
/* special nonreflexangle options */
Options.nonreflexangle = {};
// /* special options for Msector of 3 points */
// msector: {
//     strokeColor: '#000000', // Msector line
//     point: {               // Msector point
//         visible: false
//         fixed: false
//         withLabel: false
//         name: ''
//     }
// }
/* special options for normal lines */
Options.normal = {
    strokeColor: '#000000', //  normal line
    point: {
        visible: false,
        fixed: false,
        withLabel: false,
        name: '',
    }
};
/* special options for orthogonal projection points */
Options.orthogonalprojection = {};
/* special otherintersection point options */
Options.otherintersection = {
    alwaysIntersect: true,
    precision: 0.001
};
/* special options for parallel lines */
Options.parallel = {
    strokeColor: '#000000', // Parallel line
    point: {
        visible: false,
        fixed: false,
        withLabel: false,
        name: '',
    },
    label: { position: 'llft', },
};
/* special parallelogram options */
Options.parallelogram = {
    parallelpoint: {
        withLabel: false,
        name: '',
    },
};
/* special parallelpoint options */
Options.parallelpoint = {};
/* special perpendicular options */
Options.perpendicular = {
    strokeColor: '#000000', // Perpendicular line
    straightFirst: true,
    straightLast: true,
};
/* special perpendicular options */
Options.perpendicularsegment = {
    strokeColor: '#000000', // Perpendicular segment
    straightFirst: false,
    straightLast: false,
    point: {
        visible: false,
        fixed: true,
        withLabel: false,
        name: '',
    }
};
/* special polygon options */
Options.polygon = {
    hasInnerPoints: false,
    fillColor: Color.palette.yellow,
    highlightFillColor: Color.palette.yellow,
    fillOpacity: 0.3,
    highlightFillOpacity: 0.2,
    withLines: true,
    borders: {
        withLabel: false,
        strokeWidth: 1,
        highlightstrokeWidth: 1,
        // Polygon layer + 1
        layer: 5,
        label: { position: 'top', },
        visible: 'inherit',
    },
    highlightbyStrokeWidth: false,
    vertices: {
        layer: 9,
        withLabel: false,
        name: '',
        strokeColor: Color.palette.red,
        fillColor: Color.palette.red,
        fixed: false,
        visible: 'inherit',
    },
    label: {
        offset: [0, 0]
    }
};
/* special polygonal chain options
*/
Options.polygonalchain = {
    fillColor: 'none',
    highlightFillColor: 'none',
};
/* special prescribed angle options
* Not yet implemented. But angle.setAngle(val) is implemented.

*/
Options.prescribedangle = {
    anglePoint: {
        size: 2,
        visible: false,
        withLabel: false,
    }
};
/* special reflection options */
Options.reflection = {
    fixed: true,
    center: {},
    type: 'Euclidean'
};
/* special reflexangle options */
Options.reflexangle = {
/**#@+
 * @visprop
 */
/**#@-*/
};
/* special regular polygon options */
Options.regularpolygon = {
    hasInnerPoints: false,
    fillColor: Color.palette.yellow,
    highlightFillColor: Color.palette.yellow,
    fillOpacity: 0.3,
    highlightFillOpacity: 0.2,
    withLines: true,
    borders: {
        withLabel: false,
        strokeWidth: 1,
        highlightStrokeWidth: 1,
        // Polygon layer + 1
        layer: 5,
        label: {
            position: 'top',
        }
    },
    vertices: {
        layer: 9,
        withLabel: true,
        strokeColor: Color.palette.red,
        fillColor: Color.palette.red,
        fixed: false,
    },
    label: {
        offset: [0, 0]
    }
};
/* special options for riemann sums */
Options.riemannsum = {
    /**#@+
     * @visprop
     */
    withLabel: false,
    fillOpacity: 0.3,
    fillColor: Color.palette.yellow
    /**#@-*/
};
/* special sector options */
Options.sector = {
    fillColor: Color.palette.yellow,
    highlightFillColor: Color.palette.yellow,
    fillOpacity: 0.3,
    highlightFillOpacity: 0.3,
    highlightOnSector: false,
    highlightstrokeWidth: 0,
    useDirection: false,
    selection: 'auto',
    arc: {
        visible: false,
        fillColor: 'none',
        withLabel: false,
        name: '',
        center: { visible: false, withLabel: false, name: '', },
        radiusPoint: { visible: false, withLabel: false, name: '', },
        anglePoint: { visible: false, withLabel: false, name: '', },
    },
    radiusPoint: { visible: false, withLabel: false, },
    center: { visible: false, withLabel: false, },
    anglePoint: { visible: false, withLabel: false, },
    label: {
        offset: [0, 0],
        anchorX: 'auto',
        anchorY: 'auto',
    }
};
/* special segment options */
Options.segment = {
    /**#@+
     * @visprop
     */
    label: {
        position: 'top'
    }
    /**#@-*/
};
Options.semicircle = {
    center: {
        visible: false,
        withLabel: false,
        fixed: false,
        fillColor: Color.palette.red,
        strokeColor: Color.palette.red,
        highlightFillColor: '#eeeeee',
        highlightStrokeColor: Color.palette.red,
        name: '',
    }
};
/* special slider options */
Options.slider = {
    snapWidth: -1, // -1 = deactivated
    snapValues: [],
    snapValueDistance: 0.0,
    precision: 2,
    digits: 2,
    intl: {
        enabled: 'inherit',
        options: {},
    },
    firstArrow: false,
    lastArrow: false,
    withTicks: true,
    withLabel: true,
    suffixLabel: null,
    unitLabel: null,
    postLabel: null,
    layer: 9,
    showInfobox: false,
    name: '',
    visible: true,
    strokeColor: '#000000',
    highlightStrokeColor: '#888888',
    fillColor: '#ffffff',
    highlightFillColor: 'none',
    size: 6,
    point1: { needsRegularUpdate: false, showInfobox: false, withLabel: false, visible: false, fixed: true, frozen: 'inherit', name: '', },
    point2: { needsRegularUpdate: false, showInfobox: false, withLabel: false, visible: false, fixed: true, frozen: 'inherit', name: '', },
    baseline: {
        needsRegularUpdate: false,
        visible: 'inherit',
        fixed: true,
        scalable: false,
        tabindex: null,
        name: '',
        strokeWidth: 1,
        strokeColor: '#000000',
        highlightStrokeColor: '#888888',
    },
    /**
     * Attributes for the ticks of the base line of the slider.
     *
     * @type Ticks
     * @name Slider#ticks
     */
    ticks: {
        needsRegularUpdate: false,
        fixed: true,
        // Label drawing
        drawLabels: false,
        digits: 2,
        includeBoundaries: true,
        drawZero: true,
        label: {
            offset: [-4, -14],
            display: 'internal',
        },
        minTicksDistance: 30,
        insertTicks: true,
        ticksDistance: 1, // Not necessary, since insertTicks = true
        minorHeight: 4, // if <0: full width and height
        majorHeight: 5, // if <0: full width and height
        minorTicks: 0,
        strokeOpacity: 1,
        strokeWidth: 1,
        tickEndings: [0, 1],
        majortickEndings: [0, 1],
        strokeColor: '#000000',
        visible: 'inherit',
    },
    highline: {
        strokeWidth: 3,
        visible: 'inherit',
        fixed: true,
        tabindex: null,
        name: '',
        strokeColor: '#000000',
        highlightStrokeColor: '#888888',
    },
    label: {
        visible: 'inherit',
        strokeColor: '#000000',
    },
    moveOnUp: true,
};
/* special vector field options */
Options.slopefield = {
    strokeWidth: 0.5,
    highlightStrokeWidth: 0.5,
    highlightStrokeColor: Color.palette.blue,
    highlightStrokeOpacity: 0.8,
    /**
     * Set length of the vectors in user coordinates. This in contrast to vector fields, where this attribute just scales the vector.
     * @name scale
     * @memberOf Slopefield.prototype
     * @type {Number|Function}
     * @see Vectorfield.scale
     * @default 1
     */
    scale: 1,
    arrowhead: {
        enabled: false,
        size: 5,
        angle: Math.PI * 0.125,
    }
};
/* special options for slope triangle */
Options.slopetriangle = {
    fillColor: Color.palette.red,
    fillOpacity: 0.4,
    highlightFillColor: Color.palette.red,
    highlightFillOpacity: 0.3,
    borders: {
        lastArrow: {
            type: 1,
            size: 6,
        },
    },
    glider: { fixed: true, visible: false, withLabel: false, },
    baseline: { visible: false, withLabel: false, name: '', },
    basepoint: { visible: false, withLabel: false, name: '', },
    tangent: { visible: false, withLabel: false, name: '', },
    toppoint: { visible: false, withLabel: false, name: '', },
    label: {
        visible: true,
        position: 'first',
    }
};
/* special options for smartlabel of angle */
Options.smartlabelangle = {
    cssClass: 'smart-label-solid smart-label-angle',
    highlightCssClass: 'smart-label-solid smart-label-angle',
    anchorX: 'left',
    anchorY: 'middle',
    unit: '',
    prefix: '',
    suffix: '',
    measure: 'deg',
    useMathJax: true,
};
/* special options for smartlabel of circle */
Options.smartlabelcircle = {
    cssClass: 'smart-label-solid smart-label-circle',
    highlightCssClass: 'smart-label-solid smart-label-circle',
    anchorX: 'middle',
    useMathJax: true,
    unit: '',
    prefix: '',
    suffix: '',
    measure: 'radius'
};
/* special options for smartlabel of line */
Options.smartlabelline = {
    cssClass: 'smart-label-solid smart-label-line',
    highlightCssClass: 'smart-label-solid smart-label-line',
    anchorX: 'middle',
    useMathJax: true,
    unit: '',
    measure: 'length',
};
/* special options for smartlabel of point */
Options.smartlabelpoint = {
    cssClass: 'smart-label-solid smart-label-point',
    highlightCssClass: 'smart-label-solid smart-label-point',
    anchorX: 'middle',
    anchorY: 'top',
    useMathJax: true,
    dir: 'row',
    unit: ''
    /**#@-*/
};
/* special options for smartlabel of polygon */
Options.smartlabelpolygon = {
    cssClass: 'smart-label-solid smart-label-polygon',
    highlightCssClass: 'smart-label-solid smart-label-polygon',
    anchorX: 'middle',
    useMathJax: true,
    unit: '',
    measure: 'area',
};
/* special options for step functions */
Options.stepfunction = {
/**#@+
 * @visprop
 */
/**#@-*/
};
/* special tangent options */
Options.tangent = {};
/* special tangent options */
Options.tangentto = {
    polar: {
        visible: false,
        strokeWidth: 1,
        dash: 3,
    },
    point: {
        visible: false,
    },
};
/* special tape measure options */
Options.tapemeasure = {
    strokeColor: '#000000',
    strokeWidth: 2,
    highlightStrokeColor: '#000000',
    withTicks: true,
    withLabel: true,
    rotate: 0,
    precision: 2,
    digits: 2,
    /**
     * Attributes for first helper point defining the tape measure position.
     *
     * @type Point
     * @name Tapemeasure#point1
     */
    point1: {
        visible: true,
        strokeColor: '#000000',
        fillColor: '#ffffff',
        fillOpacity: 0.0,
        highlightFillOpacity: 0.1,
        size: 6,
        snapToPoints: true,
        attractorUnit: 'screen',
        attractorDistance: 20,
        showInfobox: false,
        withLabel: false,
        name: '',
    },
    point2: {
        visible: true,
        strokeColor: '#000000',
        fillColor: '#ffffff',
        fillOpacity: 0.0,
        highlightFillOpacity: 0.1,
        size: 6,
        snapToPoints: true,
        attractorUnit: 'screen',
        attractorDistance: 20,
        showInfobox: false,
        withLabel: false,
        name: '',
    },
    ticks: {
        drawLabels: false,
        drawZero: true,
        insertTicks: true,
        ticksDistance: 0.1, // Ignored since insertTicks=true
        minorHeight: 8,
        majorHeight: 16,
        minorTicks: 4,
        tickEndings: [0, 1],
        majorTickEndings: [0, 1],
        strokeOpacity: 1,
        strokeWidth: 1,
        strokeColor: '#000000',
        visible: 'inherit',
        label: {
            anchorY: 'top',
            anchorX: 'middle',
            offset: [0, -10],
        },
    },
    label: {
        position: 'top',
    }
};
/* special options for trace curves */
Options.tracecurve = {
    strokeColor: '#000000',
    fillColor: 'none',
    numberPoints: 100,
};
/* special turtle options */
Options.turtle = {
    strokeWidth: 1,
    fillColor: 'none',
    strokeColor: '#000000',
    arrow: {
        strokeWidth: 2,
        withLabel: false,
        strokeColor: Color.palette.red,
        lastArrow: true,
    }
};
/* special vector field options */
Options.vectorfield = {
    strokeWidth: 0.5,
    highlightStrokeWidth: 0.5,
    highlightStrokeColor: Color.palette.blue,
    highlightStrokeOpacity: 0.8,
    scale: 1,
    arrowhead: {
        enabled: true,
        size: 5,
        angle: Math.PI * 0.125
    }
};
/**
 * Abbreviations of attributes. Setting the shortcut means setting abbreviated properties
 * to the same value.
 * It is used in {@link JXG.GeometryElement#setAttribute} and in
 * the constructor {@link JXG.GeometryElement}.
 * Attention: In Options.js abbreviations are not allowed.
 * @type Object
 * @name JXG.Options#shortcuts
 *
 */
Options.shortcuts = {
    color: ['strokeColor', 'fillColor'],
    opacity: ['strokeOpacity', 'fillOpacity'],
    highlightColor: ['highlightStrokeColor', 'highlightFillColor'],
    highlightOpacity: ['highlightStrokeOpacity', 'highlightFillOpacity'],
    strokeWidth: ['strokeWidth', 'highlightStrokeWidth'],
};

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */
/*global JXG: true, define: true*/
/*jslint nomen: true, plusplus: true*/
// import { JXG } from "../jxg.js";
/**
 * Functions for mathematical statistics. Most functions are like in the statistics package R.
 * @name JXG.Math.Statistics
 * @exports Mat.Statistics as JXG.Math.Statistics
 * @namespace
 */
class Statistics {
    /**
     * Sums up all elements of the given array.
     * @param {Array} arr An array of numbers.
     * @returns {Number}
     * @memberof JXG.Math.Statistics
     */
    static sum(arr) {
        var i, len = arr.length, res = 0;
        for (i = 0; i < len; i++) {
            res += arr[i];
        }
        return res;
    }
    /**
     * Multiplies all elements of the given array.
     * @param {Array} arr An array of numbers.
     * @returns {Number}
     * @memberof JXG.Math.Statistics
     */
    static prod(arr) {
        var i, len = arr.length, res = 1;
        for (i = 0; i < len; i++) {
            res *= arr[i];
        }
        return res;
    }
    /**
     * Determines the mean value of the values given in an array.
     * @param {Array} arr
     * @returns {Number}
     * @memberof JXG.Math.Statistics
     */
    static mean(arr) {
        if (arr.length > 0) {
            return this.sum(arr) / arr.length;
        }
        return 0.0;
    }
    /**
     * The median of a finite set of values is the value that divides the set
     * into two equal sized subsets.
     * @param {Array} arr The set of values.
     * @returns {Number}
     * @memberof JXG.Math.Statistics
     */
    static median(arr) {
        var tmp, len;
        if (arr.length > 0) {
            if (ArrayBuffer.isView(arr)) {
                tmp = new Float64Array(arr);
                tmp.sort();
            }
            else {
                tmp = arr.slice(0);
                tmp.sort(function (a, b) {
                    return a - b;
                });
            }
            len = tmp.length;
            if (len & 1) {
                // odd
                return tmp[len * 0.5];
            }
            return (tmp[len * 0.5 - 1] + tmp[len * 0.5]) * 0.5;
        }
        return 0.0;
    }
    /**
     * The P-th percentile ( <i>0 < P  100</i> ) of a list of <i>N</i> ordered values (sorted from least to greatest)
     * is the smallest value in the list such that no more than <i>P</i> percent of the data is strictly less
     * than the value and at least <i>P</i> percent of the data is less than or equal to that value.
     * See <a href="https://en.wikipedia.org/wiki/Percentile">https://en.wikipedia.org/wiki/Percentile</a>.
     *
     * Here, the <i>linear interpolation between closest ranks</i> method is used.
     * @param {Array} arr The set of values, need not be ordered.
     * @param {Number|Array} percentile One or several percentiles
     * @returns {Number|Array} Depending if a number or an array is the input for percentile, a number or an array containing the percentiles
     * is returned.
     */
    static percentile(arr, percentile) {
        var tmp, //Float64Array,
        len, i, p, res = [], per;
        if (arr.length > 0) {
            // if (ArrayBuffer.isView(arr)) {
            //     tmp = new Float64Array(arr);
            //     tmp.sort();
            // } else {
            tmp = arr.slice(0);
            tmp.sort(function (a, b) {
                return a - b;
            });
            // }
            len = tmp.length;
            if (Array.isArray(percentile)) {
                p = percentile;
            }
            else {
                p = [percentile];
            }
            for (i = 0; i < p.length; i++) {
                per = len * p[i] * 0.01;
                if (parseInt(per, 10) === per) {
                    res.push((tmp[per - 1] + tmp[per]) * 0.5);
                }
                else {
                    res.push(tmp[parseInt(per, 10)]);
                }
            }
            if (Array.isArray(percentile)) {
                return res;
            }
            else {
                throw new Error('simple number?');
                // return res[0];
            }
        }
        throw new Error('percentileof empty array');
        // return 0.0;
    }
    /**
     * Bias-corrected sample variance. A variance is a measure of how far a
     * set of numbers are spread out from each other.
     * @param {Array} arr
     * @returns {Number}
     * @memberof JXG.Math.Statistics
     */
    static variance(arr) {
        var m, res, i, len = arr.length;
        if (len > 1) {
            m = this.mean(arr);
            res = 0;
            for (i = 0; i < len; i++) {
                res += (arr[i] - m) * (arr[i] - m);
            }
            return res / (arr.length - 1);
        }
        return 0.0;
    }
    /**
     * Determines the <strong>s</strong>tandard <strong>d</strong>eviation which shows how much
     * variation there is from the average value of a set of numbers.
     * @param {Array} arr
     * @returns {Number}
     * @memberof JXG.Math.Statistics
     */
    static sd(arr) {
        return Math.sqrt(this.variance(arr));
    }
    /**
     * Weighted mean value is basically the same as {@link JXG.Math.Statistics.mean} but here the values
     * are weighted, i.e. multiplied with another value called <em>weight</em>. The weight values are given
     * as a second array with the same length as the value array..
     * @throws {Error} If the dimensions of the arrays don't match.
     * @param {Array} arr Set of alues.
     * @param {Array} w Weight values.
     * @returns {Number}
     * @memberof JXG.Math.Statistics
     */
    static weightedMean(arr, w) {
        if (arr.length !== w.length) {
            throw new Error("JSXGraph error (Math.Statistics.weightedMean): Array dimension mismatch.");
        }
        if (arr.length > 0) {
            return this.mean(this.multiply(arr, w));
        }
        return 0.0;
    }
    /**
     * Extracts the maximum value from the array.
     * @param {Array} arr
     * @returns {Number} The highest number from the array. It returns <tt>NaN</tt> if not every element could be
     * interpreted as a number and <tt>-Infinity</tt> if an empty array is given or no element could be interpreted
     * as a number.
     * @memberof JXG.Math.Statistics
     */
    static max(arr) {
        return Math.max.apply(this, arr);
    }
    /**
     * Extracts the minimum value from the array.
     * @param {Array} arr
     * @returns {Number} The lowest number from the array. It returns <tt>NaN</tt> if not every element could be
     * interpreted as a number and <tt>Infinity</tt> if an empty array is given or no element could be interpreted
     * as a number.
     * @memberof JXG.Math.Statistics
     */
    static min(arr) {
        return Math.min.apply(this, arr);
    }
    /**
     * Determines the lowest and the highest value from the given array.
     * @param {Array} arr
     * @returns {Array} The minimum value as the first and the maximum value as the second value.
     * @memberof JXG.Math.Statistics
     */
    static range(arr) {
        return [this.min(arr), this.max(arr)];
    }
    /**
     * Determines the absolute value of every given value.
     * @param {Array|Number} arr
     * @returns {Array|Number}
     * @memberof JXG.Math.Statistics
     */
    static abs(arr) {
        let res;
        if (Array.isArray(arr)) {
            res = arr.map((x) => Math.abs(x));
            // } else if (ArrayBuffer.isView(arr)) {
            //     res = arr.map(Math.abs);
        }
        else {
            throw new Error('abs of simple number ?');
            // res = Math.abs(arr);
        }
        return res;
    }
    /**
     * Adds up two (sequences of) values. If one value is an array and the other one is a number the number
     * is added to every element of the array. If two arrays are given and the lengths don't match the shortest
     * length is taken.
     * @param {Array|Number} arr1
     * @param {Array|Number} arr2
     * @returns {Array|Number}
     * @memberof JXG.Math.Statistics
     */
    static add(arr1, arr2) {
        var i, len, res = [];
        arr1 = Type.evalSlider(arr1);
        arr2 = Type.evalSlider(arr2);
        if (Array.isArray(arr1) && typeof arr2 === 'number') {
            len = arr1.length;
            for (i = 0; i < len; i++) {
                res[i] = arr1[i] + arr2;
            }
        }
        else if (typeof arr1 === 'number' && Array.isArray(arr2)) {
            len = arr2.length;
            for (i = 0; i < len; i++) {
                res[i] = arr1 + arr2[i];
            }
        }
        else if (Array.isArray(arr1) && Array.isArray(arr2)) {
            len = Math.min(arr1.length, arr2.length);
            for (i = 0; i < len; i++) {
                res[i] = arr1[i] + arr2[i];
            }
        }
        else {
            throw new Error('add of two simple numbers ?');
            // res = arr1 + arr2;
        }
        return res;
    }
    /**
     * Divides two (sequences of) values. If two arrays are given and the lengths don't match the shortest length
     * is taken.
     * @param {Array|Number} arr1 Dividend
     * @param {Array|Number} arr2 Divisor
     * @returns {Array|Number}
     * @memberof JXG.Math.Statistics
     */
    static div(arr1, arr2) {
        var i, len, res = [];
        arr1 = Type.evalSlider(arr1);
        arr2 = Type.evalSlider(arr2);
        if (Array.isArray(arr1) && typeof arr2 === 'number') {
            len = arr1.length;
            for (i = 0; i < len; i++) {
                res[i] = arr1[i] / arr2;
            }
        }
        else if (typeof arr1 === 'number' && Array.isArray(arr2)) {
            len = arr2.length;
            for (i = 0; i < len; i++) {
                res[i] = arr1 / arr2[i];
            }
        }
        else if (Array.isArray(arr1) && Array.isArray(arr2)) {
            len = Math.min(arr1.length, arr2.length);
            for (i = 0; i < len; i++) {
                res[i] = arr1[i] / arr2[i];
            }
        }
        else {
            throw new Error('div of two simple numbers ?');
            // res = arr1 / arr2;
        }
        return res;
    }
    /**
     * @function
     * @deprecated Use {@link JXG.Math.Statistics.div} instead.
     * @memberof JXG.Math.Statistics
     */
    static divide() {
        throw new Error('deprecated, use Statistics.div instead');
    }
    /**
     * Divides two (sequences of) values and returns the remainder. If two arrays are given and the lengths don't
     * match the shortest length is taken.
     * @param {Array|Number} arr1 Dividend
     * @param {Array|Number} arr2 Divisor
     * @param {Boolean} [math=false] Mathematical mod or symmetric mod? Default is symmetric, the JavaScript <tt>%</tt> operator.
     * @returns {Array|Number}
     * @memberof JXG.Math.Statistics
     */
    static mod(arr1, arr2, math = false) {
        var i, len, res = [], mod = function (a, m) {
            return a % m;
        };
        if (math) {
            mod = JSXMath.mod; // the results differ if a or m < 0.
        }
        arr1 = Type.evalSlider(arr1);
        arr2 = Type.evalSlider(arr2);
        if (Array.isArray(arr1) && typeof arr2 === 'number') {
            len = arr1.length;
            for (i = 0; i < len; i++) {
                res[i] = mod(arr1[i], arr2);
            }
        }
        else if (typeof arr1 === 'number' && Array.isArray(arr2)) {
            len = arr2.length;
            for (i = 0; i < len; i++) {
                res[i] = mod(arr1, arr2[i]);
            }
        }
        else if (Array.isArray(arr1) && Array.isArray(arr2)) {
            len = Math.min(arr1.length, arr2.length);
            for (i = 0; i < len; i++) {
                res[i] = mod(arr1[i], arr2[i]);
            }
        }
        else {
            throw new Error('Mod of a simple number?');
            // res = mod(arr1, arr2);
        }
        return res;
    }
    /**
     * Multiplies two (sequences of) values. If one value is an array and the other one is a number the number
     * is multiplied to every element of the array. If two arrays are given and the lengths don't match the shortest
     * length is taken.
     * @param {Array|Number} arr1
     * @param {Array|Number} arr2
     * @returns {Array|Number}
     * @memberof JXG.Math.Statistics
     */
    static multiply(arr1, arr2) {
        var i, len, res = [];
        arr1 = Type.evalSlider(arr1);
        arr2 = Type.evalSlider(arr2);
        if (Array.isArray(arr1) && typeof arr2 == 'number') {
            len = arr1.length;
            for (i = 0; i < len; i++) {
                res[i] = arr1[i] * arr2;
            }
        }
        else if (typeof arr1 == 'number' && Array.isArray(arr2)) {
            len = arr2.length;
            for (i = 0; i < len; i++) {
                res[i] = arr1 * arr2[i];
            }
        }
        else if (Array.isArray(arr1) && Array.isArray(arr2)) {
            len = Math.min(arr1.length, arr2.length);
            for (i = 0; i < len; i++) {
                res[i] = arr1[i] * arr2[i];
            }
        }
        else {
            throw new Error('multipling to simple numbers ?');
            // res = arr1 * arr2;
        }
        return res;
    }
    /**
     * Subtracts two (sequences of) values. If two arrays are given and the lengths don't match the shortest
     * length is taken.
     * @param {Array} arr1 Minuend
     * @param {Array} arr2 Subtrahend
     * @returns {Array|Number}
     * @memberof JXG.Math.Statistics
     */
    static subtract(arr1, arr2) {
        var i, len, res = [];
        /////////////// the original allowed arr1 or arr2 to be numbers OR arrays.
        // arr1 = Type.evalSlider(arr1);
        // arr2 = Type.evalSlider(arr2);
        // if (Array.isArray(arr1) && typeof arr2 === 'number') {
        //     len = arr1.length;
        //     for (i = 0; i < len; i++) {
        //         res[i] = arr1[i] - arr2;
        //     }
        // } else if (typeof arr1 === 'number' && Array.isArray(arr2)) {
        //     len = arr2.length;
        //     for (i = 0; i < len; i++) {
        //         res[i] = arr1 - arr2[i];
        //     }
        // } else if (Array.isArray(arr1) && Array.isArray(arr2)) {
        len = Math.min(arr1.length, arr2.length);
        for (i = 0; i < len; i++) {
            res[i] = arr1[i] - arr2[i];
        }
        return res;
    }
    /**
     * The Theil-Sen estimator can be used to determine a more robust linear regression of a set of sample
     * points than least squares regression in {@link JXG.Math.Numerics.regressionPolynomial}.
     *
     * If the function should be applied to an array a of points, a the coords array can be generated with
     * JavaScript array.map:
     *
     * <pre>
     * JXG.Math.Statistics.TheilSenRegression(a.map(el => el.coords));
     * </pre>
     *
     * @param {Array} coords Array of {@link JXG.Coords}.
     * @returns {Array} A stdform array of the regression line.
     * @memberof JXG.Math.Statistics
     *
     * @example
     * var board = JXG.JSXGraph.initBoard('jxgbox', { boundingbox: [-6,6,6,-6], axis : true });
     * var a=[];
     * a[0]=board.create('point', [0,0]);
     * a[1]=board.create('point', [3,0]);
     * a[2]=board.create('point', [0,3]);
     *
     * board.create('line', [
     *     () => JXG.Math.Statistics.TheilSenRegression(a.map(el => el.coords))
     *   ],
     *   {strokeWidth:1, strokeColor:'black'});
     *
     * </pre><div id="JXG0a28be85-91c5-44d3-aae6-114e81217cf0" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG0a28be85-91c5-44d3-aae6-114e81217cf0',
     *             {boundingbox: [-6,6,6,-6], axis: true, showcopyright: false, shownavigation: false});
     *     var a=[];
     *     a[0]=board.create('point', [0,0]);
     *     a[1]=board.create('point', [3,0]);
     *     a[2]=board.create('point', [0,3]);
     *
     *     board.create('line', [
     *         () => JXG.Math.Statistics.TheilSenRegression(a.map(el => el.coords))
     *       ],
     *       {strokeWidth:1, strokeColor:'black'});
     *
     *     })();
     *
     * </script><pre>
     *
     */
    static TheilSenRegression(coords) {
        var i, j, slopes = [], tmpslopes = [], yintercepts = [];
        for (i = 0; i < coords.length; i++) {
            tmpslopes.length = 0;
            for (j = 0; j < coords.length; j++) {
                if (Math.abs(coords[j].usrCoords[1] - coords[i].usrCoords[1]) > JSXMath.eps) {
                    tmpslopes[j] =
                        (coords[j].usrCoords[2] - coords[i].usrCoords[2]) /
                            (coords[j].usrCoords[1] - coords[i].usrCoords[1]);
                }
            }
            slopes[i] = this.median(tmpslopes);
            yintercepts.push(coords[i].usrCoords[2] - slopes[i] * coords[i].usrCoords[1]);
        }
        return [this.median(yintercepts), this.median(slopes), -1];
    }
    static generateGaussian(mean, stdDev) {
        var u, v, s;
        if (Statistics.hasSpare) {
            Statistics.hasSpare = false;
            return Statistics.spare * stdDev + mean;
        }
        do {
            u = Math.random() * 2 - 1;
            v = Math.random() * 2 - 1;
            s = u * u + v * v;
        } while (s >= 1 || s === 0);
        s = Math.sqrt((-2 * Math.log(s)) / s);
        Statistics.spare = v * s;
        Statistics.hasSpare = true;
        return mean + stdDev * u * s;
    }
    /**
     * Generate value of a standard normal random variable with given mean and standard deviation.
     * Alias for {@link JXG.Math.Statistics#generateGaussian}
     *
     * @param {Number} mean
     * @param {Number} stdDev
     * @returns Number
     * @memberof JXG.Math.Statistics
     * @see JXG.Math.Statistics.generateGaussian
     * @example
     *  let board = JXG.JSXGraph.initBoard('JXGbox',
     *       { boundingbox: [-5, 1.5, 5, -.03], axis: true});
     *
     *   let runs = [
     *       [0, 0.2, 'blue'],
     *       [0, 1.0, 'red'],
     *       [0, 5.0, 'orange'],
     *       [-2,0.5, 'green'],
     *   ]
     *
     *   let labelY = 1.2
     *   runs.forEach((run,i) => {
     *       board.create('segment',[[1.0,labelY-(i/20)],[2.0,labelY-(i/20)]],{strokeColor:run[2]})
     *       board.create('text',[2.5,labelY-(i/20),`&mu;=${run[0]}, &#963;<sup>2</sup>=${run[1]}`])
     *
     *       let x = Array(50000).fill(0).map(() => JXG.Math.Statistics.randomNormal(run[0],Math.sqrt(run[1])))  // sqrt so Std Dev, not Variance
     *       let res = JXG.Math.Statistics.histogram(x, { bins: 40, density: true, cumulative: false, range: false });
     *       board.create('curve', [res[1], res[0]], { strokeColor: run[2], strokeWidth:2});
     *   })
     *
     * </pre><div id="JXGda56df4d-a5a5-4c87-9ffc-9bbc1b512302-4" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     * {
     *  let board = JXG.JSXGraph.initBoard('JXGda56df4d-a5a5-4c87-9ffc-9bbc1b512302-4',
     *       { boundingbox: [-5, 1.5, 5, -.03], axis: true});
     *
     *   let runs = [
     *       [0, 0.2, 'blue'],
     *       [0, 1.0, 'red'],
     *       [0, 5.0, 'orange'],
     *       [-2,0.5, 'green'],
     *   ]
     *
     *   let labelY = 1.2
     *   runs.forEach((run,i) => {
     *       board.create('segment',[[1.0,labelY-(i/20)],[2.0,labelY-(i/20)]],{strokeColor:run[2]})
     *       board.create('text',[2.5,labelY-(i/20),`&mu;=${run[0]}, &#963;<sup>2</sup>=${run[1]}`])
     *
     *       let x = Array(50000).fill(0).map(() => JXG.Math.Statistics.randomNormal(run[0],Math.sqrt(run[1])))  // sqrt so Std Dev, not Variance
     *       let res = JXG.Math.Statistics.histogram(x, { bins: 40, density: true, cumulative: false, range: false });
     *       board.create('curve', [res[1], res[0]], { strokeColor: run[2], strokeWidth:2});
     *   })
     * }
     * </script><pre>

     */
    static randomNormal(mean, stdDev) {
        return this.generateGaussian(mean, stdDev);
    }
    /**
     * Generate value of a uniform distributed random variable in the interval [a, b].
     * @param {Number} a
     * @param {Number} b
     * @returns Number
     * @memberof JXG.Math.Statistics
     */
    static randomUniform(a, b) {
        return Math.random() * (b - a) + a;
    }
    /**
     * Generate value of a random variable with exponential distribution, i.e.
     * <i>f(x; lambda) = lambda * e^(-lambda x)</i> if <i>x >= 0</i> and <i>f(x; lambda) = 0</i> if <i>x < 0</i>.
     * See <a href="https://en.wikipedia.org/wiki/Exponential_distribution">https://en.wikipedia.org/wiki/Exponential_distribution</a>.
     * Algorithm: D.E. Knuth, TAOCP 2, p. 128.
     *
     * @param {Number} lambda <i>&gt; 0</i>
     * @returns Number
     * @memberof JXG.Math.Statistics
     * @example
     *  let board = JXG.JSXGraph.initBoard('JXGbox',
     *       { boundingbox: [-.5, 1.5, 5, -.1], axis: true});
     *
     *   let runs = [
     *       [0.5, 'red'],
     *       [1.0, 'green'],
     *       [1.5, 'blue'],
     *   ]
     *
     *   let labelY = 1
     *   runs.forEach((run,i) => {
     *       board.create('segment',[[1.8,labelY-(i/20)],[2.3,labelY-(i/20)]],{strokeColor:run[1]})
     *       board.create('text',[2.5,labelY-(i/20),`&lambda;=${run[0]}`])
     *
     *       let x = Array(50000).fill(0).map(() => JXG.Math.Statistics.randomExponential(run[0]))
     *       let res = JXG.Math.Statistics.histogram(x, { bins: 40, density: true, cumulative: false, range: false });
     *       board.create('curve', [res[1], res[0]], { strokeColor: run[1], strokeWidth:2});
     *   })
     *
     * </pre><div id="JXGda56df4d-a5a5-4c87-9ffc-9bbc1b512302-5" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     * {
     *  let board = JXG.JSXGraph.initBoard('JXGda56df4d-a5a5-4c87-9ffc-9bbc1b512302-5',
     *       { boundingbox: [-.5, 1.5, 5, -.1], axis: true});
     *
     *   let runs = [
     *       [0.5, 'red'],
     *       [1.0, 'green'],
     *       [1.5, 'blue'],
     *   ]
     *
     *   let labelY = 1
     *   runs.forEach((run,i) => {
     *       board.create('segment',[[1.8,labelY-(i/20)],[2.3,labelY-(i/20)]],{strokeColor:run[1]})
     *       board.create('text',[2.5,labelY-(i/20),`&lambda;=${run[0]}`])
     *
     *       let x = Array(50000).fill(0).map(() => JXG.Math.Statistics.randomExponential(run[0]))
     *       let res = JXG.Math.Statistics.histogram(x, { bins: 40, density: true, cumulative: false, range: false });
     *       board.create('curve', [res[1], res[0]], { strokeColor: run[1], strokeWidth:2});
     *   })
     * }
     * </script><pre>

    */
    static randomExponential(lbda) {
        var u;
        // Knuth, TAOCP 2, p 128
        // See https://en.wikipedia.org/wiki/Exponential_distribution
        if (lbda <= 0) {
            return NaN;
        }
        do {
            u = Math.random();
        } while (u === 0);
        return -Math.log(u) / lbda;
    }
    /**
     * Generate value of a random variable with gamma distribution of order alpha.
     * See <a href="https://en.wikipedia.org/wiki/Gamma_distribution">https://en.wikipedia.org/wiki/Gamma_distribution</a>.
     * Algorithm: D.E. Knuth, TAOCP 2, p. 129.

     * @param {Number} a shape, <i> &gt; 0</i>
     * @param {Number} [b=1] scale, <i> &gt; 0</i>
     * @param {Number} [t=0] threshold
     * @returns Number
     * @memberof JXG.Math.Statistics
     * @example
     *  let board = JXG.JSXGraph.initBoard('jxgbox',
     *       { boundingbox: [-1.7, .5, 20, -.03], axis: true});
     *
     *   let runs = [
     *       [0.5, 1.0, 'brown'],
     *       [1.0, 2.0, 'red'],
     *       [2.0, 2.0, 'orange'],
     *       [3.0, 2.0, 'yellow'],
     *       [5.0, 1.0, 'green'],
     *       [9.0, 0.5, 'black'],
     *       [7.5, 1.0, 'purple'],
     *   ]
     *
     *   let labelY = .4
     *   runs.forEach((run,i) => {
     *       board.create('segment',[[7,labelY-(i/50)],[9,labelY-(i/50)]],{strokeColor:run[2]})
     *       board.create('text',[10,labelY-(i/50),`k=${run[0]}, &theta;=${run[1]}`])
     *
     *       // density
     *       let x = Array(50000).fill(0).map(() => JXG.Math.Statistics.randomGamma(run[0],run[1]))
     *       let res = JXG.Math.Statistics.histogram(x, { bins: 50, density: true, cumulative: false, range: [0, 20] });
     *       board.create('curve', [res[1], res[0]], { strokeColor: run[2]});
     *
     *   })
     *
     *
     * </pre>
     * <div id="JXGda56df4d-a5a5-4c87-9ffc-9bbc1b512302-6" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     * {
     *  let board = JXG.JSXGraph.initBoard('JXGda56df4d-a5a5-4c87-9ffc-9bbc1b512302-6',
     *       { boundingbox: [-1.7, .5, 20, -.03], axis: true});
     *
     *   let runs = [
     *       [0.5, 1.0, 'brown'],
     *       [1.0, 2.0, 'red'],
     *       [2.0, 2.0, 'orange'],
     *       [3.0, 2.0, 'yellow'],
     *       [5.0, 1.0, 'green'],
     *       [9.0, 0.5, 'black'],
     *       [7.5, 1.0, 'purple'],
     *   ]
     *
     *   let labelY = .4
     *   runs.forEach((run,i) => {
     *       board.create('segment',[[7,labelY-(i/50)],[9,labelY-(i/50)]],{strokeColor:run[2]})
     *       board.create('text',[10,labelY-(i/50),`k=${run[0]}, &theta;=${run[1]}`])
     *
     *       let x = Array(50000).fill(0).map(() => JXG.Math.Statistics.randomGamma(run[0],run[1]))
     *       let res = JXG.Math.Statistics.histogram(x, { bins: 50, density: true, cumulative: false, range: [0, 20] });
     *       board.create('curve', [res[1], res[0]], { strokeColor: run[2]});
     *   })
     * }
     * </script><pre>
     *
     */
    static randomGamma(a, b = 1, t = 0) {
        var u, v, x, y, p, q;
        if (a <= 0) {
            return NaN;
        }
        b = b || 1;
        t = t || 0;
        if (a === 1) {
            return b * this.randomExponential(1) + t;
        }
        if (a < 1) {
            // Method by Ahrens
            // Knuth, TAOCP 2, Ex. 16, p 551
            p = Math.E / (a + Math.E);
            do {
                u = Math.random();
                do {
                    v = Math.random();
                } while (v === 0);
                if (u < p) {
                    x = Math.pow(v, 1 / a);
                    q = Math.exp(-x);
                }
                else {
                    x = 1 - Math.log(v);
                    q = Math.pow(x, a - 1);
                }
                u = Math.random();
            } while (u >= q);
            return b * x + t;
        }
        // a > 1
        // Knuth, TAOCP 2, p 129
        do {
            y = Math.tan(Math.PI * Math.random());
            x = Math.sqrt(2 * a - 1) * y + a - 1;
            if (x > 0) {
                v = Math.random();
            }
            else {
                continue;
            }
        } while (x <= 0.0 || v > (1 + y * y) * Math.exp((a - 1) * Math.log(x / (a - 1)) - Math.sqrt(2 * a - 1) * y));
        return b * x + t;
    }
    /**
     * Generate value of a random variable with beta distribution with shape parameters alpha and beta.
     * See <a href="https://en.wikipedia.org/wiki/Beta_distribution">https://en.wikipedia.org/wiki/Beta_distribution</a>.
     *
     * @param {Number} alpha <i>&gt; 0</i>
     * @param {Number} beta <i>&gt; 0</i>
     * @returns Number
     * @memberof JXG.Math.Statistics
     */
    static randomBeta(a, b) {
        // Knuth, TAOCP 2, p 129
        var x1, x2, x;
        if (a <= 0 || b <= 0) {
            return NaN;
        }
        x1 = this.randomGamma(a);
        x2 = this.randomGamma(b);
        x = x1 / (x1 + x2);
        return x;
    }
    /**
     * Generate value of a random variable with chi-square distribution with k degrees of freedom.
     * See <a href="https://en.wikipedia.org/wiki/Chi-squared_distribution">https://en.wikipedia.org/wiki/Chi-squared_distribution</a>.
     *
     * @param {Number} k <i>&gt; 0</i>
     * @returns Number
     * @memberof JXG.Math.Statistics
     */
    static randomChisquare(nu) {
        // Knuth, TAOCP 2, p 130
        if (nu <= 0) {
            return NaN;
        }
        return 2 * this.randomGamma(nu * 0.5);
    }
    /**
     * Generate value of a random variable with F-distribution with d<sub>1</sub> and d<sub>2</sub> degrees of freedom.
     * See <a href="https://en.wikipedia.org/wiki/F-distribution">https://en.wikipedia.org/wiki/F-distribution</a>.
     * @param {Number} d1 <i>&gt; 0</i>
     * @param {Number} d2 <i>&gt; 0</i>
     * @returns Number
     * @memberof JXG.Math.Statistics
     */
    static randomF(nu1, nu2) {
        // Knuth, TAOCP 2, p 130
        var y1, y2;
        if (nu1 <= 0 || nu2 <= 0) {
            return NaN;
        }
        y1 = this.randomChisquare(nu1);
        y2 = this.randomChisquare(nu2);
        return (y1 * nu2) / (y2 * nu1);
    }
    /**
     * Generate value of a random variable with Students-t-distribution with &nu; degrees of freedom.
     * See <a href="https://en.wikipedia.org/wiki/Student%27s_t-distribution">https://en.wikipedia.org/wiki/Student%27s_t-distribution</a>.
     * @param {Number} nu <i>&gt; 0</i>
     * @returns Number
     * @memberof JXG.Math.Statistics
     */
    static randomT(nu) {
        // Knuth, TAOCP 2, p 130
        var y1, y2;
        if (nu <= 0) {
            return NaN;
        }
        y1 = this.randomNormal(0, 1);
        y2 = this.randomChisquare(nu);
        return y1 / Math.sqrt(y2 / nu);
    }
    /**
     * Generate values for a random variable in binomial distribution with parameters <i>n</i> and <i>p</i>.
     * See <a href="https://en.wikipedia.org/wiki/Binomial_distribution">https://en.wikipedia.org/wiki/Binomial_distribution</a>.
     * It uses algorithm BG from <a href="https://dl.acm.org/doi/pdf/10.1145/42372.42381">https://dl.acm.org/doi/pdf/10.1145/42372.42381</a>.
     *
     * @param {Number} n Number of trials (n >= 0)
     * @param {Number} p Probability (0 <= p <= 1)
     * @returns Number Integer value of a random variable in binomial distribution
     * @memberof JXG.Math.Statistics
     *
     * @example
     * let board = JXG.JSXGraph.initBoard('jxgbox',
     *     { boundingbox: [-1.7, .5, 30, -.03], axis: true });
     *
     * let runs = [
     *     [0.5, 20, 'blue'],
     *     [0.7, 20, 'green'],
     *     [0.5, 40, 'red'],
     * ];
     *
     * let labelY = .4;
     * runs.forEach((run, i) => {
     *     board.create('segment', [[7, labelY - (i / 50)], [9, labelY - (i / 50)]], { strokeColor: run[2] });
     *     board.create('text', [10, labelY - (i / 50), `p=${run[0]}, n=${run[1]}`]);
     *
     *     let x = Array(50000).fill(0).map(() => JXG.Math.Statistics.randomBinomial(run[1], run[0]));
     *     let res = JXG.Math.Statistics.histogram(x, {
     *         bins: 40,
     *         density: true,
     *         cumulative: false,
     *         range: [0, 40]
     *     });
     *     board.create('curve', [res[1], res[0]], { strokeColor: run[2] });
     * });
     *
     *
     * </pre><div id="JXGda56df4d-a5a5-4c87-9ffc-9bbc1b512302-3" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     * {
     *  let board = JXG.JSXGraph.initBoard('JXGda56df4d-a5a5-4c87-9ffc-9bbc1b512302-3',
     *       { boundingbox: [-1.7, .5, 30, -.03], axis: true});
     *
     *   let runs = [
     *       [0.5, 20, 'blue'],
     *       [0.7, 20, 'green'],
     *       [0.5, 40, 'red'],
     *   ]
     *
     *   let labelY = .4
     *   runs.forEach((run,i) => {
     *       board.create('segment',[[7,labelY-(i/50)],[9,labelY-(i/50)]],{strokeColor:run[2]})
     *       board.create('text',[10,labelY-(i/50),`p=${run[0]}, n=${run[1]}`])
     *
     *       let x = Array(50000).fill(0).map(() => JXG.Math.Statistics.randomBinomial(run[1],run[0]))
     *       let res = JXG.Math.Statistics.histogram(x, { bins: 40, density: true, cumulative: false, range: [0, 40] });
     *       board.create('curve', [res[1], res[0]], { strokeColor: run[2]});
     *   })
     * }
     * </script><pre>
     *
     */
    static randomBinomial(n, p) {
        var x, y, c, a, b, N1;
        if (p < 0 || p > 1 || n < 0) {
            return NaN;
        }
        // Edge cases
        if (p === 0) {
            return 0;
        }
        if (p === 1) {
            return n;
        }
        // Now, we can assume 0 < p < 1.
        // Fast path for common cases
        if (n === 0) {
            return 0;
        }
        if (n === 1) {
            return ((Math.random() < p) ? 1 : 0);
        }
        // Exploit symmetry
        if (p > 0.5) {
            return n - this.randomBinomial(n, 1 - p);
        }
        // General case: n > 1, p <= 0.5
        if (n < 100) {
            // n small:
            // Algorithm BG (Devroye) from:
            // https://dl.acm.org/doi/pdf/10.1145/42372.42381
            // Time O(np) so suitable for np small only.
            x = -1;
            y = 0;
            c = Math.log(1 - p);
            if (c === 0) {
                return 0;
            }
            do {
                x += 1;
                y += Math.floor(Math.log(Math.random()) / c) + 1;
            } while (y < n);
        }
        else {
            // n large:
            // Knuth, TAOCP 2, p 131
            a = 1 + Math.floor(n * 0.5);
            b = n - a + 1;
            x = this.randomBeta(a, b);
            if (x >= p) {
                N1 = this.randomBinomial(a - 1, p / x);
                x = N1;
            }
            else {
                N1 = this.randomBinomial(b - 1, (p - x) / (1 - x));
                x = a + N1;
            }
        }
        return x;
    }
    /**
     * Generate values for a random variable in geometric distribution with probability <i>p</i>.
     * See <a href="https://en.wikipedia.org/wiki/Geometric_distribution">https://en.wikipedia.org/wiki/Geometric_distribution</a>.
     *
     * @param {Number} p (0 <= p <= 1)
     * @returns Number
     * @memberof JXG.Math.Statistics
     */
    static randomGeometric(p) {
        var u;
        if (p < 0 || p > 1) {
            return NaN;
        }
        // Knuth, TAOCP 2, p 131
        u = Math.random();
        return Math.ceil(Math.log(u) / Math.log(1 - p));
    }
    /**
     * Generate values for a random variable in Poisson distribution with mean <i>mu</i>.
     * See <a href="https://en.wikipedia.org/wiki/Poisson_distribution">https://en.wikipedia.org/wiki/Poisson_distribution</a>.
     *
     * @param {Number} mu (0 < mu)
     * @returns Number
     * @memberof JXG.Math.Statistics
     */
    static randomPoisson(mu) {
        var e = Math.exp(-mu), N, m = 0, u = 1, x, alpha = 7 / 8;
        if (mu <= 0) {
            return NaN;
        }
        // Knuth, TAOCP 2, p 132
        if (mu < 10) {
            do {
                u *= Math.random();
                m += 1;
            } while (u > e);
            N = m - 1;
        }
        else {
            m = Math.floor(alpha * mu);
            x = this.randomGamma(m);
            if (x < mu) {
                N = m + this.randomPoisson(mu - x);
            }
            else {
                N = this.randomBinomial(m - 1, mu / x);
            }
        }
        return N;
    }
    /**
     * Generate values for a random variable in Pareto distribution with
     * shape <i>gamma</i> and scale <i>k</i>.
     * See <a href="https://en.wikipedia.org/wiki/Pareto_distribution">https://en.wikipedia.org/wiki/Pareto_distribution</a>.
     * Method: use inverse transformation sampling.
     *
     * @param {Number} gamma shape (0 < gamma)
     * @param {Number} k scale (0 < k < x)
     * @returns Number
     * @memberof JXG.Math.Statistics
     */
    static randomPareto(gamma, k) {
        var u = Math.random();
        if (gamma <= 0 || k <= 0) {
            return NaN;
        }
        return k * Math.pow(1 - u, -1 / gamma);
    }
    /**
     * Generate values for a random variable in hypergeometric distribution.
     * Samples are drawn from a hypergeometric distribution with specified parameters, <i>good</i> (ways to make a good selection),
     * <i>bad</i> (ways to make a bad selection), and <i>samples</i> (number of items sampled, which is less than or equal to <i>good + bad</i>).
     * <p>
     * Naive implementation with runtime <i>O(samples)</i>.
     *
     * @param {Number} good ways to make a good selection
     * @param {Number} bad ways to make a bad selection
     * @param {Number} samples number of items sampled
     * @returns
     * @memberof JXG.Math.Statistics
     */
    static randomHypergeometric(good, bad, k) {
        var i, u, x = 0, 
        // kk,
        // n = good + bad,
        d1 = good + bad - k, d2 = Math.min(good, bad), y = d2;
        if (good < 1 || bad < 1 || k > good + bad) {
            return NaN;
        }
        // Naive method
        // kk = Math.min(k, n - k);
        // for (i = 0; i < k; i ++) {
        //     u = Math.random();
        //     if (n * u <= good) {
        //         x += 1;
        //         if (x === good) {
        //             return x;
        //         }
        //         good -= 1;
        //     }
        //     n -= 1;
        // }
        // return x;
        // Implementation from
        // Monte Carlo by George S. Fishman
        // https://link.springer.com/book/10.1007/978-1-4757-2553-7
        // page 218
        //
        i = k;
        while (y * i > 0) {
            u = Math.random();
            y -= Math.floor(u + y / (d1 + i));
            i -= 1;
        }
        x = d2 - y;
        if (good <= bad) {
            return x;
        }
        else {
            return k - x;
        }
    }
    /**
     * Compute the histogram of a dataset.
     * Optional parameters can be supplied through a JavaScript object
     * with the following default values:
     * <pre>
     * {
     *   bins: 10,          // Number of bins
     *   range: false,      // false or array. The lower and upper range of the bins.
     *                      // If not provided, range is simply [min(x), max(x)].
     *                      // Values outside the range are ignored.
     *   density: false,    // If true, normalize the counts by dividing by sum(counts)
     *   cumulative: false
     * }
     * </pre>
     * The function returns an array containing two arrays. The first array is of length bins+1
     * containing the start values of the bins. The last entry contains the end values of the last bin.
     * <p>
     * The second array contains the counts of each bin.
     * @param {Array} x
     * @param {Object} opt Optional parameters
     * @returns Array [bin, counts] Array bins contains start values of bins, array counts contains
     * the number of entries of x which are contained in each bin.
     * @memberof JXG.Math.Statistics
     *
     * @example
     *  let board = JXG.JSXGraph.initBoard('jxgbox',
     *       { boundingbox: [-1.7, .5, 20, -.03], axis: true});
     *  let board2 = JXG.JSXGraph.initBoard('jxgbox2',
     *       { boundingbox: [-1.6, 1.1, 20, -.06], axis: true});
     *
     *   let runs = [
     *       [0.5, 1.0, 'brown'],
     *       [1.0, 2.0, 'red'],
     *       [2.0, 2.0, 'orange'],
     *       [3.0, 2.0, 'yellow'],
     *       [5.0, 1.0, 'green'],
     *       [9.0, 0.5, 'black'],
     *       [7.5, 1.0, 'purple'],
     *   ]
     *
     *   let labelY = .4
     *   runs.forEach((run,i) => {
     *       board.create('segment',[[7,labelY-(i/50)],[9,labelY-(i/50)]],{strokeColor:run[2]})
     *       board.create('text',[10,labelY-(i/50),`k=${run[0]}, &theta;=${run[1]}`])
     *
     *       // density
     *       let x = Array(50000).fill(0).map(() => JXG.Math.Statistics.randomGamma(run[0],run[1]))
     *       let res = JXG.Math.Statistics.histogram(x, { bins: 50, density: true, cumulative: false, range: [0, 20] });
     *       board.create('curve', [res[1], res[0]], { strokeColor: run[2], strokeWidth:2});
     *
     *       // cumulative density
     *       res = JXG.Math.Statistics.histogram(x, { bins: 50, density: true, cumulative: true, range: [0, 20] });
     *       res[0].unshift(0)  // add zero to front so cumulative starts at zero
     *       res[1].unshift(0)
     *       board2.create('curve', [res[1], res[0]], { strokeColor: run[2], strokeWidth:2 });
     *   })
     *
     *
     * </pre><div id="JXGda56df4d-a5a5-4c87-9ffc-9bbc1b512302" class="jxgbox" style="width: 300px; height: 300px; float:left;"></div>
     * <div style='float:left;'>&nbsp;&nbsp;</div>
     * <div id="JXGda56df4d-a5a5-4c87-9ffc-9bbc1b512302-2" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     * {
     *  let board = JXG.JSXGraph.initBoard('JXGda56df4d-a5a5-4c87-9ffc-9bbc1b512302',
     *       { boundingbox: [-1.7, .5, 20, -.03], axis: true});
     *  let board2 = JXG.JSXGraph.initBoard('JXGda56df4d-a5a5-4c87-9ffc-9bbc1b512302-2',
     *       { boundingbox: [-1.6, 1.1, 20, -.06], axis: true});
     *
     *   let runs = [
     *       [0.5, 1.0, 'brown'],
     *       [1.0, 2.0, 'red'],
     *       [2.0, 2.0, 'orange'],
     *       [3.0, 2.0, 'yellow'],
     *       [5.0, 1.0, 'green'],
     *       [9.0, 0.5, 'black'],
     *       [7.5, 1.0, 'purple'],
     *   ]
     *
     *   let labelY = .4
     *   runs.forEach((run,i) => {
     *       board.create('segment',[[7,labelY-(i/50)],[9,labelY-(i/50)]],{strokeColor:run[2]})
     *       board.create('text',[10,labelY-(i/50),`k=${run[0]}, &theta;=${run[1]}`])
     *
     *       let x = Array(50000).fill(0).map(() => JXG.Math.Statistics.randomGamma(run[0],run[1]))
     *       let res = JXG.Math.Statistics.histogram(x, { bins: 50, density: true, cumulative: false, range: [0, 20] });
     *       board.create('curve', [res[1], res[0]], { strokeColor: run[2], strokeWidth:2});
     *
     *       // cumulative density
     *       res = JXG.Math.Statistics.histogram(x, { bins: 50, density: true, cumulative: true, range: [0, 20] });
     *       res[0].unshift(0)  // add zero to front so cumulative starts at zero
     *       res[1].unshift(0)
     *       board2.create('curve', [res[1], res[0]], { strokeColor: run[2], strokeWidth:2 });
     *   })
     * }
     * </script><pre>
     *
     */
    static histogram(x, opt) {
        var i, le, k, mi, ma, num_bins, delta, range, s, counts = [], bins = [], no_bin = 0; // Count of long tail elements not in histogram range
        // Evaluate number of bins
        num_bins = opt.bins || 10;
        // Evaluate range
        range = opt.range || false;
        if (range === false) {
            mi = Math.min.apply(null, x);
            ma = Math.max.apply(null, x);
        }
        else {
            mi = range[0];
            ma = range[1];
        }
        // Set uniform delta
        if (num_bins > 0) {
            delta = (ma - mi) / (num_bins - 1);
        }
        else {
            delta = 0;
        }
        // Set the bins and init the counts array
        for (i = 0; i < num_bins; i++) {
            counts.push(0);
            bins.push(mi + i * delta);
        }
        // bins.push(ma);
        // Determine the counts
        le = x.length;
        for (i = 0; i < le; i++) {
            k = Math.floor((x[i] - mi) / delta);
            if (k >= 0 && k < num_bins) {
                counts[k] += 1;
            }
            else {
                no_bin += 1;
            }
        }
        // Normalize if density===true
        if (opt.density) {
            s = Statistics.sum(counts) + no_bin; // Normalize including long tail
            for (i = 0; i < num_bins; i++) {
                counts[i] /= (s * delta);
                // counts[i] /= s;
            }
        }
        // Cumulative counts
        if (opt.cumulative) {
            if (opt.density) {
                for (i = 0; i < num_bins; i++) {
                    counts[i] *= delta; // Normalize
                }
            }
            for (i = 1; i < num_bins; i++) {
                counts[i] += counts[i - 1];
            }
        }
        return [counts, bins];
    }
}
Statistics.hasSpare = false;

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */
/*global JXG: true, define: true*/
/*jslint nomen: true, plusplus: true*/
/**
 * @fileoverview A class for complex arithmetics JXG.Complex is defined in this
 * file. Also a namespace JXG.C is included to provide instance-independent
 * arithmetic functions.
 */
// import { JXG } from "../jxg.js";
/**
 * Creates a new complex number. See also {@link JXG.C}.
 * @class This class is for calculating with complex numbers, see also {@link JXG.C} for more methods.
 * @constructor
 * @param {Number} [x=0] Real part.
 * @param {Number} [y=0] Imaginary part.
 * @see JXG.C
 */
class Complex {
    constructor(x, y = 0) {
        /**
         * This property is only to signalize that this object is of type JXG.Complex. Only
         * used internally to distinguish between normal JavaScript numbers and JXG.Complex numbers.
         * @type Boolean
         * @default true
         * @private
         */
        this.isComplex = true;
        /* is the first argument a complex number? if it is,
         * extract real and imaginary part. */
        if (typeof x === 'object' && x.isComplex) {
            y = x.imaginary;
            x = x.real;
        }
        // let TypeScript know x and y are definitely numbers now
        this.assertIsNumber(x);
        this.assertIsNumber(y);
        /**
         * Real part of the complex number.
         * @type Number
         * @default 0
         */
        this.real = x || 0;
        /**
         * Imaginary part of the complex number.
         * @type Number
         * @default 0
         */
        this.imaginary = y || 0;
        // /**
        //  * Absolute value in the polar form of the complex number. Currently unused.
        //  * @type Number
        //  */
        // this.absval = 0;
        // /**
        //  * Angle value in the polar form of the complex number. Currently unused.
        //  * @type Number
        //  */
        // this.angle = 0;
    }
    ;
    /** TypeScript magic - see https://mariusschulz.com/blog/assertion-functions-in-typescript */
    assertIsNumber(value) {
        if (typeof value !== 'number')
            throw new Error('Not a number');
    }
    /**
     * Converts a complex number into a string.
     * @returns {String} Formatted string containing the complex number in human readable form (algebraic form).
     */
    toString() {
        return this.real + " + " + this.imaginary + "i";
    }
    /**
     * Add another complex number to this complex number.
     * @param {JXG.Complex|Number} c A JavaScript number or a JXG.Complex object to be added to the current object.
     * @returns {JXG.Complex} Reference to this complex number
     */
    add(c) {
        if (Type.isNumber(c)) {
            this.real += c;
        }
        else {
            this.real += c.real;
            this.imaginary += c.imaginary;
        }
        return this;
    }
    /**
     * Subtract another complex number from this complex number.
     * @param {JXG.Complex|Number} c A JavaScript number or a JXG.Complex object to subtract from the current object.
     * @returns {JXG.Complex} Reference to this complex number
     */
    sub(c) {
        if (typeof c === 'number') { //(Type.isNumber(c)) {
            this.real -= c;
        }
        else {
            this.real -= c.real;
            this.imaginary -= c.imaginary;
        }
        return this;
    }
    /**
     * Multiply another complex number to this complex number.
     * @param {JXG.Complex|Number} c A JavaScript number or a JXG.Complex object to
     * multiply with the current object.
     * @returns {JXG.Complex} Reference to this complex number
     */
    mult(c) {
        var re, im;
        if (Type.isNumber(c)) {
            this.real *= c;
            this.imaginary *= c;
        }
        else {
            re = this.real;
            im = this.imaginary;
            //  (a+ib)(x+iy) = ax-by + i(xb+ay)
            this.real = re * c.real - im * c.imaginary;
            this.imaginary = re * c.imaginary + im * c.real;
        }
        return this;
    }
    /**
     * Divide this complex number by the given complex number.
     * @param {JXG.Complex|Number} c A JavaScript number or a JXG.Complex object to
     * divide the current object by.
     * @returns {JXG.Complex} Reference to this complex number
     */
    div(c) {
        var denom, im, re;
        if (Type.isNumber(c)) {
            if (Math.abs(c) < JSXMath.eps) {
                this.real = Infinity;
                this.imaginary = Infinity;
                return this;
            }
            this.real /= c;
            this.imaginary /= c;
        }
        else {
            //  (a+ib)(x+iy) = ax-by + i(xb+ay)
            if (Math.abs(c.real) < JSXMath.eps && Math.abs(c.imaginary) < JSXMath.eps) {
                this.real = Infinity;
                this.imaginary = Infinity;
                return this;
            }
            denom = c.real * c.real + c.imaginary * c.imaginary;
            re = this.real;
            im = this.imaginary;
            this.real = (re * c.real + im * c.imaginary) / denom;
            this.imaginary = (im * c.real - re * c.imaginary) / denom;
        }
        return this;
    }
    /**
     * Conjugate a complex number in place.
     * @returns {JXG.Complex} Reference to this complex number
     */
    conj() {
        this.imaginary *= -1;
        return this;
    }
    /**
     * Absolute value in the polar form, i.e. |z| of the complex number z.
     * @returns Number
     */
    abs() {
        var x = this.real, y = this.imaginary;
        return Math.sqrt(x * x + y * y);
    }
    /**
     * Angle value in the polar form of the complex number (in radians).
     * @returns Number
     */
    angle() {
        return Math.atan2(this.imaginary, this.real);
    }
}
/**
 * @namespace Namespace for the complex number arithmetic functions, see also {@link JXG.Complex}.
 * @description
 * JXG.C is the complex number (name)space. It provides functions to calculate with
 * complex numbers (defined in {@link JXG.Complex}). With this namespace you don't have to modify
 * your existing complex numbers, e.g. to add two complex numbers:
 * <pre class="code">   var z1 = new JXG.Complex(1, 0);
 *    var z2 = new JXG.Complex(0, 1);
 *    z = JXG.C.add(z1, z1);</pre>
 * z1 and z2 here remain unmodified. With the object oriented approach above this
 * section the code would look like:
 * <pre class="code">
 *    var z1 = new JXG.Complex(1, 0);
 *    var z2 = new JXG.Complex(0, 1);
 *    var z = new JXG.Complex(z1);
 *    z.add(z2);</pre>
 * @see JXG.Complex
 */
class C {
    /**
     * Add two (complex) numbers z1 and z2 and return the result as a (complex) number.
     * @param {JXG.Complex|Number} z1 Summand
     * @param {JXG.Complex|Number} z2 Summand
     * @returns {JXG.Complex} A complex number equal to the sum of the given parameters.
     */
    static add(z1, z2) {
        var z = new Complex(z1);
        z.add(z2);
        return z;
    }
    ;
    /**
     * Subtract two (complex) numbers z1 and z2 and return the result as a (complex) number.
     * @param {JXG.Complex|Number} z1 Minuend
     * @param {JXG.Complex|Number} z2 Subtrahend
     * @returns {JXG.Complex} A complex number equal to the difference of the given parameters.
     */
    static sub(z1, z2) {
        var z = new Complex(z1);
        z.sub(z2);
        return z;
    }
    ;
    /**
     * Multiply two (complex) numbers z1 and z2 and return the result as a (complex) number.
     * @param {JXG.Complex|Number} z1 Factor
     * @param {JXG.Complex|Number} z2 Factor
     * @returns {JXG.Complex} A complex number equal to the product of the given parameters.
     */
    static mult(z1, z2) {
        var z = new Complex(z1);
        z.mult(z2);
        return z;
    }
    ;
    /**
     * Divide two (complex) numbers z1 and z2 and return the result as a (complex) number.
     * @param {JXG.Complex|Number} z1 Dividend
     * @param {JXG.Complex|Number} z2 Divisor
     * @returns {JXG.Complex} A complex number equal to the quotient of the given parameters.
     */
    static div(z1, z2) {
        var z = new Complex(z1);
        z.div(z2);
        return z;
    }
    ;
    /**
     * Conjugate a complex number and return the result.
     * @param {JXG.Complex|Number} z1 Complex number
     * @returns {JXG.Complex} A complex number equal to the conjugate of the given parameter.
     */
    static conj(z1) {
        var z = new Complex(z1);
        z.conj();
        return z;
    }
    ;
    /**
     * Absolute value of a complex number.
     * @param {JXG.Complex|Number} z1 Complex number
     * @returns {Number} real number equal to the absolute value of the given parameter.
     */
    static abs(z1) {
        var z = new Complex(z1);
        // z.conj();
        // z.mult(z1);
        // return Math.sqrt(z.real);
        return z.abs();
    }
    ;
    /**
     * Angle of a complex number (in radians).
     * @param {JXG.Complex|Number} z1 Complex number
     * @returns {Number} real number equal to the angle value of the given parameter.
     */
    static angle(z1) {
        var z = new Complex(z1);
        return z.angle();
    }
    ;
    /**
     * Create copy of complex number.
     *
     * @param {JXG.Complex|Number} z
     * @returns {JXG.Complex}
     */
    static copy(z) {
        return new Complex(z);
    }
    ;
}

// some dummies for testing
// Predefined butcher tableaus for the common Runge-Kutta method (fourth order), Heun method (second order), and Euler method (first order).
var predefinedButcher = {
    rk4: {
        s: 4,
        A: [
            [0, 0, 0, 0],
            [0.5, 0, 0, 0],
            [0, 0.5, 0, 0],
            [0, 0, 1, 0]
        ],
        b: [1.0 / 6.0, 1.0 / 3.0, 1.0 / 3.0, 1.0 / 6.0],
        c: [0, 0.5, 0.5, 1]
    },
    heun: {
        s: 2,
        A: [
            [0, 0],
            [1, 0]
        ],
        b: [0.5, 0.5],
        c: [0, 1]
    },
    euler: {
        s: 1,
        A: [[0]],
        b: [1],
        c: [0]
    }
};
/**
 * The JXG.Math.Numerics namespace holds numerical algorithms, constants, and variables.
 * @name JXG.Math.Numerics
 * @exports JSXMath.Numerics as JXG.Math.Numerics
 * @namespace
 */
class Numerics {
    //JXG.extend(JSXMath.Numerics, /** @lends JXG.Math.Numerics */ {
    /**
     * Solves a system of linear equations given by A and b using the Gauss-Jordan-elimination.
     * The algorithm runs in-place. I.e. the entries of A and b are changed.
     * @param {Array} A Square matrix represented by an array of rows, containing the coefficients of the lineare equation system.
     * @param {Array} b A vector containing the linear equation system's right hand side.
     * @throws {Error} If a non-square-matrix is given or if b has not the right length or A's rank is not full.
     * @returns {Array} A vector that solves the linear equation system.
     * @memberof JXG.Math.Numerics
     */
    static Gauss(A, b) {
        var i, j, k, 
        // copy the matrix to prevent changes in the original
        Acopy, 
        // solution vector, to prevent changing b
        x, eps = JSXMath.eps, 
        // number of columns of A
        n = A.length > 0 ? A[0].length : 0;
        if (n !== b.length || n !== A.length) {
            throw new Error("JXG.Math.Numerics.Gauss: Dimensions don't match. A must be a square matrix and b must be of the same length as A.");
        }
        // initialize solution vector
        Acopy = [];
        x = b.slice(0, n);
        for (i = 0; i < n; i++) {
            Acopy[i] = A[i].slice(0, n);
        }
        // Gauss-Jordan-elimination
        for (j = 0; j < n; j++) {
            for (i = n - 1; i > j; i--) {
                // Is the element which is to eliminate greater than zero?
                if (Math.abs(Acopy[i][j]) > eps) {
                    // Equals pivot element zero?
                    if (Math.abs(Acopy[j][j]) < eps) {
                        // At least numerically, so we have to exchange the rows
                        Type.swap(Acopy, i, j);
                        Type.swap(x, i, j);
                    }
                    else {
                        // Saves the L matrix of the LR-decomposition. unnecessary.
                        Acopy[i][j] /= Acopy[j][j];
                        // Transform right-hand-side b
                        x[i] -= Acopy[i][j] * x[j];
                        // subtract the multiple of A[i][j] / A[j][j] of the j-th row from the i-th.
                        for (k = j + 1; k < n; k++) {
                            Acopy[i][k] -= Acopy[i][j] * Acopy[j][k];
                        }
                    }
                }
            }
            // The absolute values of all coefficients below the j-th row in the j-th column are smaller than JXG.Math.eps.
            if (Math.abs(Acopy[j][j]) < eps) {
                throw new Error("JXG.Math.Numerics.Gauss(): The given matrix seems to be singular.");
            }
        }
        this.backwardSolve(Acopy, x, true);
        return x;
    }
    /**
     * Solves a system of linear equations given by the right triangular matrix R and vector b.
     * @param {Array} R Right triangular matrix represented by an array of rows. All entries a_(i,j) with i &lt; j are ignored.
     * @param {Array} b Right hand side of the linear equation system.
     * @param {Boolean} [canModify=false] If true, the right hand side vector is allowed to be changed by this method.
     * @returns {Array} An array representing a vector that solves the system of linear equations.
     * @memberof JXG.Math.Numerics
     */
    static backwardSolve(R, b, canModify) {
        var x, m, n, i, j;
        if (canModify) {
            x = b;
        }
        else {
            x = b.slice(0, b.length);
        }
        // m: number of rows of R
        // n: number of columns of R
        m = R.length;
        n = R.length > 0 ? R[0].length : 0;
        for (i = m - 1; i >= 0; i--) {
            for (j = n - 1; j > i; j--) {
                x[i] -= R[i][j] * x[j];
            }
            x[i] /= R[i][i];
        }
        return x;
    }
    /**
     *  Gauss-Bareiss algorithm to compute the
     *  determinant of matrix without fractions.
     *  See Henri Cohen, "A Course in Computational
     *  Algebraic Number Theory (Graduate texts
     *  in mathematics; 138)", Springer-Verlag,
     *  ISBN 3-540-55640-0 / 0-387-55640-0
     *  Third, Corrected Printing 1996
     *  "Algorithm 2.2.6", pg. 52-53
     *
     * @param {Array} mat Matrix
     * @returns Number
     * @private
     * @memberof JXG.Math.Numerics
     */
    static gaussBareiss(mat) {
        var k, c, s, i, j, p, n, M, t, eps = JSXMath.eps;
        n = mat.length;
        if (n <= 0) {
            return 0;
        }
        if (mat[0].length < n) {
            n = mat[0].length;
        }
        // Copy the input matrix to M
        M = [];
        for (i = 0; i < n; i++) {
            M[i] = mat[i].slice(0, n);
        }
        c = 1;
        s = 1;
        for (k = 0; k < n - 1; k++) {
            p = M[k][k];
            // Pivot step
            if (Math.abs(p) < eps) {
                for (i = k + 1; i < n; i++) {
                    if (Math.abs(M[i][k]) >= eps) {
                        break;
                    }
                }
                // No nonzero entry found in column k -> det(M) = 0
                if (i === n) {
                    return 0.0;
                }
                // swap row i and k partially
                for (j = k; j < n; j++) {
                    t = M[i][j];
                    M[i][j] = M[k][j];
                    M[k][j] = t;
                }
                s = -s;
                p = M[k][k];
            }
            // Main step
            for (i = k + 1; i < n; i++) {
                for (j = k + 1; j < n; j++) {
                    t = p * M[i][j] - M[i][k] * M[k][j];
                    M[i][j] = t / c;
                }
            }
            c = p;
        }
        return s * M[n - 1][n - 1];
    }
    /**
     * Computes the determinant of a square nxn matrix with the
     * Gauss-Bareiss algorithm.
     * @param {Array} mat Matrix.
     * @returns {Number} The determinant pf the matrix mat.
     *                   The empty matrix returns 0.
     * @memberof JXG.Math.Numerics
     */
    static det(mat) {
        var n = mat.length;
        if (n === 2 && mat[0].length === 2) {
            return mat[0][0] * mat[1][1] - mat[1][0] * mat[0][1];
        }
        return this.gaussBareiss(mat);
    }
    /**
     * Compute the Eigenvalues and Eigenvectors of a symmetric 3x3 matrix with the Jacobi method
     * Adaption of a FORTRAN program by Ed Wilson, Dec. 25, 1990
     * @param {Array} Ain A symmetric 3x3 matrix.
     * @returns {Array} [A,V] the matrices A and V. The diagonal of A contains the Eigenvalues, V contains the Eigenvectors.
     * @memberof JXG.Math.Numerics
     */
    static Jacobi(Ain) {
        var i, j, k, aa, si, co, tt, ssum, eps = JSXMath.eps * JSXMath.eps, sum = 0.0, n = Ain.length, V = [
            [0, 0, 0],
            [0, 0, 0],
            [0, 0, 0]
        ], A = [
            [0, 0, 0],
            [0, 0, 0],
            [0, 0, 0]
        ], nloops = 0;
        // Initialization. Set initial Eigenvectors.
        for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
                V[i][j] = 0.0;
                A[i][j] = Ain[i][j];
                sum += Math.abs(A[i][j]);
            }
            V[i][i] = 1.0;
        }
        // Trivial problems
        if (n === 1) {
            return [A, V];
        }
        if (sum <= 0.0) {
            return [A, V];
        }
        sum /= n * n;
        // Reduce matrix to diagonal
        do {
            ssum = 0.0;
            for (j = 1; j < n; j++) {
                for (i = 0; i < j; i++) {
                    // Check if A[i][j] is to be reduced
                    aa = Math.abs(A[i][j]);
                    ssum += aa;
                    if (aa >= eps) {
                        // calculate rotation angle
                        aa = Math.atan2(2.0 * A[i][j], A[i][i] - A[j][j]) * 0.5;
                        si = Math.sin(aa);
                        co = Math.cos(aa);
                        // Modify 'i' and 'j' columns
                        for (k = 0; k < n; k++) {
                            tt = A[k][i];
                            A[k][i] = co * tt + si * A[k][j];
                            A[k][j] = -si * tt + co * A[k][j];
                            tt = V[k][i];
                            V[k][i] = co * tt + si * V[k][j];
                            V[k][j] = -si * tt + co * V[k][j];
                        }
                        // Modify diagonal terms
                        A[i][i] = co * A[i][i] + si * A[j][i];
                        A[j][j] = -si * A[i][j] + co * A[j][j];
                        A[i][j] = 0.0;
                        // Make 'A' matrix symmetrical
                        for (k = 0; k < n; k++) {
                            A[i][k] = A[k][i];
                            A[j][k] = A[k][j];
                        }
                        // A[i][j] made zero by rotation
                    }
                }
            }
            nloops += 1;
        } while (Math.abs(ssum) / sum > eps && nloops < 2000);
        return [A, V];
    }
    /**
     * Calculates the integral of function f over interval using Newton-Cotes-algorithm.
     * @param {Array} interval The integration interval, e.g. [0, 3].
     * @param {function} f A function which takes one argument of type number and returns a number.
     * @param {Object} [config] The algorithm setup. Accepted properties are number_of_nodes of type number and integration_type
     * with value being either 'trapez', 'simpson', or 'milne'.
     * @param {Number} [config.number_of_nodes=28]
     * @param {String} [config.integration_type='milne'] Possible values are 'milne', 'simpson', 'trapez'
     * @returns {Number} Integral value of f over interval
     * @throws {Error} If config.number_of_nodes doesn't match config.integration_type an exception is thrown. If you want to use
     * simpson rule respectively milne rule config.number_of_nodes must be dividable by 2 respectively 4.
     * @example
     * function f(x) {
     *   return x*x;
     * }
     *
     * // calculates integral of <tt>f</tt> from 0 to 2.
     * var area1 = JXG.Math.Numerics.NewtonCotes([0, 2], f);
     *
     * // the same with an anonymous function
     * var area2 = JXG.Math.Numerics.NewtonCotes([0, 2], function (x) { return x*x; });
     *
     * // use trapez rule with 16 nodes
     * var area3 = JXG.Math.Numerics.NewtonCotes([0, 2], f,
     *                                   {number_of_nodes: 16, integration_type: 'trapez'});
     * @memberof JXG.Math.Numerics
     */
    static NewtonCotes(interval, f, config) {
        var evaluation_point, i, number_of_intervals, integral_value = 0.0, number_of_nodes = config && Type.isNumber(config.number_of_nodes) ? config.number_of_nodes : 28, available_types = { trapez: true, simpson: true, milne: true }, integration_type = config &&
            config.integration_type &&
            available_types.hasOwnProperty(config.integration_type) &&
            available_types[config.integration_type]
            ? config.integration_type
            : "milne";
        let step_size = (interval[1] - interval[0]) / number_of_nodes;
        switch (integration_type) {
            case "trapez":
                integral_value = (f(interval[0]) + f(interval[1])) * 0.5;
                evaluation_point = interval[0];
                for (i = 0; i < number_of_nodes - 1; i++) {
                    evaluation_point += step_size;
                    integral_value += f(evaluation_point);
                }
                integral_value *= step_size;
                break;
            case "simpson":
                if (number_of_nodes % 2 > 0) {
                    throw new Error("JSXGraph:  INT_SIMPSON requires config.number_of_nodes dividable by 2.");
                }
                number_of_intervals = number_of_nodes / 2.0;
                integral_value = f(interval[0]) + f(interval[1]);
                evaluation_point = interval[0];
                for (i = 0; i < number_of_intervals - 1; i++) {
                    evaluation_point += 2.0 * step_size;
                    integral_value += 2.0 * f(evaluation_point);
                }
                evaluation_point = interval[0] - step_size;
                for (i = 0; i < number_of_intervals; i++) {
                    evaluation_point += 2.0 * step_size;
                    integral_value += 4.0 * f(evaluation_point);
                }
                integral_value *= step_size / 3.0;
                break;
            default:
                if (number_of_nodes % 4 > 0) {
                    throw new Error("JSXGraph: Error in INT_MILNE: config.number_of_nodes must be a multiple of 4");
                }
                number_of_intervals = number_of_nodes * 0.25;
                integral_value = 7.0 * (f(interval[0]) + f(interval[1]));
                evaluation_point = interval[0];
                for (i = 0; i < number_of_intervals - 1; i++) {
                    evaluation_point += 4.0 * step_size;
                    integral_value += 14.0 * f(evaluation_point);
                }
                evaluation_point = interval[0] - 3.0 * step_size;
                for (i = 0; i < number_of_intervals; i++) {
                    evaluation_point += 4.0 * step_size;
                    integral_value +=
                        32.0 * (f(evaluation_point) + f(evaluation_point + 2 * step_size));
                }
                evaluation_point = interval[0] - 2.0 * step_size;
                for (i = 0; i < number_of_intervals; i++) {
                    evaluation_point += 4.0 * step_size;
                    integral_value += 12.0 * f(evaluation_point);
                }
                integral_value *= (2.0 * step_size) / 45.0;
        }
        return integral_value;
    }
    /**
     * Calculates the integral of function f over interval using Romberg iteration.
     * @param {Array} interval The integration interval, e.g. [0, 3].
     * @param {function} f A function which takes one argument of type number and returns a number.
     * @param {Object} [config] The algorithm setup. Accepted properties are max_iterations of type number and precision eps.
     * @param {Number} [config.max_iterations=20]
     * @param {Number} [config.eps=0.0000001]
     * @returns {Number} Integral value of f over interval
     * @example
     * function f(x) {
     *   return x*x;
     * }
     *
     * // calculates integral of <tt>f</tt> from 0 to 2.
     * var area1 = JXG.Math.Numerics.Romberg([0, 2], f);
     *
     * // the same with an anonymous function
     * var area2 = JXG.Math.Numerics.Romberg([0, 2], function (x) { return x*x; });
     *
     * // use trapez rule with maximum of 16 iterations or stop if the precision 0.0001 has been reached.
     * var area3 = JXG.Math.Numerics.Romberg([0, 2], f,
     *                                   {max_iterations: 16, eps: 0.0001});
     * @memberof JXG.Math.Numerics
     */
    static Romberg(interval, f, config) {
        var a, b, h, s, n, k, i, q, p = [], integral = 0.0, last = Infinity, m = config && Type.isNumber(config.max_iterations) ? config.max_iterations : 20, eps = config && Type.isNumber(config.eps) ? config.eps : config.eps || 0.0000001;
        a = interval[0];
        b = interval[1];
        h = b - a;
        n = 1;
        p[0] = 0.5 * h * (f(a) + f(b));
        for (k = 0; k < m; ++k) {
            s = 0;
            h *= 0.5;
            n *= 2;
            q = 1;
            for (i = 1; i < n; i += 2) {
                s += f(a + i * h);
            }
            p[k + 1] = 0.5 * p[k] + s * h;
            integral = p[k + 1];
            for (i = k - 1; i >= 0; --i) {
                q *= 4;
                p[i] = p[i + 1] + (p[i + 1] - p[i]) / (q - 1.0);
                integral = p[i];
            }
            if (Math.abs(integral - last) < eps * Math.abs(integral)) {
                break;
            }
            last = integral;
        }
        return integral;
    }
    /**
     * Calculates the integral of function f over interval using Gauss-Legendre quadrature.
     * @param {Array} interval The integration interval, e.g. [0, 3].
     * @param {function} f A function which takes one argument of type number and returns a number.
     * @param {Object} [config] The algorithm setup. Accepted property is the order n of type number. n is allowed to take
     * values between 2 and 18, default value is 12.
     * @param {Number} [config.n=16]
     * @returns {Number} Integral value of f over interval
     * @example
     * function f(x) {
     *   return x*x;
     * }
     *
     * // calculates integral of <tt>f</tt> from 0 to 2.
     * var area1 = JXG.Math.Numerics.GaussLegendre([0, 2], f);
     *
     * // the same with an anonymous function
     * var area2 = JXG.Math.Numerics.GaussLegendre([0, 2], function (x) { return x*x; });
     *
     * // use 16 point Gauss-Legendre rule.
     * var area3 = JXG.Math.Numerics.GaussLegendre([0, 2], f,
     *                                   {n: 16});
     * @memberof JXG.Math.Numerics
     */
    static GaussLegendre(interval, f, config) {
        var a, b, i, m, xp, xm, result = 0.0, table_xi = [], table_w = [], xi, w, n = config && Type.isNumber(config.n) ? config.n : 12;
        if (n > 18) {
            n = 18;
        }
        /* n = 2 */
        table_xi[2] = [0.5773502691896257645091488];
        table_w[2] = [1.0];
        /* n = 4 */
        table_xi[4] = [0.3399810435848562648026658, 0.8611363115940525752239465];
        table_w[4] = [0.6521451548625461426269361, 0.3478548451374538573730639];
        /* n = 6 */
        table_xi[6] = [
            0.2386191860831969086305017, 0.6612093864662645136613996,
            0.9324695142031520278123016
        ];
        table_w[6] = [
            0.4679139345726910473898703, 0.3607615730481386075698335,
            0.1713244923791703450402961
        ];
        /* n = 8 */
        table_xi[8] = [
            0.1834346424956498049394761, 0.525532409916328985817739,
            0.7966664774136267395915539, 0.9602898564975362316835609
        ];
        table_w[8] = [
            0.3626837833783619829651504, 0.3137066458778872873379622,
            0.222381034453374470544356, 0.1012285362903762591525314
        ];
        /* n = 10 */
        table_xi[10] = [
            0.148874338981631210884826, 0.4333953941292471907992659,
            0.6794095682990244062343274, 0.8650633666889845107320967, 0.973906528517171720077964
        ];
        table_w[10] = [
            0.295524224714752870173893, 0.2692667193099963550912269,
            0.2190863625159820439955349, 0.1494513491505805931457763,
            0.0666713443086881375935688
        ];
        /* n = 12 */
        table_xi[12] = [
            0.1252334085114689154724414, 0.3678314989981801937526915,
            0.5873179542866174472967024, 0.7699026741943046870368938,
            0.9041172563704748566784659, 0.9815606342467192506905491
        ];
        table_w[12] = [
            0.2491470458134027850005624, 0.2334925365383548087608499,
            0.2031674267230659217490645, 0.1600783285433462263346525,
            0.1069393259953184309602547, 0.047175336386511827194616
        ];
        /* n = 14 */
        table_xi[14] = [
            0.1080549487073436620662447, 0.3191123689278897604356718,
            0.5152486363581540919652907, 0.6872929048116854701480198,
            0.8272013150697649931897947, 0.9284348836635735173363911,
            0.9862838086968123388415973
        ];
        table_w[14] = [
            0.2152638534631577901958764, 0.2051984637212956039659241,
            0.1855383974779378137417166, 0.1572031671581935345696019,
            0.1215185706879031846894148, 0.0801580871597602098056333,
            0.0351194603317518630318329
        ];
        /* n = 16 */
        table_xi[16] = [
            0.0950125098376374401853193, 0.2816035507792589132304605,
            0.4580167776572273863424194, 0.6178762444026437484466718,
            0.7554044083550030338951012, 0.8656312023878317438804679,
            0.9445750230732325760779884, 0.9894009349916499325961542
        ];
        table_w[16] = [
            0.1894506104550684962853967, 0.1826034150449235888667637,
            0.1691565193950025381893121, 0.1495959888165767320815017,
            0.1246289712555338720524763, 0.0951585116824927848099251,
            0.0622535239386478928628438, 0.0271524594117540948517806
        ];
        /* n = 18 */
        table_xi[18] = [
            0.0847750130417353012422619, 0.2518862256915055095889729,
            0.4117511614628426460359318, 0.5597708310739475346078715,
            0.6916870430603532078748911, 0.8037049589725231156824175,
            0.8926024664975557392060606, 0.9558239495713977551811959, 0.991565168420930946730016
        ];
        table_w[18] = [
            0.1691423829631435918406565, 0.1642764837458327229860538,
            0.154684675126265244925418, 0.1406429146706506512047313,
            0.1225552067114784601845191, 0.100942044106287165562814,
            0.0764257302548890565291297, 0.0497145488949697964533349,
            0.0216160135264833103133427
        ];
        /* n = 3 */
        table_xi[3] = [0.0, 0.7745966692414833770358531];
        table_w[3] = [0.8888888888888888888888889, 0.5555555555555555555555556];
        /* n = 5 */
        table_xi[5] = [0.0, 0.5384693101056830910363144, 0.9061798459386639927976269];
        table_w[5] = [
            0.5688888888888888888888889, 0.4786286704993664680412915, 0.236926885056189087514264
        ];
        /* n = 7 */
        table_xi[7] = [
            0.0, 0.4058451513773971669066064, 0.7415311855993944398638648,
            0.9491079123427585245261897
        ];
        table_w[7] = [
            0.417959183673469387755102, 0.3818300505051189449503698,
            0.2797053914892766679014678, 0.1294849661688696932706114
        ];
        /* n = 9 */
        table_xi[9] = [
            0.0, 0.324253423403808929038538, 0.613371432700590397308702,
            0.8360311073266357942994298, 0.9681602395076260898355762
        ];
        table_w[9] = [
            0.3302393550012597631645251, 0.3123470770400028400686304,
            0.2606106964029354623187429, 0.180648160694857404058472, 0.0812743883615744119718922
        ];
        /* n = 11 */
        table_xi[11] = [
            0.0, 0.269543155952344972331532, 0.5190961292068118159257257,
            0.7301520055740493240934163, 0.8870625997680952990751578, 0.978228658146056992803938
        ];
        table_w[11] = [
            0.2729250867779006307144835, 0.2628045445102466621806889,
            0.2331937645919904799185237, 0.1862902109277342514260976,
            0.1255803694649046246346943, 0.0556685671161736664827537
        ];
        /* n = 13 */
        table_xi[13] = [
            0.0, 0.2304583159551347940655281, 0.4484927510364468528779129,
            0.6423493394403402206439846, 0.8015780907333099127942065,
            0.9175983992229779652065478, 0.9841830547185881494728294
        ];
        table_w[13] = [
            0.2325515532308739101945895, 0.2262831802628972384120902,
            0.2078160475368885023125232, 0.1781459807619457382800467,
            0.1388735102197872384636018, 0.0921214998377284479144218,
            0.0404840047653158795200216
        ];
        /* n = 15 */
        table_xi[15] = [
            0.0, 0.2011940939974345223006283, 0.3941513470775633698972074,
            0.5709721726085388475372267, 0.7244177313601700474161861,
            0.8482065834104272162006483, 0.9372733924007059043077589,
            0.9879925180204854284895657
        ];
        table_w[15] = [
            0.2025782419255612728806202, 0.1984314853271115764561183,
            0.1861610000155622110268006, 0.1662692058169939335532009,
            0.1395706779261543144478048, 0.1071592204671719350118695,
            0.0703660474881081247092674, 0.0307532419961172683546284
        ];
        /* n = 17 */
        table_xi[17] = [
            0.0, 0.1784841814958478558506775, 0.3512317634538763152971855,
            0.5126905370864769678862466, 0.6576711592166907658503022,
            0.7815140038968014069252301, 0.8802391537269859021229557,
            0.950675521768767761222717, 0.990575475314417335675434
        ];
        table_w[17] = [
            0.1794464703562065254582656, 0.176562705366992646325271,
            0.1680041021564500445099707, 0.1540457610768102880814316, 0.13513636846852547328632,
            0.1118838471934039710947884, 0.0850361483171791808835354,
            0.0554595293739872011294402, 0.02414830286854793196011
        ];
        a = interval[0];
        b = interval[1];
        //m = Math.ceil(n * 0.5);
        m = (n + 1) >> 1;
        xi = table_xi[n];
        w = table_w[n];
        xm = 0.5 * (b - a);
        xp = 0.5 * (b + a);
        if (n /*& (1 === 1)*/) { // TODO ????? what was this?
            // n odd
            result = w[0] * f(xp);
            for (i = 1; i < m; ++i) {
                result += w[i] * (f(xp + xm * xi[i]) + f(xp - xm * xi[i]));
            }
        }
        else {
            // n even
            result = 0.0;
            for (i = 0; i < m; ++i) {
                result += w[i] * (f(xp + xm * xi[i]) + f(xp - xm * xi[i]));
            }
        }
        return xm * result;
    }
    /**
     * Scale error in Gauss Kronrod quadrature.
     * Internal method used in {@link JXG.Math.Numerics._gaussKronrod}.
     * @private
     */
    static _rescale_error(err, result_abs, result_asc) {
        var scale, min_err, DBL_MIN = 2.2250738585072014e-308, DBL_EPS = 2.2204460492503131e-16;
        err = Math.abs(err);
        if (result_asc !== 0 && err !== 0) {
            scale = Math.pow((200 * err) / result_asc, 1.5);
            if (scale < 1.0) {
                err = result_asc * scale;
            }
            else {
                err = result_asc;
            }
        }
        if (result_abs > DBL_MIN / (50 * DBL_EPS)) {
            min_err = 50 * DBL_EPS * result_abs;
            if (min_err > err) {
                err = min_err;
            }
        }
        return err;
    }
    /**
     * Generic Gauss-Kronrod quadrature algorithm.
     * Internal method used in {@link JXG.Math.Numerics.GaussKronrod15}
     * {@link JXG.Math.Numerics.GaussKronrod21}
     * {@link JXG.Math.Numerics.GaussKronrod31}.
     * Taken from QUADPACK.
     *
     * @param {Array} interval The integration interval, e.g. [0, 3].
     * @param {function} f A function which takes one argument of type number and returns a number.
     * @param {Number} n order of approximation. Actually, n is the length of the array xgk. For example, for the 15-point Kronrod rule, n is equal to 8.
     * @param {Array} xgk Kronrod quadrature abscissae
     * @param {Array} wg Weights of the Gauss rule
     * @param {Array} wgk Weights of the Kronrod rule
     * @param {Object} resultObj Object returning resultObj.abserr, resultObj.resabs, resultObj.resasc.
     * See the library QUADPACK for an explanation.
     *
     * @returns {Number} Integral value of f over interval
     *
     * @private
     */
    static _gaussKronrod(interval, f, n, xgk, wg, wgk, resultObj) {
        var a = interval[0], b = interval[1], up, result, center = 0.5 * (a + b), half_length = 0.5 * (b - a), abs_half_length = Math.abs(half_length), f_center = f(center), result_gauss = 0.0, result_kronrod = f_center * wgk[n - 1], result_abs = Math.abs(result_kronrod), result_asc = 0.0, mean = 0.0, err = 0.0, j, jtw, jtwm1, abscissa, fval1, fval2, fsum, fv1 = [], fv2 = [];
        if (n % 2 === 0) {
            result_gauss = f_center * wg[n / 2 - 1];
        }
        up = Math.floor((n - 1) / 2);
        for (j = 0; j < up; j++) {
            jtw = j * 2 + 1; // in original fortran j=1,2,3 jtw=2,4,6
            abscissa = half_length * xgk[jtw];
            fval1 = f(center - abscissa);
            fval2 = f(center + abscissa);
            fsum = fval1 + fval2;
            fv1[jtw] = fval1;
            fv2[jtw] = fval2;
            result_gauss += wg[j] * fsum;
            result_kronrod += wgk[jtw] * fsum;
            result_abs += wgk[jtw] * (Math.abs(fval1) + Math.abs(fval2));
        }
        up = Math.floor(n / 2);
        for (j = 0; j < up; j++) {
            jtwm1 = j * 2;
            abscissa = half_length * xgk[jtwm1];
            fval1 = f(center - abscissa);
            fval2 = f(center + abscissa);
            fv1[jtwm1] = fval1;
            fv2[jtwm1] = fval2;
            result_kronrod += wgk[jtwm1] * (fval1 + fval2);
            result_abs += wgk[jtwm1] * (Math.abs(fval1) + Math.abs(fval2));
        }
        mean = result_kronrod * 0.5;
        result_asc = wgk[n - 1] * Math.abs(f_center - mean);
        for (j = 0; j < n - 1; j++) {
            result_asc += wgk[j] * (Math.abs(fv1[j] - mean) + Math.abs(fv2[j] - mean));
        }
        // scale by the width of the integration region
        err = (result_kronrod - result_gauss) * half_length;
        result_kronrod *= half_length;
        result_abs *= abs_half_length;
        result_asc *= abs_half_length;
        result = result_kronrod;
        resultObj.abserr = this._rescale_error(err, result_abs, result_asc);
        resultObj.resabs = result_abs;
        resultObj.resasc = result_asc;
        return result;
    }
    /**
     * 15-point Gauss-Kronrod quadrature algorithm, see the library QUADPACK
     * @param {Array} interval The integration interval, e.g. [0, 3].
     * @param {function} f A function which takes one argument of type number and returns a number.
     * @param {Object} resultObj Object returning resultObj.abserr, resultObj.resabs, resultObj.resasc. See the library
     *  QUADPACK for an explanation.
     *
     * @returns {Number} Integral value of f over interval
     *
     * @memberof JXG.Math.Numerics
     */
    static GaussKronrod15(interval, f, resultObj) {
        /* Gauss quadrature weights and kronrod quadrature abscissae and
                weights as evaluated with 80 decimal digit arithmetic by
                L. W. Fullerton, Bell Labs, Nov. 1981. */
        var xgk = 
        /* abscissae of the 15-point kronrod rule */
        [
            0.991455371120812639206854697526329, 0.949107912342758524526189684047851,
            0.864864423359769072789712788640926, 0.741531185599394439863864773280788,
            0.58608723546769113029414483825873, 0.405845151377397166906606412076961,
            0.207784955007898467600689403773245, 0.0
        ], 
        /* xgk[1], xgk[3], ... abscissae of the 7-point gauss rule.
            xgk[0], xgk[2], ... abscissae to optimally extend the 7-point gauss rule */
        wg = 
        /* weights of the 7-point gauss rule */
        [
            0.129484966168869693270611432679082, 0.27970539148927666790146777142378,
            0.381830050505118944950369775488975, 0.417959183673469387755102040816327
        ], wgk = 
        /* weights of the 15-point kronrod rule */
        [
            0.02293532201052922496373200805897, 0.063092092629978553290700663189204,
            0.104790010322250183839876322541518, 0.140653259715525918745189590510238,
            0.16900472663926790282658342659855, 0.190350578064785409913256402421014,
            0.204432940075298892414161999234649, 0.209482141084727828012999174891714
        ];
        return this._gaussKronrod(interval, f, 8, xgk, wg, wgk, resultObj);
    }
    /**
     * 21 point Gauss-Kronrod quadrature algorithm, see the library QUADPACK
     * @param {Array} interval The integration interval, e.g. [0, 3].
     * @param {function} f A function which takes one argument of type number and returns a number.
     * @param {Object} resultObj Object returning resultObj.abserr, resultObj.resabs, resultObj.resasc. See the library
     *  QUADPACK for an explanation.
     *
     * @returns {Number} Integral value of f over interval
     *
     * @memberof JXG.Math.Numerics
     */
    static GaussKronrod21(interval, f, resultObj) {
        /* Gauss quadrature weights and kronrod quadrature abscissae and
                weights as evaluated with 80 decimal digit arithmetic by
                L. W. Fullerton, Bell Labs, Nov. 1981. */
        var xgk = 
        /* abscissae of the 21-point kronrod rule */
        [
            0.995657163025808080735527280689003, 0.973906528517171720077964012084452,
            0.930157491355708226001207180059508, 0.865063366688984510732096688423493,
            0.780817726586416897063717578345042, 0.679409568299024406234327365114874,
            0.562757134668604683339000099272694, 0.433395394129247190799265943165784,
            0.294392862701460198131126603103866, 0.14887433898163121088482600112972, 0.0
        ], 
        /* xgk[1], xgk[3], ... abscissae of the 10-point gauss rule.
            xgk[0], xgk[2], ... abscissae to optimally extend the 10-point gauss rule */
        wg = 
        /* weights of the 10-point gauss rule */
        [
            0.066671344308688137593568809893332, 0.149451349150580593145776339657697,
            0.219086362515982043995534934228163, 0.269266719309996355091226921569469,
            0.295524224714752870173892994651338
        ], wgk = 
        /* weights of the 21-point kronrod rule */
        [
            0.011694638867371874278064396062192, 0.03255816230796472747881897245939,
            0.05475589657435199603138130024458, 0.07503967481091995276704314091619,
            0.093125454583697605535065465083366, 0.109387158802297641899210590325805,
            0.123491976262065851077958109831074, 0.134709217311473325928054001771707,
            0.142775938577060080797094273138717, 0.147739104901338491374841515972068,
            0.149445554002916905664936468389821
        ];
        return this._gaussKronrod(interval, f, 11, xgk, wg, wgk, resultObj);
    }
    /**
     * 31 point Gauss-Kronrod quadrature algorithm, see the library QUADPACK
     * @param {Array} interval The integration interval, e.g. [0, 3].
     * @param {function} f A function which takes one argument of type number and returns a number.
     * @param {Object} resultObj Object returning resultObj.abserr, resultObj.resabs, resultObj.resasc. See the library
     *  QUADPACK for an explanation.
     *
     * @returns {Number} Integral value of f over interval
     *
     * @memberof JXG.Math.Numerics
     */
    static GaussKronrod31(interval, f, resultObj) {
        /* Gauss quadrature weights and kronrod quadrature abscissae and
                weights as evaluated with 80 decimal digit arithmetic by
                L. W. Fullerton, Bell Labs, Nov. 1981. */
        var xgk = 
        /* abscissae of the 21-point kronrod rule */
        [
            0.998002298693397060285172840152271, 0.987992518020485428489565718586613,
            0.967739075679139134257347978784337, 0.937273392400705904307758947710209,
            0.897264532344081900882509656454496, 0.848206583410427216200648320774217,
            0.790418501442465932967649294817947, 0.724417731360170047416186054613938,
            0.650996741297416970533735895313275, 0.570972172608538847537226737253911,
            0.485081863640239680693655740232351, 0.394151347077563369897207370981045,
            0.299180007153168812166780024266389, 0.201194093997434522300628303394596,
            0.101142066918717499027074231447392, 0.0
        ], 
        /* xgk[1], xgk[3], ... abscissae of the 10-point gauss rule.
            xgk[0], xgk[2], ... abscissae to optimally extend the 10-point gauss rule */
        wg = 
        /* weights of the 10-point gauss rule */
        [
            0.030753241996117268354628393577204, 0.070366047488108124709267416450667,
            0.107159220467171935011869546685869, 0.139570677926154314447804794511028,
            0.166269205816993933553200860481209, 0.186161000015562211026800561866423,
            0.198431485327111576456118326443839, 0.202578241925561272880620199967519
        ], wgk = 
        /* weights of the 21-point kronrod rule */
        [
            0.005377479872923348987792051430128, 0.015007947329316122538374763075807,
            0.025460847326715320186874001019653, 0.03534636079137584622203794847836,
            0.04458975132476487660822729937328, 0.05348152469092808726534314723943,
            0.062009567800670640285139230960803, 0.069854121318728258709520077099147,
            0.076849680757720378894432777482659, 0.083080502823133021038289247286104,
            0.088564443056211770647275443693774, 0.093126598170825321225486872747346,
            0.096642726983623678505179907627589, 0.099173598721791959332393173484603,
            0.10076984552387559504494666261757, 0.101330007014791549017374792767493
        ];
        return this._gaussKronrod(interval, f, 16, xgk, wg, wgk, resultObj);
    }
    /**
     * Generate workspace object for {@link JXG.Math.Numerics.Qag}.
     * @param {Array} interval The integration interval, e.g. [0, 3].
     * @param {Number} n Max. limit
     * @returns {Object} Workspace object
     *
     * @private
     * @memberof JXG.Math.Numerics
     */
    static _workspace(interval, n) {
        // return {
        //     limit: n,
        //     size: 0,
        //     nrmax: 0,
        //     i: 0,
        //     alist: [interval[0]],
        //     blist: [interval[1]],
        //     rlist: [0.0],
        //     elist: [0.0],
        //     order: [0],
        //     level: [0],
        //     qpsrt() {
        //         var last = this.size - 1,
        //             limit = this.limit,
        //             errmax,
        //             errmin,
        //             i,
        //             k,
        //             top,
        //             i_nrmax = this.nrmax,
        //             i_maxerr = this.order[i_nrmax];
        //         /* Check whether the list contains more than two error estimates */
        //         if (last < 2) {
        //             this.order[0] = 0;
        //             this.order[1] = 1;
        //             this.i = i_maxerr;
        //             return;
        //         }
        //         errmax = this.elist[i_maxerr];
        //         /* This part of the routine is only executed if, due to a difficult
        //                 integrand, subdivision increased the error estimate. In the normal
        //                 case the insert procedure should start after the nrmax-th largest
        //                 error estimate. */
        //         while (i_nrmax > 0 && errmax > this.elist[this.order[i_nrmax - 1]]) {
        //             this.order[i_nrmax] = this.order[i_nrmax - 1];
        //             i_nrmax--;
        //         }
        //         /* Compute the number of elements in the list to be maintained in
        //                 descending order. This number depends on the number of
        //                 subdivisions still allowed. */
        //         if (last < limit / 2 + 2) {
        //             top = last;
        //         } else {
        //             top = limit - last + 1;
        //         }
        //         /* Insert errmax by traversing the list top-down, starting
        //                 comparison from the element elist(order(i_nrmax+1)). */
        //         i = i_nrmax + 1;
        //         /* The order of the tests in the following line is important to
        //                 prevent a segmentation fault */
        //         while (i < top && errmax < this.elist[this.order[i]]) {
        //             this.order[i - 1] = this.order[i];
        //             i++;
        //         }
        //         this.order[i - 1] = i_maxerr;
        //         /* Insert errmin by traversing the list bottom-up */
        //         errmin = this.elist[last];
        //         k = top - 1;
        //         while (k > i - 2 && errmin >= this.elist[this.order[k]]) {
        //             this.order[k + 1] = this.order[k];
        //             k--;
        //         }
        //         this.order[k + 1] = last;
        //         /* Set i_max and e_max */
        //         i_maxerr = this.order[i_nrmax];
        //         this.i = i_maxerr;
        //         this.nrmax = i_nrmax;
        //     },
        //     set_initial_result(result, error) {
        //         this.size = 1;
        //         this.rlist[0] = result;
        //         this.elist[0] = error;
        //     },
        //     update(a1, b1, area1, error1, a2, b2, area2, error2) {
        //         var i_max = this.i,
        //             i_new = this.size,
        //             new_level = this.level[this.i] + 1;
        //         /* append the newly-created intervals to the list */
        //         if (error2 > error1) {
        //             this.alist[i_max] = a2; /* blist[maxerr] is already == b2 */
        //             this.rlist[i_max] = area2;
        //             this.elist[i_max] = error2;
        //             this.level[i_max] = new_level;
        //             this.alist[i_new] = a1;
        //             this.blist[i_new] = b1;
        //             this.rlist[i_new] = area1;
        //             this.elist[i_new] = error1;
        //             this.level[i_new] = new_level;
        //         } else {
        //             this.blist[i_max] = b1; /* alist[maxerr] is already == a1 */
        //             this.rlist[i_max] = area1;
        //             this.elist[i_max] = error1;
        //             this.level[i_max] = new_level;
        //             this.alist[i_new] = a2;
        //             this.blist[i_new] = b2;
        //             this.rlist[i_new] = area2;
        //             this.elist[i_new] = error2;
        //             this.level[i_new] = new_level;
        //         }
        //         this.size++;
        //         if (new_level > this.maximum_level) {
        //             this.maximum_level = new_level;
        //         }
        //         this.qpsrt();
        //     },
        //     retrieve() {
        //         var i = this.i;
        //         return {
        //             a: this.alist[i],
        //             b: this.blist[i],
        //             r: this.rlist[i],
        //             e: this.elist[i]
        //         };
        //     },
        //     sum_results() {
        //         var nn = this.size,
        //             k,
        //             result_sum = 0.0;
        //         for (k = 0; k < nn; k++) {
        //             result_sum += this.rlist[k];
        //         }
        //         return result_sum;
        //     },
        //     subinterval_too_small(a1, a2, b2) {
        //         var e = 2.2204460492503131e-16,
        //             u = 2.2250738585072014e-308,
        //             tmp = (1 + 100 * e) * (Math.abs(a2) + 1000 * u);
        //         return Math.abs(a1) <= tmp && Math.abs(b2) <= tmp;
        //     },
        // };
    }
    /**
     * Quadrature algorithm qag from QUADPACK.
     * Internal method used in {@link JXG.Math.Numerics.GaussKronrod15}
     * {@link JXG.Math.Numerics.GaussKronrod21}
     * {@link JXG.Math.Numerics.GaussKronrod31}.
     *
     * @param {Array} interval The integration interval, e.g. [0, 3].
     * @param {function} f A function which takes one argument of type number and returns a number.
     * @param {Object} [config] The algorithm setup. Accepted propert are max. recursion limit of type number,
     * and epsrel and epsabs, the relative and absolute required precision of type number. Further,
     * q the internal quadrature sub-algorithm of type function.
     * @param {Number} [config.limit=15]
     * @param {Number} [config.epsrel=0.0000001]
     * @param {Number} [config.epsabs=0.0000001]
     * @param {Number} [config.q=JXG.Math.Numerics.GaussKronrod15]
     * @returns {Number} Integral value of f over interval
     *
     * @example
     * function f(x) {
     *   return x*x;
     * }
     *
     * // calculates integral of <tt>f</tt> from 0 to 2.
     * var area1 = JXG.Math.Numerics.Qag([0, 2], f);
     *
     * // the same with an anonymous function
     * var area2 = JXG.Math.Numerics.Qag([0, 2], function (x) { return x*x; });
     *
     * // use JXG.Math.Numerics.GaussKronrod31 rule as sub-algorithm.
     * var area3 = JXG.Math.Numerics.Quag([0, 2], f,
     *                                   {q: JXG.Math.Numerics.GaussKronrod31});
     * @memberof JXG.Math.Numerics
     */
    static Qag(interval, f, config) {
        this._workspace(interval, 1000); config && Type.isNumber(config.limit) ? config.limit : 15; config && Type.isNumber(config.epsrel) ? config.epsrel : 0.0000001; config && Type.isNumber(config.epsabs) ? config.epsabs : 0.0000001; config && Type.isFunction(config.q) ? config.q : this.GaussKronrod15;
        // TODO: // tbtb - this is a mess
        //
        //         if (limit > ws.limit) {
        //             JXG.warn("iteration limit exceeds available workspace");
        //         }
        //         if (epsabs <= 0 && (epsrel < 50 * JSXMath.eps || epsrel < 0.5e-28)) {
        //             JXG.warn("tolerance cannot be acheived with given epsabs and epsrel");
        //         }
        //         result0 = q.apply(this, [interval, f, resultObj]);
        //         abserr0 = resultObj.abserr;
        //         resabs0 = resultObj.resabs;
        //         resasc0 = resultObj.resasc;
        //         ws.set_initial_result(result0, abserr0);
        //         tolerance = Math.max(epsabs, epsrel * Math.abs(result0));
        //         round_off = 50 * DBL_EPS * resabs0;
        //         if (abserr0 <= round_off && abserr0 > tolerance) {
        //             result = result0;
        //             // abserr = abserr0;
        //             JXG.warn("cannot reach tolerance because of roundoff error on first attempt");
        //             return -Infinity;
        //         }
        //         if ((abserr0 <= tolerance && abserr0 !== resasc0) || abserr0 === 0.0) {
        //             result = result0;
        //             // abserr = abserr0;
        //             return result;
        //         }
        //         if (limit === 1) {
        //             result = result0;
        //             // abserr = abserr0;
        //             JXG.warn("a maximum of one iteration was insufficient");
        //             return -Infinity;
        //         }
        //         area = result0;
        //         errsum = abserr0;
        //         iteration = 1;
        //         do {
        //             area1 = 0;
        //             area2 = 0;
        //             area12 = 0;
        //             error1 = 0;
        //             error2 = 0;
        //             error12 = 0;
        //             /* Bisect the subinterval with the largest error estimate */
        //             wsObj = ws.retrieve();
        //             a_i = wsObj.a;
        //             b_i = wsObj.b;
        //             r_i = wsObj.r;
        //             e_i = wsObj.e;
        //             a1 = a_i;
        //             b1 = 0.5 * (a_i + b_i);
        //             a2 = b1;
        //             b2 = b_i;
        //             area1 = q.apply(this, [[a1, b1], f, resultObj]);
        //             error1 = resultObj.abserr;
        //             // resabs1 = resultObj.resabs;
        //             resasc1 = resultObj.resasc;
        //             area2 = q.apply(this, [[a2, b2], f, resultObj]);
        //             error2 = resultObj.abserr;
        //             // resabs2 = resultObj.resabs;
        //             resasc2 = resultObj.resasc;
        //             area12 = area1 + area2;
        //             error12 = error1 + error2;
        //             errsum += error12 - e_i;
        //             area += area12 - r_i;
        //             if (resasc1 !== error1 && resasc2 !== error2) {
        //                 delta = r_i - area12;
        //                 if (Math.abs(delta) <= 1.0e-5 * Math.abs(area12) && error12 >= 0.99 * e_i) {
        //                     roundoff_type1++;
        //                 }
        //                 if (iteration >= 10 && error12 > e_i) {
        //                     roundoff_type2++;
        //                 }
        //             }
        //             tolerance = Math.max(epsabs, epsrel * Math.abs(area));
        //             if (errsum > tolerance) {
        //                 if (roundoff_type1 >= 6 || roundoff_type2 >= 20) {
        //                     error_type = 2; /* round off error */
        //                 }
        //                 /* set error flag in the case of bad integrand behaviour at
        //                     a point of the integration range */
        //                 if (ws.subinterval_too_small(a1, a2, b2)) {
        //                     error_type = 3;
        //                 }
        //             }
        //             ws.update(a1, b1, area1, error1, a2, b2, area2, error2);
        //             wsObj = ws.retrieve();
        //             a_i = wsObj.a_i;
        //             b_i = wsObj.b_i;
        //             r_i = wsObj.r_i;
        //             e_i = wsObj.e_i;
        //             iteration++;
        //         } while (iteration < limit && !error_type && errsum > tolerance);
        //         result = ws.sum_results();
        //         // abserr = errsum;
        //         /*
        //   if (errsum <= tolerance)
        //     {
        //       return GSL_SUCCESS;
        //     }
        //   else if (error_type == 2)
        //     {
        //       GSL_ERROR ("roundoff error prevents tolerance from being achieved",
        //                  GSL_EROUND);
        //     }
        //   else if (error_type == 3)
        //     {
        //       GSL_ERROR ("bad integrand behavior found in the integration interval",
        //                  GSL_ESING);
        //     }
        //   else if (iteration == limit)
        //     {
        //       GSL_ERROR ("maximum number of subdivisions reached", GSL_EMAXITER);
        //     }
        //   else
        //     {
        //       GSL_ERROR ("could not integrate function", GSL_EFAILED);
        //     }
        // */
        //         return result;
    }
    /**
     * Integral of function f over interval.
     * @param {Array} interval The integration interval, e.g. [0, 3].
     * @param {function} f A function which takes one argument of type number and returns a number.
     * @returns {Number} The value of the integral of f over interval
     * @see JXG.Math.Numerics.NewtonCotes
     * @see JXG.Math.Numerics.Romberg
     * @see JXG.Math.Numerics.Qag
     * @memberof JXG.Math.Numerics
     */
    static I(interval, f) {
        // return this.NewtonCotes(interval, f, {number_of_nodes: 16, integration_type: 'milne'});
        // return this.Romberg(interval, f, {max_iterations: 20, eps: 0.0000001});
        return this.Qag(interval, f, {
            q: this.GaussKronrod15,
            limit: 15,
            epsrel: 0.0000001,
            epsabs: 0.0000001
        });
    }
    /**
     * Newton's method to find roots of a funtion in one variable.
     * @param {function} f We search for a solution of f(x)=0.
     * @param {Number} x initial guess for the root, i.e. start value.
     * @param {Object} context optional object that is treated as "this" in the function body. This is useful if
     * the function is a method of an object and contains a reference to its parent object via "this".
     * @returns {Number} A root of the function f.
     * @memberof JXG.Math.Numerics
     */
    static Newton(f, x, context) {
        var df, i = 0, h = JSXMath.eps, newf = f.apply(context, [x]);
        // nfev = 1;
        // For compatibility
        if (Array.isArray(x)) {
            x = x[0];
        }
        while (i < 50 && Math.abs(newf) > h) {
            df = this.D(f, context)(x);
            // nfev += 2;
            if (Math.abs(df) > h) {
                x -= newf / df;
            }
            else {
                x += Math.random() * 0.2 - 1.0;
            }
            newf = f.apply(context, [x]);
            // nfev += 1;
            i += 1;
        }
        return x;
    }
    /**
     * Abstract method to find roots of univariate functions, which - for the time being -
     * is an alias for {@link JXG.Math.Numerics.chandrupatla}.
     * @param {function} f We search for a solution of f(x)=0.
     * @param {Number|Array} x initial guess for the root, i.e. starting value, or start interval enclosing the root.
     * If x is an interval [a,b], it is required that f(a)f(b) <= 0, otherwise the minimum of f in [a, b] will be returned.
     * If x is a number, the algorithms tries to enclose the root by an interval [a, b] containing x and the root and
     * f(a)f(b) <= 0. If this fails, the algorithm falls back to Newton's method.
     *
     * @param {Object} context optional object that is treated as "this" in the function body. This is useful if
     * the function is a method of an object and contains a reference to its parent object via "this".
     * @returns {Number} A root of the function f.
     *
     * @see JXG.Math.Numerics.chandrupatla
     * @see JXG.Math.Numerics.fzero
     * @see JXG.Math.Numerics.polzeros
     * @see JXG.Math.Numerics.Newton
     * @memberof JXG.Math.Numerics
     */
    static root(f, x, context) {
        //return this.fzero(f, x, context);
        return this.chandrupatla(f, x, context);
    }
    /**
     * Compute an intersection of the curves c1 and c2
     * with a generalized Newton method.
     * We want to find values t1, t2 such that
     * c1(t1) = c2(t2), i.e.
     * <br>
     * (c1_x(t1)-c2_x(t2),c1_y(t1)-c2_y(t2)) = (0,0).
     * <p>
     * We set
     * (e,f) := (c1_x(t1)-c2_x(t2),c1_y(t1)-c2_y(t2))
     * <p>
     * The Jacobian J is defined by
     * <pre>
     * J = (a, b)
     *     (c, d)
     * </pre>
     * where
     * <ul>
     * <li> a = c1_x'(t1)
     * <li> b = -c2_x'(t2)
     * <li> c = c1_y'(t1)
     * <li> d = -c2_y'(t2)
     * </ul>
     * The inverse J^(-1) of J is equal to
     * <pre>
     *  (d, -b)/ (ad-bc)
     *  (-c, a) / (ad-bc)
     * </pre>
     *
     * Then, (t1new, t2new) := (t1,t2) - J^(-1)*(e,f).
     * <p>
     * If the function meetCurveCurve has the properties
     * t1memo and t2memo then these are taken as start values
     * for the Newton algorithm.
     * After stopping of the Newton algorithm the values of t1 and t2 are stored in
     * t1memo and t2memo.
     *
     * @param {JXG.Curve} c1 Curve, Line or Circle
     * @param {JXG.Curve} c2 Curve, Line or Circle
     * @param {Number} t1ini start value for t1
     * @param {Number} t2ini start value for t2
     * @returns {JXG.Coords} intersection point
     * @memberof JXG.Math.Numerics
     */
    static generalizedNewton(c1, c2, t1ini, t2ini) {
        // TODO: tbtb this algorithm doesn't seem to be recursive - it must be missing something
        // if (this.generalizedNewton.t1memo) {
        //     t1 = this.generalizedNewton.t1memo;
        //     t2 = this.generalizedNewton.t2memo;
        // } else {
        //     t1 = t1ini;
        //     t2 = t2ini;
        // }
        // e = c1.X(t1) - c2.X(t2);
        // f = c1.Y(t1) - c2.Y(t2);
        // F = e * e + f * f;
        // D00 = this.D(c1.X, c1);
        // D01 = this.D(c2.X, c2);
        // D10 = this.D(c1.Y, c1);
        // D11 = this.D(c2.Y, c2);
        // while (F > JSXMath.eps && count < 10) {
        //     a = D00(t1);
        //     b = -D01(t2);
        //     c = D10(t1);
        //     d = -D11(t2);
        //     disc = a * d - b * c;
        //     t1 -= (d * e - b * f) / disc;
        //     t2 -= (a * f - c * e) / disc;
        //     e = c1.X(t1) - c2.X(t2);
        //     f = c1.Y(t1) - c2.Y(t2);
        //     F = e * e + f * f;
        //     count += 1;
        // }
        // this.generalizedNewton.t1memo = t1;
        // this.generalizedNewton.t2memo = t2;
        // if (Math.abs(t1) < Math.abs(t2)) {
        //     return [c1.X(t1), c1.Y(t1)];
        // }
        // return [c2.X(t2), c2.Y(t2)];
    }
    /**
     * Returns the Lagrange polynomials for curves with equidistant nodes, see
     * Jean-Paul Berrut, Lloyd N. Trefethen: Barycentric Lagrange Interpolation,
     * SIAM Review, Vol 46, No 3, (2004) 501-517.
     * The graph of the parametric curve [x(t),y(t)] runs through the given points.
     * @param {Array} p Array of JXG.Points
     * @returns {Array} An array consisting of two functions x(t), y(t) which define a parametric curve
     * f(t) = (x(t), y(t)), a number x1 (which equals 0) and a function x2 defining the curve's domain.
     * That means the curve is defined between x1 and x2(). x2 returns the (length of array p minus one).
     * @memberof JXG.Math.Numerics
     *
     * @example
     * var p = [];
     *
     * p[0] = board.create('point', [0, -2], {size:2, name: 'C(a)'});
     * p[1] = board.create('point', [-1.5, 5], {size:2, name: ''});
     * p[2] = board.create('point', [1, 4], {size:2, name: ''});
     * p[3] = board.create('point', [3, 3], {size:2, name: 'C(b)'});
     *
     * // Curve
     * var fg = JXG.Math.Numerics.Neville(p);
     * var graph = board.create('curve', fg, {strokeWidth:3, strokeOpacity:0.5});
     *
     * </pre><div id="JXG88a8b3a8-6561-44f5-a678-76bca13fd484" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG88a8b3a8-6561-44f5-a678-76bca13fd484',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var p = [];
     *
     *     p[0] = board.create('point', [0, -2], {size:2, name: 'C(a)'});
     *     p[1] = board.create('point', [-1.5, 5], {size:2, name: ''});
     *     p[2] = board.create('point', [1, 4], {size:2, name: ''});
     *     p[3] = board.create('point', [3, 3], {size:2, name: 'C(b)'});
     *
     *     // Curve
     *     var fg = JXG.Math.Numerics.Neville(p);
     *     var graph = board.create('curve', fg, {strokeWidth:3, strokeOpacity:0.5});
     *
     *     })();
     *
     * </script><pre>
     *
     */
    static Neville(p) {
        var w = [], xfct, yfct;
        /** @ignore */
        let makeFct = function (fun) {
            return function (t, suspendedUpdate) {
                var i, d, s, bin = JSXMath.binomial, len = p.length, len1 = len - 1, num = 0.0, denom = 0.0;
                if (!suspendedUpdate) {
                    s = 1;
                    for (i = 0; i < len; i++) {
                        w[i] = bin(len1, i) * s;
                        s *= -1;
                    }
                }
                d = t;
                for (i = 0; i < len; i++) {
                    if (d === 0) {
                        return p[i][fun]();
                    }
                    s = w[i] / d;
                    d -= 1;
                    num += p[i][fun]() * s;
                    denom += s;
                }
                return num / denom;
            };
        };
        xfct = makeFct("X");
        yfct = makeFct("Y");
        return [
            xfct,
            yfct,
            0,
            function () {
                return p.length - 1;
            }
        ];
    }
    /**
     * Calculates second derivatives at the given knots.
     * @param {Array} x x values of knots
     * @param {Array} y y values of knots
     * @returns {Array} Second derivatives of the interpolated function at the knots.
     * @see JXG.Math.Numerics.splineEval
     * @memberof JXG.Math.Numerics
     */
    static splineDef(x, y) {
        var pair, i, l, n = Math.min(x.length, y.length), diag = [], z = [], data = [], dx = [], delta = [], F = [];
        if (n === 2) {
            return [0, 0];
        }
        for (i = 0; i < n; i++) {
            pair = { X: x[i], Y: y[i] };
            data.push(pair);
        }
        data.sort(function (a, b) {
            return a.X - b.X;
        });
        for (i = 0; i < n; i++) {
            x[i] = data[i].X;
            y[i] = data[i].Y;
        }
        for (i = 0; i < n - 1; i++) {
            dx.push(x[i + 1] - x[i]);
        }
        for (i = 0; i < n - 2; i++) {
            delta.push((6 * (y[i + 2] - y[i + 1])) / dx[i + 1] - (6 * (y[i + 1] - y[i])) / dx[i]);
        }
        // ForwardSolve
        diag.push(2 * (dx[0] + dx[1]));
        z.push(delta[0]);
        for (i = 0; i < n - 3; i++) {
            l = dx[i + 1] / diag[i];
            diag.push(2 * (dx[i + 1] + dx[i + 2]) - l * dx[i + 1]);
            z.push(delta[i + 1] - l * z[i]);
        }
        // BackwardSolve
        F[n - 3] = z[n - 3] / diag[n - 3];
        for (i = n - 4; i >= 0; i--) {
            F[i] = (z[i] - dx[i + 1] * F[i + 1]) / diag[i];
        }
        // Generate f''-Vector
        for (i = n - 3; i >= 0; i--) {
            F[i + 1] = F[i];
        }
        // natural cubic spline
        F[0] = 0;
        F[n - 1] = 0;
        return F;
    }
    /**
     * Evaluate points on spline.
     * @param {Number|Array} x0 A single float value or an array of values to evaluate
     * @param {Array} x x values of knots
     * @param {Array} y y values of knots
     * @param {Array} F Second derivatives at knots, calculated by {@link JXG.Math.Numerics.splineDef}
     * @see JXG.Math.Numerics.splineDef
     * @returns {Number|Array} A single value or an array, depending on what is given as x0.
     * @memberof JXG.Math.Numerics
     */
    static splineEval(x0, x, y, F) {
        var i, j, a, b, c, d, x_, n = Math.min(x.length, y.length), l = 1, asArray = false, y0 = [];
        // number of points to be evaluated
        if (Array.isArray(x0)) {
            l = x0.length;
            asArray = true;
        }
        else {
            x0 = [x0];
        }
        for (i = 0; i < l; i++) {
            // is x0 in defining interval?
            if (x0[i] < x[0] || x[i] > x[n - 1]) {
                return NaN;
            }
            // determine part of spline in which x0 lies
            for (j = 1; j < n; j++) {
                if (x0[i] <= x[j]) {
                    break;
                }
            }
            j -= 1;
            // we're now in the j-th partial interval, i.e. x[j] < x0[i] <= x[j+1];
            // determine the coefficients of the polynomial in this interval
            a = y[j];
            b =
                (y[j + 1] - y[j]) / (x[j + 1] - x[j]) -
                    ((x[j + 1] - x[j]) / 6) * (F[j + 1] + 2 * F[j]);
            c = F[j] / 2;
            d = (F[j + 1] - F[j]) / (6 * (x[j + 1] - x[j]));
            // evaluate x0[i]
            x_ = x0[i] - x[j];
            //y0.push(a + b*x_ + c*x_*x_ + d*x_*x_*x_);
            y0.push(a + (b + (c + d * x_) * x_) * x_);
        }
        if (asArray) {
            return y0;
        }
        return y0[0];
    }
    /**
     * Generate a string containing the function term of a polynomial.
     * @param {Array} coeffs Coefficients of the polynomial. The position i belongs to x^i.
     * @param {Number} deg Degree of the polynomial
     * @param {String} varname Name of the variable (usually 'x')
     * @param {Number} prec Precision
     * @returns {String} A string containing the function term of the polynomial.
     * @memberof JXG.Math.Numerics
     */
    static generatePolynomialTerm(coeffs, deg, varname, prec) {
        var i, t = [];
        for (i = deg; i >= 0; i--) {
            Type.concat(t, ["(", coeffs[i].toPrecision(prec), ")"]);
            if (i > 1) {
                Type.concat(t, ["*", varname, "<sup>", i, "<", "/sup> + "]);
            }
            else if (i === 1) {
                Type.concat(t, ["*", varname, " + "]);
            }
        }
        return t.join("");
    }
    /**
     * Computes the polynomial through a given set of coordinates in Lagrange form.
     * Returns the Lagrange polynomials, see
     * Jean-Paul Berrut, Lloyd N. Trefethen: Barycentric Lagrange Interpolation,
     * SIAM Review, Vol 46, No 3, (2004) 501-517.
     * <p>
     * It possesses the method getTerm() which returns the string containing the function term of the polynomial and
     * the method getCoefficients() which returns an array containing the coefficients of the polynomial.
     * @param {Array} p Array of JXG.Points
     * @returns {function} A function of one parameter which returns the value of the polynomial, whose graph runs through the given points.
     * @memberof JXG.Math.Numerics
     *
     * @example
     * var p = [];
     * p[0] = board.create('point', [-1,2], {size:4});
     * p[1] = board.create('point', [0,3], {size:4});
     * p[2] = board.create('point', [1,1], {size:4});
     * p[3] = board.create('point', [3,-1], {size:4});
     * var f = JXG.Math.Numerics.lagrangePolynomial(p);
     * var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
     *
     * </pre><div id="JXGc058aa6b-74d4-41e1-af94-df06169a2d89" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGc058aa6b-74d4-41e1-af94-df06169a2d89',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var p = [];
     *     p[0] = board.create('point', [-1,2], {size:4});
     *     p[1] = board.create('point', [0,3], {size:4});
     *     p[2] = board.create('point', [1,1], {size:4});
     *     p[3] = board.create('point', [3,-1], {size:4});
     *     var f = JXG.Math.Numerics.lagrangePolynomial(p);
     *     var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
     *
     *     })();
     *
     * </script><pre>
     *
     * @example
     * var points = [];
     * points[0] = board.create('point', [-1,2], {size:4});
     * points[1] = board.create('point', [0, 0], {size:4});
     * points[2] = board.create('point', [2, 1], {size:4});
     *
     * var f = JXG.Math.Numerics.lagrangePolynomial(points);
     * var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
     * var txt = board.create('text', [-3, -4,  () => f.getTerm(2, 't', ' * ')], {fontSize: 16});
     * var txt2 = board.create('text', [-3, -6,  () => f.getCoefficients()], {fontSize: 12});
     *
     * </pre><div id="JXG73fdaf12-e257-4374-b488-ae063e4eecbb" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG73fdaf12-e257-4374-b488-ae063e4eecbb',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var points = [];
     *     points[0] = board.create('point', [-1,2], {size:4});
     *     points[1] = board.create('point', [0, 0], {size:4});
     *     points[2] = board.create('point', [2, 1], {size:4});
     *
     *     var f = JXG.Math.Numerics.lagrangePolynomial(points);
     *     var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
     *     var txt = board.create('text', [-3, -4,  () => f.getTerm(2, 't', ' * ')], {fontSize: 16});
     *     var txt2 = board.create('text', [-3, -6,  () => f.getCoefficients()], {fontSize: 12});
     *
     *     })();
     *
     * </script><pre>
     *
     */
    // static lagrangePolynomial(p) {
    //     var w :number[]= [],
    //         that = this
    //     let fct = function (x, suspendedUpdate) {
    //         var i, // j,
    //             k,
    //             xi,
    //             s, //M,
    //             len = p.length,
    //             num = 0,
    //             denom = 0;
    //         if (!suspendedUpdate) {
    //             for (i = 0; i < len; i++) {
    //                 w[i] = 1.0;
    //                 xi = p[i].X();
    //                 for (k = 0; k < len; k++) {
    //                     if (k !== i) {
    //                         w[i] *= xi - p[k].X();
    //                     }
    //                 }
    //                 w[i] = 1 / w[i];
    //             }
    //             // M = [];
    //             // for (k = 0; k < len; k++) {
    //             //     M.push([1]);
    //             // }
    //         }
    //         for (i = 0; i < len; i++) {
    //             xi = p[i].X();
    //             if (x === xi) {
    //                 return p[i].Y();
    //             }
    //             s = w[i] / (x - xi);
    //             denom += s;
    //             num += s * p[i].Y();
    //         }
    //         return num / denom;
    //     };
    //     /**
    //      * Get the term of the Lagrange polynomial as string.
    //      * Calls {@link JXG.Math.Numerics#lagrangePolynomialTerm}.
    //      *
    //      * @name JXG.Math.Numerics.lagrangePolynomial#getTerm
    //      * @param {Number} digits Number of digits of the coefficients
    //      * @param {String} param Variable name
    //      * @param {String} dot Dot symbol
    //      * @returns {String} containing the term of Lagrange polynomial as string.
    //      * @see JXG.Math.Numerics.lagrangePolynomialTerm
    //      * @example
    //      * var points = [];
    //      * points[0] = board.create('point', [-1,2], {size:4});
    //      * points[1] = board.create('point', [0, 0], {size:4});
    //      * points[2] = board.create('point', [2, 1], {size:4});
    //      *
    //      * var f = JXG.Math.Numerics.lagrangePolynomial(points);
    //      * var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
    //      * var txt = board.create('text', [-3, -4,  () => f.getTerm(2, 't', ' * ')], {fontSize: 16});
    //      *
    //      * </pre><div id="JXG73fdaf12-e257-4374-b488-ae063e4eeccf" class="jxgbox" style="width: 300px; height: 300px;"></div>
    //      * <script type="text/javascript">
    //      *     (function() {
    //      *         var board = JXG.JSXGraph.initBoard('JXG73fdaf12-e257-4374-b488-ae063e4eeccf',
    //      *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
    //      *     var points = [];
    //      *     points[0] = board.create('point', [-1,2], {size:4});
    //      *     points[1] = board.create('point', [0, 0], {size:4});
    //      *     points[2] = board.create('point', [2, 1], {size:4});
    //      *
    //      *     var f = JXG.Math.Numerics.lagrangePolynomial(points);
    //      *     var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
    //      *     var txt = board.create('text', [-3, -4,  () => f.getTerm(2, 't', ' * ')], {fontSize: 16});
    //      *
    //      *     })();
    //      *
    //      * </script><pre>
    //      *
    //      */
    //     fct.getTerm = function (digits, param, dot) {
    //         return that.lagrangePolynomialTerm(p, digits, param, dot)();
    //     };
    //     /**
    //      * Get the coefficients of the Lagrange polynomial as array. The leading
    //      * coefficient is at position 0.
    //      * Calls {@link JXG.Math.Numerics#lagrangePolynomialCoefficients}.
    //      *
    //      * @name JXG.Math.Numerics.lagrangePolynomial#getCoefficients
    //      * @returns {Array} containing the coefficients of the Lagrange polynomial.
    //      * @see JXG.Math.Numerics.lagrangePolynomial.getTerm
    //      * @see JXG.Math.Numerics.lagrangePolynomialTerm
    //      * @see JXG.Math.Numerics.lagrangePolynomialCoefficients
    //      * @example
    //      * var points = [];
    //      * points[0] = board.create('point', [-1,2], {size:4});
    //      * points[1] = board.create('point', [0, 0], {size:4});
    //      * points[2] = board.create('point', [2, 1], {size:4});
    //      *
    //      * var f = JXG.Math.Numerics.lagrangePolynomial(points);
    //      * var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
    //      * var txt = board.create('text', [1, -4,  () => f.getCoefficients()], {fontSize: 10});
    //      *
    //      * </pre><div id="JXG52a883a5-2e0c-4caf-8f84-8650c173c365" class="jxgbox" style="width: 300px; height: 300px;"></div>
    //      * <script type="text/javascript">
    //      *     (function() {
    //      *         var board = JXG.JSXGraph.initBoard('JXG52a883a5-2e0c-4caf-8f84-8650c173c365',
    //      *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
    //      *     var points = [];
    //      *     points[0] = board.create('point', [-1,2], {size:4});
    //      *     points[1] = board.create('point', [0, 0], {size:4});
    //      *     points[2] = board.create('point', [2, 1], {size:4});
    //      *
    //      *     var f = JXG.Math.Numerics.lagrangePolynomial(points);
    //      *     var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
    //      *     var txt = board.create('text', [1, -4,  () => f.getCoefficients()], {fontSize: 10});
    //      *
    //      *     })();
    //      *
    //      * </script><pre>
    //      *
    //      */
    //     fct.getCoefficients = function () {
    //         return that.lagrangePolynomialCoefficients(p)();
    //     };
    //     return fct;
    // }
    /**
     * Determine the Lagrange polynomial through an array of points and
     * return the term of the polynomial as string.
     *
     * @param {Array} points Array of JXG.Points
     * @param {Number} digits Number of decimal digits of the coefficients
     * @param {String} param Name of the parameter. Default: 'x'.
     * @param {String} dot Multiplication symbol. Default: ' * '.
     * @returns {Function} returning the Lagrange polynomial term through
     *    the supplied points as string
     * @memberof JXG.Math.Numerics
     *
     * @example
     * var points = [];
     * points[0] = board.create('point', [-1,2], {size:4});
     * points[1] = board.create('point', [0, 0], {size:4});
     * points[2] = board.create('point', [2, 1], {size:4});
     *
     * var f = JXG.Math.Numerics.lagrangePolynomial(points);
     * var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
     *
     * var f_txt = JXG.Math.Numerics.lagrangePolynomialTerm(points, 2, 't', ' * ');
     * var txt = board.create('text', [-3, -4, f_txt], {fontSize: 16});
     *
     * </pre><div id="JXGd45e9e96-7526-486d-aa43-e1178d5f2baa" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGd45e9e96-7526-486d-aa43-e1178d5f2baa',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var points = [];
     *     points[0] = board.create('point', [-1,2], {size:4});
     *     points[1] = board.create('point', [0, 0], {size:4});
     *     points[2] = board.create('point', [2, 1], {size:4});
     *
     *     var f = JXG.Math.Numerics.lagrangePolynomial(points);
     *     var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
     *
     *     var f_txt = JXG.Math.Numerics.lagrangePolynomialTerm(points, 2, 't', ' * ');
     *     var txt = board.create('text', [-3, -4, f_txt], {fontSize: 16});
     *
     *     })();
     *
     * </script><pre>
     *
     */
    static lagrangePolynomialTerm(points, digits, param, dot) {
        var that = this;
        return function () {
            var len = points.length, coeffs = [], isLeading = true, n, t, j, c;
            param = param || "x";
            if (dot === undefined) {
                dot = " * ";
            }
            n = len - 1; // (Max) degree of the polynomial
            coeffs = that.lagrangePolynomialCoefficients(points)();
            t = "";
            for (j = 0; j < coeffs.length; j++) {
                c = coeffs[j];
                if (Math.abs(c) < JSXMath.eps) {
                    continue;
                }
                if (Type.exists(digits)) {
                    c = Type._round10(c, -digits);
                }
                if (isLeading) {
                    t += c > 0 ? c : "-" + -c;
                    isLeading = false;
                }
                else {
                    t += c > 0 ? " + " + c : " - " + -c;
                }
                if (n - j > 1) {
                    t += dot + param + "^" + (n - j);
                }
                else if (n - j === 1) {
                    t += dot + param;
                }
            }
            return t; // board.jc.manipulate('f = map(x) -> ' + t + ';');
        };
    }
    /**
     * Determine the Lagrange polynomial through an array of points and
     * return the coefficients of the polynomial as array.
     * The leading coefficient is at position 0.
     *
     * @param {Array} points Array of JXG.Points
     * @returns {Function} returning the coefficients of the Lagrange polynomial through
     *    the supplied points.
     * @memberof JXG.Math.Numerics
     *
     * @example
     * var points = [];
     * points[0] = board.create('point', [-1,2], {size:4});
     * points[1] = board.create('point', [0, 0], {size:4});
     * points[2] = board.create('point', [2, 1], {size:4});
     *
     * var f = JXG.Math.Numerics.lagrangePolynomial(points);
     * var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
     *
     * var f_arr = JXG.Math.Numerics.lagrangePolynomialCoefficients(points);
     * var txt = board.create('text', [1, -4, f_arr], {fontSize: 10});
     *
     * </pre><div id="JXG1778f0d1-a420-473f-99e8-1755ef4be97e" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG1778f0d1-a420-473f-99e8-1755ef4be97e',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var points = [];
     *     points[0] = board.create('point', [-1,2], {size:4});
     *     points[1] = board.create('point', [0, 0], {size:4});
     *     points[2] = board.create('point', [2, 1], {size:4});
     *
     *     var f = JXG.Math.Numerics.lagrangePolynomial(points);
     *     var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
     *
     *     var f_arr = JXG.Math.Numerics.lagrangePolynomialCoefficients(points);
     *     var txt = board.create('text', [1, -4, f_arr], {fontSize: 10});
     *
     *     })();
     *
     * </script><pre>
     *
     */
    static lagrangePolynomialCoefficients(points) {
        return function () {
            var len = points.length, zeroes = [], coeffs = [], coeffs_sum = [], i, j, c, p;
            // n = len - 1; // (Max) degree of the polynomial
            for (j = 0; j < len; j++) {
                coeffs_sum[j] = 0;
            }
            for (i = 0; i < len; i++) {
                c = points[i].Y();
                p = points[i].X();
                zeroes = [];
                for (j = 0; j < len; j++) {
                    if (j !== i) {
                        c /= p - points[j].X();
                        zeroes.push(points[j].X());
                    }
                }
                coeffs = [1].concat(JSXMath.Vieta(zeroes));
                for (j = 0; j < coeffs.length; j++) {
                    coeffs_sum[j] += (j % 2 === 1 ? -1 : 1) * coeffs[j] * c;
                }
            }
            return coeffs_sum;
        };
    }
    /**
     * Determine the coefficients of a cardinal spline polynom, See
     * https://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections
     * @param  {Number} x1 point 1
     * @param  {Number} x2 point 2
     * @param  {Number} t1 tangent slope 1
     * @param  {Number} t2 tangent slope 2
     * @return {Array}    coefficents array c for the polynomial t maps to
     * c[0] + c[1]*t + c[2]*t*t + c[3]*t*t*t
     */
    static _initCubicPoly(x1, x2, t1, t2) {
        return [x1, t1, -3 * x1 + 3 * x2 - 2 * t1 - t2, 2 * x1 - 2 * x2 + t1 + t2];
    }
    /**
     * Computes the cubic cardinal spline curve through a given set of points. The curve
     * is uniformly parametrized.
     * Two artificial control points at the beginning and the end are added.
     *
     * The implementation (especially the centripetal parametrization) is from
     * https://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections .
     * @param {Array} points Array consisting of JXG.Points.
     * @param {Number|Function} tau The tension parameter, either a constant number or a function returning a number. This number is between 0 and 1.
     * tau=1/2 give Catmull-Rom splines.
     * @param {String} type (Optional) parameter which allows to choose between "uniform" (default) and
     * "centripetal" parameterization. Thus the two possible values are "uniform" or "centripetal".
     * @returns {Array} An Array consisting of four components: Two functions each of one parameter t
     * which return the x resp. y coordinates of the Catmull-Rom-spline curve in t, a zero value,
     * and a function simply returning the length of the points array
     * minus three.
     * @memberof JXG.Math.Numerics
     */
    static CardinalSpline(points, tau_param, type) {
        var p, coeffs = [], makeFct, tau, _tau, that = this;
        if (Type.isFunction(tau_param)) {
            _tau = tau_param;
        }
        else {
            _tau = function () {
                return tau_param;
            };
        }
        if (type === undefined) {
            type = "uniform";
        }
        /** @ignore */
        makeFct = function (which) {
            return function (t, suspendedUpdate) {
                var s, c, 
                // control point at the beginning and at the end
                first, last, t1, t2, dt0, dt1, dt2, 
                // dx, dy,
                len;
                if (points.length < 2) {
                    return NaN;
                }
                if (!suspendedUpdate) {
                    tau = _tau();
                    // New point list p: [first, points ..., last]
                    first = {
                        X() {
                            return 2 * points[0].X() - points[1].X();
                        },
                        Y() {
                            return 2 * points[0].Y() - points[1].Y();
                        },
                        Dist(p) {
                            var dx = this.X() - p.X(), dy = this.Y() - p.Y();
                            return JSXMath.hypot(dx, dy);
                        },
                    };
                    last = {
                        X() {
                            return (2 * points[points.length - 1].X() -
                                points[points.length - 2].X());
                        },
                        Y() {
                            return (2 * points[points.length - 1].Y() -
                                points[points.length - 2].Y());
                        },
                        Dist(p) {
                            var dx = this.X() - p.X(), dy = this.Y() - p.Y();
                            return JSXMath.hypot(dx, dy);
                        },
                    };
                    p = [first].concat(points, [last]);
                    len = p.length;
                    coeffs[which] = [];
                    for (s = 0; s < len - 3; s++) {
                        if (type === "centripetal") {
                            // The order is important, since p[0].coords === undefined
                            dt0 = p[s].Dist(p[s + 1]);
                            dt1 = p[s + 2].Dist(p[s + 1]);
                            dt2 = p[s + 3].Dist(p[s + 2]);
                            dt0 = Math.sqrt(dt0);
                            dt1 = Math.sqrt(dt1);
                            dt2 = Math.sqrt(dt2);
                            if (dt1 < JSXMath.eps) {
                                dt1 = 1.0;
                            }
                            if (dt0 < JSXMath.eps) {
                                dt0 = dt1;
                            }
                            if (dt2 < JSXMath.eps) {
                                dt2 = dt1;
                            }
                            t1 =
                                (p[s + 1][which]() - p[s][which]()) / dt0 -
                                    (p[s + 2][which]() - p[s][which]()) / (dt1 + dt0) +
                                    (p[s + 2][which]() - p[s + 1][which]()) / dt1;
                            t2 =
                                (p[s + 2][which]() - p[s + 1][which]()) / dt1 -
                                    (p[s + 3][which]() - p[s + 1][which]()) / (dt2 + dt1) +
                                    (p[s + 3][which]() - p[s + 2][which]()) / dt2;
                            t1 *= dt1;
                            t2 *= dt1;
                            coeffs[which][s] = that._initCubicPoly(p[s + 1][which](), p[s + 2][which](), tau * t1, tau * t2);
                        }
                        else {
                            coeffs[which][s] = that._initCubicPoly(p[s + 1][which](), p[s + 2][which](), tau * (p[s + 2][which]() - p[s][which]()), tau * (p[s + 3][which]() - p[s + 1][which]()));
                        }
                    }
                }
                if (isNaN(t)) {
                    return NaN;
                }
                len = points.length;
                // This is necessary for our advanced plotting algorithm:
                if (t <= 0.0) {
                    return points[0][which]();
                }
                if (t >= len) {
                    return points[len - 1][which]();
                }
                s = Math.floor(t);
                if (s === t) {
                    return points[s][which]();
                }
                t -= s;
                c = coeffs[which][s];
                if (c === undefined) {
                    return NaN;
                }
                return ((c[3] * t + c[2]) * t + c[1]) * t + c[0];
            };
        };
        return [
            makeFct("X"),
            makeFct("Y"),
            0,
            function () {
                return points.length - 1;
            }
        ];
    }
    /**
     * Computes the cubic Catmull-Rom spline curve through a given set of points. The curve
     * is uniformly parametrized. The curve is the cardinal spline curve for tau=0.5.
     * Two artificial control points at the beginning and the end are added.
     * @param {Array} points Array consisting of JXG.Points.
     * @param {String} type (Optional) parameter which allows to choose between "uniform" (default) and
     * "centripetal" parameterization. Thus the two possible values are "uniform" or "centripetal".
     * @returns {Array} An Array consisting of four components: Two functions each of one parameter t
     * which return the x resp. y coordinates of the Catmull-Rom-spline curve in t, a zero value, and a function simply
     * returning the length of the points array minus three.
     * @memberof JXG.Math.Numerics
     */
    static CatmullRomSpline(points, type) {
        return this.CardinalSpline(points, 0.5, type);
    }
    /**
     * Computes the regression polynomial of a given degree through a given set of coordinates.
     * Returns the regression polynomial function.
     * @param {Number|function|Slider} degree number, function or slider.
     * Either
     * @param {Array} dataX Array containing either the x-coordinates of the data set or both coordinates in
     * an array of {@link JXG.Point}s or {@link JXG.Coords}.
     * In the latter case, the <tt>dataY</tt> parameter will be ignored.
     * @param {Array} dataY Array containing the y-coordinates of the data set,
     * @returns {function} A function of one parameter which returns the value of the regression polynomial of the given degree.
     * It possesses the method getTerm() which returns the string containing the function term of the polynomial.
     * The function returned will throw an exception, if the data set is malformed.
     * @memberof JXG.Math.Numerics
     */
    //TODO:  Really?  use a slider in Numbeics.regressionPolynomial ?!?
    // static regressionPolynomial(degree:number|Function /*|Slider*/, dataX:number[], dataY:number[]):Function {
    //     var coeffs, deg, dX, dY, inputType, fct,
    //         term = "";
    //     // Slider
    //     if (Type.isPoint(degree) && Type.isFunction(degree.Value)) {
    //         /** @ignore */
    //         deg = function () {
    //             return degree.Value();
    //         };
    //         // function
    //     } else if (Type.isFunction(degree)) {
    //         deg = degree;
    //         // number
    //     } else if (Type.isNumber(degree)) {
    //         /** @ignore */
    //         deg = function () {
    //             return degree;
    //         };
    //     } else {
    //         throw new Error(
    //             "JSXGraph: Can't create regressionPolynomial from degree of type'" +
    //             typeof degree +
    //             "'."
    //         );
    //     }
    //     // Parameters degree, dataX, dataY
    //     if (arguments.length === 3 && Array.isArray(dataX) && Array.isArray(dataY)) {
    //         inputType = 0;
    //         // Parameters degree, point array
    //     } else if (
    //         arguments.length === 2 &&
    //         Array.isArray(dataX) &&
    //         dataX.length > 0 &&
    //         Type.isPoint(dataX[0])
    //     ) {
    //         inputType = 1;
    //     } else if (
    //         arguments.length === 2 &&
    //         Array.isArray(dataX) &&
    //         dataX.length > 0 &&
    //         dataX[0].usrCoords &&
    //         dataX[0].scrCoords
    //     ) {
    //         inputType = 2;
    //     } else {
    //         throw new Error("JSXGraph: Can't create regressionPolynomial. Wrong parameters.");
    //     }
    //     /** @ignore */
    //     fct = function (x, suspendedUpdate) {
    //         var i, j,
    //             M, MT, y, B, c, s, d,
    //             // input data
    //             len = dataX.length;
    //         d = Math.floor(deg());
    //         if (!suspendedUpdate) {
    //             // point list as input
    //             if (inputType === 1) {
    //                 dX = [];
    //                 dY = [];
    //                 for (i = 0; i < len; i++) {
    //                     dX[i] = dataX[i].X();
    //                     dY[i] = dataX[i].Y();
    //                 }
    //             }
    //             if (inputType === 2) {
    //                 dX = [];
    //                 dY = [];
    //                 for (i = 0; i < len; i++) {
    //                     dX[i] = dataX[i].usrCoords[1];
    //                     dY[i] = dataX[i].usrCoords[2];
    //                 }
    //             }
    //             // check for functions
    //             if (inputType === 0) {
    //                 dX = [];
    //                 dY = [];
    //                 for (i = 0; i < len; i++) {
    //                     if (Type.isFunction(dataX[i])) {
    //                         dX.push(dataX[i]());
    //                     } else {
    //                         dX.push(dataX[i]);
    //                     }
    //                     if (Type.isFunction(dataY[i])) {
    //                         dY.push(dataY[i]());
    //                     } else {
    //                         dY.push(dataY[i]);
    //                     }
    //                 }
    //             }
    //             M = [];
    //             for (j = 0; j < len; j++) {
    //                 M.push([1]);
    //             }
    //             for (i = 1; i <= d; i++) {
    //                 for (j = 0; j < len; j++) {
    //                     M[j][i] = M[j][i - 1] * dX[j];
    //                 }
    //             }
    //             y = dY;
    //             MT = JSXMath.transpose(M);
    //             B = JSXMath.matMatMult(MT, M);
    //             c = JSXMath.matVecMult(MT, y);
    //             coeffs = Numerics.Gauss(B, c);
    //             term = Numerics.generatePolynomialTerm(coeffs, d, "x", 3);
    //         }
    //         // Horner's scheme to evaluate polynomial
    //         s = coeffs[d];
    //         for (i = d - 1; i >= 0; i--) {
    //             s = s * x + coeffs[i];
    //         }
    //         return s;
    //     };
    //     /** @ignore */
    //     fct.getTerm = function () {
    //         return term;
    //     };
    //     return fct;
    // }
    /**
     * Computes the cubic Bezier curve through a given set of points.
     * @param {Array} points Array consisting of 3*k+1 {@link JXG.Points}.
     * The points at position k with k mod 3 = 0 are the data points,
     * points at position k with k mod 3 = 1 or 2 are the control points.
     * @returns {Array} An array consisting of two functions of one parameter t which return the
     * x resp. y coordinates of the Bezier curve in t, one zero value, and a third function accepting
     * no parameters and returning one third of the length of the points.
     * @memberof JXG.Math.Numerics
     */
    static bezier(points) {
        var len, flen, 
        /** @ignore */
        makeFct = function (which) {
            return function (t, suspendedUpdate) {
                var z = Math.floor(t) * 3, t0 = t % 1, t1 = 1 - t0;
                if (!suspendedUpdate) {
                    flen = 3 * Math.floor((points.length - 1) / 3);
                    len = Math.floor(flen / 3);
                }
                if (t < 0) {
                    return points[0][which]();
                }
                if (t >= len) {
                    return points[flen][which]();
                }
                if (isNaN(t)) {
                    return NaN;
                }
                return (t1 * t1 * (t1 * points[z][which]() + 3 * t0 * points[z + 1][which]()) +
                    (3 * t1 * points[z + 2][which]() + t0 * points[z + 3][which]()) *
                        t0 *
                        t0);
            };
        };
        return [
            makeFct("X"),
            makeFct("Y"),
            0,
            function () {
                return Math.floor(points.length / 3);
            }
        ];
    }
    /**
     * Computes the B-spline curve of order k (order = degree+1) through a given set of points.
     * @param {Array} points Array consisting of JXG.Points.
     * @param {Number} order Order of the B-spline curve.
     * @returns {Array} An Array consisting of four components: Two functions each of one parameter t
     * which return the x resp. y coordinates of the B-spline curve in t, a zero value, and a function simply
     * returning the length of the points array minus one.
     * @memberof JXG.Math.Numerics
     */
    static bspline(points, order) {
        var knots, _knotVector = function (n, k) {
            var j, kn = [];
            for (j = 0; j < n + k + 1; j++) {
                if (j < k) {
                    kn[j] = 0.0;
                }
                else if (j <= n) {
                    kn[j] = j - k + 1;
                }
                else {
                    kn[j] = n - k + 2;
                }
            }
            return kn;
        };
        let _evalBasisFuncs = function (t, kn, k, s) {
            var i, j, a, b, den, N = [];
            if (kn[s] <= t && t < kn[s + 1]) {
                N[s] = 1;
            }
            else {
                N[s] = 0;
            }
            for (i = 2; i <= k; i++) {
                for (j = s - i + 1; j <= s; j++) {
                    if (j <= s - i + 1 || j < 0) {
                        a = 0.0;
                    }
                    else {
                        a = N[j];
                    }
                    if (j >= s) {
                        b = 0.0;
                    }
                    else {
                        b = N[j + 1];
                    }
                    den = kn[j + i - 1] - kn[j];
                    if (den === 0) {
                        N[j] = 0;
                    }
                    else {
                        N[j] = ((t - kn[j]) / den) * a;
                    }
                    den = kn[j + i] - kn[j + 1];
                    if (den !== 0) {
                        N[j] += ((kn[j + i] - t) / den) * b;
                    }
                }
            }
            return N;
        };
        /** @ignore */
        let makeFct = function (which) {
            return function (t, suspendedUpdate) {
                var y, j, s, N = [], len = points.length, n = len - 1, k = order;
                if (n <= 0) {
                    return NaN;
                }
                if (n + 2 <= k) {
                    k = n + 1;
                }
                if (t <= 0) {
                    return points[0][which]();
                }
                if (t >= n - k + 2) {
                    return points[n][which]();
                }
                s = Math.floor(t) + k - 1;
                knots = _knotVector(n, k);
                N = _evalBasisFuncs(t, knots, k, s);
                y = 0.0;
                for (j = s - k + 1; j <= s; j++) {
                    if (j < len && j >= 0) {
                        y += points[j][which]() * N[j];
                    }
                }
                return y;
            };
        };
        return [
            makeFct("X"),
            makeFct("Y"),
            0,
            function () {
                return points.length - 1;
            }
        ];
    }
    /**
     * Numerical (symmetric) approximation of derivative. suspendUpdate is piped through,
     * see {@link JXG.Curve#updateCurve}
     * and {@link JXG.Curve#hasPoint}.
     * @param {function} f Function in one variable to be differentiated.
     * @param {object} [obj] Optional object that is treated as "this" in the function body. This is useful, if the function is a
     * method of an object and contains a reference to its parent object via "this".
     * @returns {function} Derivative function of a given function f.
     * @memberof JXG.Math.Numerics
     */
    static D(f, obj) {
        if (!Type.exists(obj)) {
            return function (x, suspendedUpdate) {
                var h = 0.00001, h2 = h * 2.0;
                // Experiments with Richardsons rule
                /*
                    var phi = (f(x + h, suspendedUpdate) - f(x - h, suspendedUpdate)) / h2;
                    var phi2;
                    h *= 0.5;
                    h2 *= 0.5;
                    phi2 = (f(x + h, suspendedUpdate) - f(x - h, suspendedUpdate)) / h2;

                    return phi2 + (phi2 - phi) / 3.0;
                    */
                return (f(x + h, suspendedUpdate) - f(x - h, suspendedUpdate)) / h2;
            };
        }
        return function (x, suspendedUpdate) {
            var h = 0.00001, h2 = h * 2.0;
            return ((f.apply(obj, [x + h, suspendedUpdate]) -
                f.apply(obj, [x - h, suspendedUpdate])) /
                h2);
        };
    }
    /**
     * Evaluate the function term for {@link JXG.Math.Numerics.riemann}.
     * @private
     * @param {Number} x function argument
     * @param {function} f JavaScript function returning a number
     * @param {String} type Name of the Riemann sum type, e.g. 'lower'.
     * @param {Number} delta Width of the bars in user coordinates
     * @returns {Number} Upper (delta > 0) or lower (delta < 0) value of the bar containing x of the Riemann sum.
     * @see JXG.Math.Numerics.riemann
     * @private
     * @memberof JXG.Math.Numerics
     */
    static _riemannValue(x, f, type, delta) {
        var y, y1, x1, delta1;
        if (delta < 0) {
            // delta is negative if the lower function term is evaluated
            if (type !== "trapezoidal") {
                x = x + delta;
            }
            delta *= -1;
            if (type === "lower") {
                type = "upper";
            }
            else if (type === "upper") {
                type = "lower";
            }
        }
        delta1 = delta * 0.01; // for 'lower' and 'upper'
        if (type === "right") {
            y = f(x + delta);
        }
        else if (type === "middle") {
            y = f(x + delta * 0.5);
        }
        else if (type === "left" || type === "trapezoidal") {
            y = f(x);
        }
        else if (type === "lower") {
            y = f(x);
            for (x1 = x + delta1; x1 <= x + delta; x1 += delta1) {
                y1 = f(x1);
                if (y1 < y) {
                    y = y1;
                }
            }
            y1 = f(x + delta);
            if (y1 < y) {
                y = y1;
            }
        }
        else if (type === "upper") {
            y = f(x);
            for (x1 = x + delta1; x1 <= x + delta; x1 += delta1) {
                y1 = f(x1);
                if (y1 > y) {
                    y = y1;
                }
            }
            y1 = f(x + delta);
            if (y1 > y) {
                y = y1;
            }
        }
        else if (type === "random") {
            y = f(x + delta * Math.random());
        }
        else if (type === "simpson") {
            y = (f(x) + 4 * f(x + delta * 0.5) + f(x + delta)) / 6.0;
        }
        else {
            y = f(x); // default is lower
        }
        return y;
    }
    /**
     * Helper function to create curve which displays Riemann sums.
     * Compute coordinates for the rectangles showing the Riemann sum.
     * <p>
     * In case of type "simpson" and "trapezoidal", the horizontal line approximating the function value
     * is replaced by a parabola or a secant. IN case of "simpson",
     * the parabola is approximated visually by a polygonal chain of fixed step width.
     *
     * @param {Function|Array} f Function or array of two functions.
     * If f is a function the integral of this function is approximated by the Riemann sum.
     * If f is an array consisting of two functions the area between the two functions is filled
     * by the Riemann sum bars.
     * @param {Number} n number of rectangles.
     * @param {String} type Type of approximation. Possible values are: 'left', 'right', 'middle', 'lower', 'upper', 'random', 'simpson', or 'trapezoidal'.
     * "simpson" is Simpson's 1/3 rule.
     * @param {Number} start Left border of the approximation interval
     * @param {Number} end Right border of the approximation interval
     * @returns {Array} An array of two arrays containing the x and y coordinates for the rectangles showing the Riemann sum. This
     * array may be used as parent array of a {@link JXG.Curve}. The third parameteris the riemann sum, i.e. the sum of the volumes of all
     * rectangles.
     * @memberof JXG.Math.Numerics
     */
    static riemann(gf, n, type, start, end) {
        var i, delta, k, a, b, c, f0, f1, f2, xx, h, steps = 30, // Fixed step width for Simpson's rule
        xarr = [], yarr = [], x = start, sum = 0, y, f, g;
        if (Array.isArray(gf)) {
            g = gf[0];
            f = gf[1];
        }
        else {
            f = gf;
        }
        n = Math.floor(n);
        if (n <= 0) {
            return [xarr, yarr, sum];
        }
        delta = (end - start) / n;
        // "Upper" horizontal line defined by function
        for (i = 0; i < n; i++) {
            if (type === "simpson") {
                sum += this._riemannValue(x, f, type, delta) * delta;
                h = delta * 0.5;
                f0 = f(x);
                f1 = f(x + h);
                f2 = f(x + 2 * h);
                a = (f2 + f0 - 2 * f1) / (h * h) * 0.5;
                b = (f2 - f0) / (2 * h);
                c = f1;
                for (k = 0; k < steps; k++) {
                    xx = k * delta / steps - h;
                    xarr.push(x + xx + h);
                    yarr.push(a * xx * xx + b * xx + c);
                }
                x += delta;
                y = f2;
            }
            else {
                y = this._riemannValue(x, f, type, delta);
                xarr.push(x);
                yarr.push(y);
                x += delta;
                if (type === "trapezoidal") {
                    f2 = f(x);
                    sum += (y + f2) * 0.5 * delta;
                    y = f2;
                }
                else {
                    sum += y * delta;
                }
                xarr.push(x);
                yarr.push(y);
            }
            xarr.push(x);
            yarr.push(y);
        }
        // "Lower" horizontal line
        // Go backwards
        for (i = 0; i < n; i++) {
            if (type === "simpson" && g) {
                sum -= this._riemannValue(x, g, type, -delta) * delta;
                h = delta * 0.5;
                f0 = g(x);
                f1 = g(x - h);
                f2 = g(x - 2 * h);
                a = (f2 + f0 - 2 * f1) / (h * h) * 0.5;
                b = (f2 - f0) / (2 * h);
                c = f1;
                for (k = 0; k < steps; k++) {
                    xx = k * delta / steps - h;
                    xarr.push(x - xx - h);
                    yarr.push(a * xx * xx + b * xx + c);
                }
                x -= delta;
                y = f2;
            }
            else {
                if (g) {
                    y = this._riemannValue(x, g, type, -delta);
                }
                else {
                    y = 0.0;
                }
                xarr.push(x);
                yarr.push(y);
                x -= delta;
                if (g) {
                    if (type === "trapezoidal") {
                        f2 = g(x);
                        sum -= (y + f2) * 0.5 * delta;
                        y = f2;
                    }
                    else {
                        sum -= y * delta;
                    }
                }
            }
            xarr.push(x);
            yarr.push(y);
            // Draw the vertical lines
            xarr.push(x);
            yarr.push(f(x));
        }
        return [xarr, yarr, sum];
    }
    /**
     * Approximate the integral by Riemann sums.
     * Compute the area described by the riemann sum rectangles.
     *
     * If there is an element of type {@link Riemannsum} then it is more efficient
     * to use the method JXG.Curve.Value() of this element instead.
     *
     * @param {Function_Array} f Function or array of two functions.
     * If f is a function the integral of this function is approximated by the Riemann sum.
     * If f is an array consisting of two functions the area between the two functions is approximated
     * by the Riemann sum.
     * @param {Number} n number of rectangles.
     * @param {String} type Type of approximation. Possible values are: 'left', 'right', 'middle', 'lower', 'upper', 'random', 'simpson' or 'trapezoidal'.
     *
     * @param {Number} start Left border of the approximation interval
     * @param {Number} end Right border of the approximation interval
     * @returns {Number} The sum of the areas of the rectangles.
     * @memberof JXG.Math.Numerics
     */
    static riemannsum(f, n, type, start, end) {
        console.warn("Deprecated .riemannsum(), use Numerics.riemann()[2]");
        return this.riemann(f, n, type, start, end)[2];
    }
    /**
     * Solve initial value problems numerically using <i>explicit</i> Runge-Kutta methods.
     * See {@link https://en.wikipedia.org/wiki/Runge-Kutta_methods} for more information on the algorithm.
     * @param {object|String} butcher Butcher tableau describing the Runge-Kutta method to use. This can be either a string describing
     * a Runge-Kutta method with a Butcher tableau predefined in JSXGraph like 'euler', 'heun', 'rk4' or an object providing the structure
     * <pre>
     * {
     *     s: &lt;Number&gt;,
     *     A: &lt;matrix&gt;,
     *     b: &lt;Array&gt;,
     *     c: &lt;Array&gt;
     * }
     * </pre>
     * which corresponds to the Butcher tableau structure
     * shown here: https://en.wikipedia.org/w/index.php?title=List_of_Runge%E2%80%93Kutta_methods&oldid=357796696 .
     * <i>Default</i> is 'euler'.
     * @param {Array} x0 Initial value vector. Even if the problem is one-dimensional, the initial value has to be given in an array.
     * @param {Array} I Interval on which to integrate.
     * @param {Number} N Number of integration intervals, i.e. there are <i>N+1</i> evaluation points.
     * @param {function} f Function describing the right hand side of the first order ordinary differential equation, i.e. if the ode
     * is given by the equation <pre>dx/dt = f(t, x(t))</pre>. So, f has to take two parameters, a number <tt>t</tt> and a
     * vector <tt>x</tt>, and has to return a vector of the same length as <tt>x</tt> has.
     * @returns {Array} An array of vectors describing the solution of the ode on the given interval I.
     * @example
     * // A very simple autonomous system dx(t)/dt = x(t);
     * var f = function(t, x) {
     *     return [x[0]];
     * }
     *
     * // Solve it with initial value x(0) = 1 on the interval [0, 2]
     * // with 20 evaluation points.
     * var data = JXG.Math.Numerics.rungeKutta('heun', [1], [0, 2], 20, f);
     *
     * // Prepare data for plotting the solution of the ode using a curve.
     * var dataX = [];
     * var dataY = [];
     * var h = 0.1;        // (I[1] - I[0])/N  = (2-0)/20
     * var i;
     * for(i=0; i&lt;data.length; i++) {
     *     dataX[i] = i*h;
     *     dataY[i] = data[i][0];
     * }
     * var g = board.create('curve', [dataX, dataY], {strokeWidth:'2px'});
     * </pre><div class="jxgbox" id="JXGd2432d04-4ef7-4159-a90b-a2eb8d38c4f6" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     * var board = JXG.JSXGraph.initBoard('JXGd2432d04-4ef7-4159-a90b-a2eb8d38c4f6', {boundingbox: [-1, 5, 5, -1], axis: true, showcopyright: false, shownavigation: false});
     * var f = function(t, x) {
     *     // we have to copy the value.
     *     // return x; would just return the reference.
     *     return [x[0]];
     * }
     * var data = JXG.Math.Numerics.rungeKutta('heun', [1], [0, 2], 20, f);
     * var dataX = [];
     * var dataY = [];
     * var h = 0.1;
     * for(var i=0; i<data.length; i++) {
     *     dataX[i] = i*h;
     *     dataY[i] = data[i][0];
     * }
     * var g = board.create('curve', [dataX, dataY], {strokeColor:'red', strokeWidth:'2px'});
     * </script><pre>
     * @memberof JXG.Math.Numerics
     */
    static rungeKutta(butcher, x0, I, N, f) {
        var e, i, j, k, l, s, x = [], y = [], h = (I[1] - I[0]) / N, t = I[0], dim = x0.length, result = [], r = 0;
        if (Type.isString(butcher)) {
            butcher = predefinedButcher[butcher] || predefinedButcher.euler;
        }
        s = butcher.s;
        // Don't change x0, so copy it
        x = x0.slice();
        for (i = 0; i <= N; i++) {
            result[r] = x.slice();
            r++;
            k = [];
            for (j = 0; j < s; j++) {
                // Init y = 0
                for (e = 0; e < dim; e++) {
                    y[e] = 0.0;
                }
                // Calculate linear combination of former k's and save it in y
                for (l = 0; l < j; l++) {
                    for (e = 0; e < dim; e++) {
                        y[e] += butcher.A[j][l] * h * k[l][e];
                    }
                }
                // Add x(t) to y
                for (e = 0; e < dim; e++) {
                    y[e] += x[e];
                }
                // Calculate new k and add it to the k matrix
                k.push(f(t + butcher.c[j] * h, y));
            }
            // Init y = 0
            for (e = 0; e < dim; e++) {
                y[e] = 0.0;
            }
            for (l = 0; l < s; l++) {
                for (e = 0; e < dim; e++) {
                    y[e] += butcher.b[l] * k[l][e];
                }
            }
            for (e = 0; e < dim; e++) {
                x[e] = x[e] + h * y[e];
            }
            t += h;
        }
        return result;
    }
    /**
     * Given a number x_0, this function tries to find a second number x_1 such that
     * the function f has opposite signs at x_0 and x_1.
     * The return values have to be tested if the method succeeded.
     *
     * @param {Function} f Function, whose root is to be found
     * @param {Number} x0 Start value
     * @param {Object} [context] Parent object in case f is method of it
     * @returns {Array} [x_0, f(x_0), x_1, f(x_1)] in case that x_0 <= x_1
     *   or [x_1, f(x_1), x_0, f(x_0)] in case that x_1 < x_0.
     *
     * @see JXG.Math.Numerics.fzero
     * @see JXG.Math.Numerics.chandrupatla
     *
     * @memberof JXG.Math.Numerics
     */
    static findBracket(f, x0, context) {
        var a, aa, fa, blist, b, fb, u, fu, i, len;
        if (Array.isArray(x0)) {
            return x0;
        }
        a = x0;
        fa = f.call(context, a);
        // nfev += 1;
        // Try to get b, by trying several values related to a
        aa = a === 0 ? 1 : a;
        blist = [
            a - 0.1 * aa,
            a + 0.1 * aa,
            a - 1,
            a + 1,
            a - 0.5 * aa,
            a + 0.5 * aa,
            a - 0.6 * aa,
            a + 0.6 * aa,
            a - 1 * aa,
            a + 1 * aa,
            a - 2 * aa,
            a + 2 * aa,
            a - 5 * aa,
            a + 5 * aa,
            a - 10 * aa,
            a + 10 * aa,
            a - 50 * aa,
            a + 50 * aa,
            a - 100 * aa,
            a + 100 * aa
        ];
        len = blist.length;
        for (i = 0; i < len; i++) {
            b = blist[i];
            fb = f.call(context, b);
            // nfev += 1;
            if (fa * fb <= 0) {
                break;
            }
        }
        if (b < a) {
            u = a;
            a = b;
            b = u;
            fu = fa;
            fa = fb;
            fb = fu;
        }
        return [a, fa, b, fb];
    }
    /**
     *
     * Find zero of an univariate function f.
     * @param {function} f Function, whose root is to be found
     * @param {Array|Number} x0  Start value or start interval enclosing the root.
     * If x0 is an interval [a,b], it is required that f(a)f(b) <= 0, otherwise the minimum of f in [a, b] will be returned.
     * If x0 is a number, the algorithms tries to enclose the root by an interval [a, b] containing x0 and the root and
     * f(a)f(b) <= 0. If this fails, the algorithm falls back to Newton's method.
     * @param {Object} [context] Parent object in case f is method of it
     * @returns {Number} the approximation of the root
     * Algorithm:
     *  Brent's root finder from
     *  G.Forsythe, M.Malcolm, C.Moler, Computer methods for mathematical
     *  computations. M., Mir, 1980, p.180 of the Russian edition
     *  https://www.netlib.org/c/brent.shar
     *
     * If x0 is an array containing lower and upper bound for the zero
     * algorithm 748 is applied. Otherwise, if x0 is a number,
     * the algorithm tries to bracket a zero of f starting from x0.
     * If this fails, we fall back to Newton's method.
     *
     * @see JXG.Math.Numerics.chandrupatla
     * @see JXG.Math.Numerics.root
     * @see JXG.Math.Numerics.findBracket
     * @see JXG.Math.Numerics.Newton
     * @see JXG.Math.Numerics.fminbr
     * @memberof JXG.Math.Numerics
     */
    static fzero(f, x0, context) {
        var a, b, c, fa, fb, fc, res, x00, prev_step, t1, t2, cb, tol_act, // Actual tolerance
        p, // Interpolation step is calculated in the form p/q; division
        q, // operations is delayed until the last moment
        new_step, // Step at this iteration
        eps = JSXMath.eps, maxiter = this.maxIterationsRoot, niter = 0;
        // nfev = 0;
        if (Array.isArray(x0)) {
            if (x0.length < 2) {
                throw new Error("JXG.Math.Numerics.fzero: length of array x0 has to be at least two.");
            }
            x00 = this.findDomain(f, x0, context);
            a = x00[0];
            b = x00[1];
            // a = x0[0];
            // b = x0[1];
            fa = f.call(context, a);
            // nfev += 1;
            fb = f.call(context, b);
            // nfev += 1;
        }
        else {
            res = this.findBracket(f, x0, context);
            a = res[0];
            fa = res[1];
            b = res[2];
            fb = res[3];
        }
        if (Math.abs(fa) <= eps) {
            return a;
        }
        if (Math.abs(fb) <= eps) {
            return b;
        }
        if (fa * fb > 0) {
            // Bracketing not successful, fall back to Newton's method or to fminbr
            if (Array.isArray(x0)) {
                return this.fminbr(f, [a, b], context);
            }
            return this.Newton(f, a, context);
        }
        // OK, we have enclosed a zero of f.
        // Now we can start Brent's method
        c = a;
        fc = fa;
        // Main iteration loop
        while (niter < maxiter) {
            // Distance from the last but one to the last approximation
            prev_step = b - a;
            // Swap data for b to be the best approximation
            if (Math.abs(fc) < Math.abs(fb)) {
                a = b;
                b = c;
                c = a;
                fa = fb;
                fb = fc;
                fc = fa;
            }
            tol_act = 2 * eps * Math.abs(b) + eps * 0.5;
            new_step = (c - b) * 0.5;
            if (Math.abs(new_step) <= tol_act || Math.abs(fb) <= eps) {
                //  Acceptable approx. is found
                return b;
            }
            // Decide if the interpolation can be tried
            // If prev_step was large enough and was in true direction Interpolatiom may be tried
            if (Math.abs(prev_step) >= tol_act && Math.abs(fa) > Math.abs(fb)) {
                cb = c - b;
                // If we have only two distinct points linear interpolation can only be applied
                if (a === c) {
                    t1 = fb / fa;
                    p = cb * t1;
                    q = 1.0 - t1;
                    // Quadric inverse interpolation
                }
                else {
                    q = fa / fc;
                    t1 = fb / fc;
                    t2 = fb / fa;
                    p = t2 * (cb * q * (q - t1) - (b - a) * (t1 - 1.0));
                    q = (q - 1.0) * (t1 - 1.0) * (t2 - 1.0);
                }
                // p was calculated with the opposite sign; make p positive
                if (p > 0) {
                    q = -q;
                    // and assign possible minus to q
                }
                else {
                    p = -p;
                }
                // If b+p/q falls in [b,c] and isn't too large it is accepted
                // If p/q is too large then the bissection procedure can reduce [b,c] range to more extent
                if (p < 0.75 * cb * q - Math.abs(tol_act * q) * 0.5 &&
                    p < Math.abs(prev_step * q * 0.5)) {
                    new_step = p / q;
                }
            }
            // Adjust the step to be not less than tolerance
            if (Math.abs(new_step) < tol_act) {
                new_step = new_step > 0 ? tol_act : -tol_act;
            }
            // Save the previous approx.
            a = b;
            fa = fb;
            b += new_step;
            fb = f.call(context, b);
            // Do step to a new approxim.
            // nfev += 1;
            // Adjust c for it to have a sign opposite to that of b
            if ((fb > 0 && fc > 0) || (fb < 0 && fc < 0)) {
                c = a;
                fc = fa;
            }
            niter++;
        } // End while
        return b;
    }
    /**
     * Find zero of an univariate function f.
     * @param {function} f Function, whose root is to be found
     * @param {Array|Number} x0  Start value or start interval enclosing the root.
     * If x0 is an interval [a,b], it is required that f(a)f(b) <= 0, otherwise the minimum of f in [a, b] will be returned.
     * If x0 is a number, the algorithms tries to enclose the root by an interval [a, b] containing x0 and the root and
     * f(a)f(b) <= 0. If this fails, the algorithm falls back to Newton's method.
     * @param {Object} [context] Parent object in case f is method of it
     * @returns {Number} the approximation of the root
     * Algorithm:
     * Chandrupatla's method, see
     * Tirupathi R. Chandrupatla,
     * "A new hybrid quadratic/bisection algorithm for finding the zero of a nonlinear function without using derivatives",
     * Advances in Engineering Software, Volume 28, Issue 3, April 1997, Pages 145-149.
     *
     * If x0 is an array containing lower and upper bound for the zero
     * algorithm 748 is applied. Otherwise, if x0 is a number,
     * the algorithm tries to bracket a zero of f starting from x0.
     * If this fails, we fall back to Newton's method.
     *
     * @see JXG.Math.Numerics.root
     * @see JXG.Math.Numerics.fzero
     * @see JXG.Math.Numerics.findBracket
     * @see JXG.Math.Numerics.Newton
     * @see JXG.Math.Numerics.fminbr
     * @memberof JXG.Math.Numerics
     */
    static chandrupatla(f, x0, context) {
        var a, b, fa, fb, res, niter = 0, maxiter = this.maxIterationsRoot, rand = 1 + Math.random() * 0.001, t = 0.5 * rand, eps = JSXMath.eps, // 1.e-10,
        dlt = 0.00001, x1, x2, x3, x, f1, f2, f3, y, xm, fm, tol, tl, xi, ph, fl, fh, AL, A, B, C, D;
        if (Array.isArray(x0)) {
            if (x0.length < 2) {
                throw new Error("JXG.Math.Numerics.fzero: length of array x0 has to be at least two.");
            }
            a = x0[0];
            fa = f.call(context, a);
            // nfev += 1;
            b = x0[1];
            fb = f.call(context, b);
            // nfev += 1;
        }
        else {
            res = this.findBracket(f, x0, context);
            a = res[0];
            fa = res[1];
            b = res[2];
            fb = res[3];
        }
        if (fa * fb > 0) {
            // Bracketing not successful, fall back to Newton's method or to fminbr
            if (Array.isArray(x0)) {
                return this.fminbr(f, [a, b], context);
            }
            return this.Newton(f, a, context);
        }
        x1 = a;
        x2 = b;
        f1 = fa;
        f2 = fb;
        do {
            x = x1 + t * (x2 - x1);
            y = f.call(context, x);
            // Arrange 2-1-3: 2-1 interval, 1 middle, 3 discarded point
            if (Math.sign(y) === Math.sign(f1)) {
                x3 = x1;
                x1 = x;
                f3 = f1;
                f1 = y;
            }
            else {
                x3 = x2;
                x2 = x1;
                f3 = f2;
                f2 = f1;
            }
            x1 = x;
            f1 = y;
            xm = x1;
            fm = f1;
            if (Math.abs(f2) < Math.abs(f1)) {
                xm = x2;
                fm = f2;
            }
            tol = 2 * eps * Math.abs(xm) + 0.5 * dlt;
            tl = tol / Math.abs(x2 - x1);
            if (tl > 0.5 || fm === 0) {
                break;
            }
            // If inverse quadratic interpolation holds, use it
            xi = (x1 - x2) / (x3 - x2);
            ph = (f1 - f2) / (f3 - f2);
            fl = 1 - Math.sqrt(1 - xi);
            fh = Math.sqrt(xi);
            if (fl < ph && ph < fh) {
                AL = (x3 - x1) / (x2 - x1);
                A = f1 / (f2 - f1);
                B = f3 / (f2 - f3);
                C = f1 / (f3 - f1);
                D = f2 / (f3 - f2);
                t = A * B + C * D * AL;
            }
            else {
                t = 0.5 * rand;
            }
            // Adjust t away from the interval boundary
            if (t < tl) {
                t = tl;
            }
            if (t > 1 - tl) {
                t = 1 - tl;
            }
            niter++;
        } while (niter <= maxiter);
        // console.log(niter);
        return xm;
    }
    /**
     * Find a small enclosing interval of the domain of a function by
     * tightening the input interval x0.
     * <p>
     * This is a helper function which is used in {@link JXG.Math.Numerics.fminbr}
     * {@link JXG.Math.Numerics.fzero} and  {@link JXG.Curve.getLabelPosition}
     * to avoid search in an interval where the function is mostly undefined.
     *
     * @param {function} f
     * @param {Array} x0 Start interval
     * @param {Object} context Parent object in case f is method of it
     * @param {Boolean} [outer=true] if true take a proper enclosing array. If false return the domain such that the function is defined
     * at its  borders.
     * @returns Array
     *
     * @example
     * var f = (x) => Math.sqrt(x);
     * console.log(JXG.Math.Numerics.findDomain(f, [-5, 5]));
     *
     * // Output: [ -0.00020428174445492973, 5 ]
     *
     * @example
     * var f = (x) => Math.sqrt(x);
     * console.log(JXG.Math.Numerics.findDomain(f, [-5, 5], null, false));
     *
     * // Output: [ 0.00020428174562965915, 5 ]
     */
    static findDomain(f, x0, context, outer = true) {
        var a, b, c, fc, x, gr = 1 - 1 / 1.61803398875, eps = 0.001, cnt, max_cnt = 20;
        if (outer === undefined) {
            outer = true;
        }
        if (!Array.isArray(x0) || x0.length < 2) {
            throw new Error("JXG.Math.Numerics.findDomain: length of array x0 has to be at least two.");
        }
        x = x0.slice();
        a = x[0];
        b = x[1];
        fc = f.call(context, a);
        if (isNaN(fc)) {
            // Divide the interval with the golden ratio
            // and keep a such that f(a) = NaN
            cnt = 0;
            while (b - a > eps && cnt < max_cnt) {
                c = (b - a) * gr + a;
                fc = f.call(context, c);
                if (isNaN(fc)) {
                    a = c;
                }
                else {
                    b = c;
                }
                cnt++;
            }
            if (outer) {
                x[0] = a;
            }
            else {
                x[0] = b;
            }
            // x[0] = a;
        }
        a = x[0];
        b = x[1];
        fc = f.call(context, b);
        if (isNaN(fc)) {
            // Divide the interval with the golden ratio
            // and keep b such that f(b) = NaN
            cnt = 0;
            while (b - a > eps && cnt < max_cnt) {
                c = b - (b - a) * gr;
                fc = f.call(context, c);
                if (isNaN(fc)) {
                    b = c;
                }
                else {
                    a = c;
                }
                cnt++;
            }
            if (outer) {
                x[1] = b;
            }
            else {
                x[1] = a;
            }
            // x[1] = b;
        }
        return x;
    }
    /**
     *
     * Find minimum of an univariate function f.
     * <p>
     * Algorithm:
     *  G.Forsythe, M.Malcolm, C.Moler, Computer methods for mathematical
     *  computations. M., Mir, 1980, p.180 of the Russian edition
     *
     * @param {function} f Function, whose minimum is to be found
     * @param {Array} x0  Start interval enclosing the minimum
     * @param {Object} [context] Parent object in case f is method of it
     * @returns {Number} the approximation of the minimum value position
     * @memberof JXG.Math.Numerics
     **/
    static fminbr(f, x0, context) {
        var a, b, x, v, w, fx, fv, fw, x00, range, middle_range, tol_act, new_step, p, q, t, ft, r = (3.0 - Math.sqrt(5.0)) * 0.5, // Golden section ratio
        tol = JSXMath.eps, sqrteps = JSXMath.eps, // Math.sqrt(JSXMath.eps),
        maxiter = Numerics.maxIterationsMinimize, niter = 0;
        // nfev = 0;
        if (!Array.isArray(x0) || x0.length < 2) {
            throw new Error("JXG.Math.Numerics.fminbr: length of array x0 has to be at least two.");
        }
        x00 = this.findDomain(f, x0, context);
        a = x00[0];
        b = x00[1];
        v = a + r * (b - a);
        fv = f.call(context, v);
        // First step - always gold section
        // nfev += 1;
        x = v;
        w = v;
        fx = fv;
        fw = fv;
        while (niter < maxiter) {
            // Range over the interval in which we are looking for the minimum
            range = b - a;
            middle_range = (a + b) * 0.5;
            // Actual tolerance
            tol_act = sqrteps * Math.abs(x) + tol / 3.0;
            if (Math.abs(x - middle_range) + range * 0.5 <= 2.0 * tol_act) {
                // Acceptable approx. is found
                return x;
            }
            // Obtain the golden section step
            new_step = r * (x < middle_range ? b - x : a - x);
            // Decide if the interpolation can be tried. If x and w are distinct, interpolatiom may be tried
            if (Math.abs(x - w) >= tol_act) {
                // Interpolation step is calculated as p/q;
                // division operation is delayed until last moment
                t = (x - w) * (fx - fv);
                q = (x - v) * (fx - fw);
                p = (x - v) * q - (x - w) * t;
                q = 2 * (q - t);
                if (q > 0) {
                    p = -p; // q was calculated with the opposite sign; make q positive
                }
                else {
                    q = -q; // // and assign possible minus to p
                }
                if (Math.abs(p) < Math.abs(new_step * q) && // If x+p/q falls in [a,b]
                    p > q * (a - x + 2 * tol_act) && //  not too close to a and
                    p < q * (b - x - 2 * tol_act)) {
                    // b, and isn't too large
                    new_step = p / q; // it is accepted
                }
                // If p / q is too large then the
                // golden section procedure can
                // reduce [a,b] range to more
                // extent
            }
            // Adjust the step to be not less than tolerance
            if (Math.abs(new_step) < tol_act) {
                if (new_step > 0) {
                    new_step = tol_act;
                }
                else {
                    new_step = -tol_act;
                }
            }
            // Obtain the next approximation to min
            // and reduce the enveloping range
            // Tentative point for the min
            t = x + new_step;
            ft = f.call(context, t);
            // nfev += 1;
            // t is a better approximation
            if (ft <= fx) {
                // Reduce the range so that t would fall within it
                if (t < x) {
                    b = x;
                }
                else {
                    a = x;
                }
                // Assign the best approx to x
                v = w;
                w = x;
                x = t;
                fv = fw;
                fw = fx;
                fx = ft;
                // x remains the better approx
            }
            else {
                // Reduce the range enclosing x
                if (t < x) {
                    a = t;
                }
                else {
                    b = t;
                }
                if (ft <= fw || w === x) {
                    v = w;
                    w = t;
                    fv = fw;
                    fw = ft;
                }
                else if (ft <= fv || v === x || v === w) {
                    v = t;
                    fv = ft;
                }
            }
            niter += 1;
        }
        return x;
    }
    /**
     * GLOMIN seeks a global minimum of a function F(X) in an interval [A,B]
     * and is the adaption of the algorithm GLOMIN by Richard Brent.
     *
     * Here is the original documentation:
     * <pre>
     *
     * Discussion:
     *
     * This function assumes that F(X) is twice continuously differentiable over [A,B]
     * and that |F''(X)| <= M for all X in [A,B].
     *
     * Licensing:
     *   This code is distributed under the GNU LGPL license.
     *
     * Modified:
     *
     *   17 April 2008
     *
     * Author:
     *
     *   Original FORTRAN77 version by Richard Brent.
     *   C version by John Burkardt.
     *   https://people.math.sc.edu/Burkardt/c_src/brent/brent.c
     *
     * Reference:
     *
     *   Richard Brent,
     *  Algorithms for Minimization Without Derivatives,
     *   Dover, 2002,
     *  ISBN: 0-486-41998-3,
     *   LC: QA402.5.B74.
     *
     * Parameters:
     *
     *   Input, double A, B, the endpoints of the interval.
     *  It must be the case that A < B.
     *
     *   Input, double C, an initial guess for the global
     *  minimizer.  If no good guess is known, C = A or B is acceptable.
     *
     *  Input, double M, the bound on the second derivative.
     *
     *   Input, double MACHEP, an estimate for the relative machine
     *  precision.
     *
     *   Input, double E, a positive tolerance, a bound for the
     *  absolute error in the evaluation of F(X) for any X in [A,B].
     *
     *   Input, double T, a positive error tolerance.
     *
     *    Input, double F (double x ), a user-supplied
     *  function whose global minimum is being sought.
     *
     *   Output, double *X, the estimated value of the abscissa
     *  for which F attains its global minimum value in [A,B].
     *
     *   Output, double GLOMIN, the value F(X).
     * </pre>
     *
     * In JSXGraph, some parameters of the original algorithm are set to fixed values:
     * <ul>
     *  <li> M = 10000000.0
     *  <li> C = A or B, depending if f(A) <= f(B)
     *  <li> T = JXG.Math.eps
     *  <li> E = JXG.Math.eps * JXG.Math.eps
     *  <li> MACHEP = JXG.Math.eps * JXG.Math.eps * JXG.Math.eps
     * </ul>
     * @param {function} f Function, whose global minimum is to be found
     * @param {Array} x0 Array of length 2 determining the interval [A, B] for which the global minimum is to be found
     * @returns {Array} [x, y] x is the position of the global minimum and y = f(x).
     */
    static glomin(f, x0) {
        var a0, a2, a3, d0, d1, d2, h, k, m2, p, q, qs, r, s, sc, y, y0, y1, y2, y3, yb, z0, z1, z2, a, b, c, x, m = 10000000.0, t = JSXMath.eps, // * JSXMath.eps,
        e = JSXMath.eps * JSXMath.eps, machep = JSXMath.eps * JSXMath.eps * JSXMath.eps;
        a = x0[0];
        b = x0[1];
        c = (f(a) < f(b)) ? a : b;
        a0 = b;
        x = a0;
        a2 = a;
        y0 = f(b);
        yb = y0;
        y2 = f(a);
        y = y2;
        if (y0 < y) {
            y = y0;
        }
        else {
            x = a;
        }
        if (b <= a) {
            return y;
        }
        m2 = 0.5 * (1.0 + 16.0 * machep) * m;
        if (c <= a || b <= c) {
            sc = 0.5 * (a + b);
        }
        else {
            sc = c;
        }
        y1 = f(sc);
        k = 3;
        d0 = a2 - sc;
        h = 9.0 / 11.0;
        if (y1 < y) {
            x = sc;
            y = y1;
        }
        for (;;) {
            d1 = a2 - a0;
            d2 = sc - a0;
            z2 = b - a2;
            z0 = y2 - y1;
            z1 = y2 - y0;
            r = d1 * d1 * z0 - d0 * d0 * z1;
            p = r;
            qs = 2.0 * (d0 * z1 - d1 * z0);
            q = qs;
            if (k < 1000000 || y2 <= y) {
                for (;;) {
                    if (q * (r * (yb - y2) + z2 * q * ((y2 - y) + t)) <
                        z2 * m2 * r * (z2 * q - r)) {
                        a3 = a2 + r / q;
                        y3 = f(a3);
                        if (y3 < y) {
                            x = a3;
                            y = y3;
                        }
                    }
                    k = ((1611 * k) % 1048576);
                    q = 1.0;
                    r = (b - a) * 0.00001 * k;
                    if (z2 <= r) {
                        break;
                    }
                }
            }
            else {
                k = ((1611 * k) % 1048576);
                q = 1.0;
                r = (b - a) * 0.00001 * k;
                while (r < z2) {
                    if (q * (r * (yb - y2) + z2 * q * ((y2 - y) + t)) <
                        z2 * m2 * r * (z2 * q - r)) {
                        a3 = a2 + r / q;
                        y3 = f(a3);
                        if (y3 < y) {
                            x = a3;
                            y = y3;
                        }
                    }
                    k = ((1611 * k) % 1048576);
                    q = 1.0;
                    r = (b - a) * 0.00001 * k;
                }
            }
            r = m2 * d0 * d1 * d2;
            s = Math.sqrt(((y2 - y) + t) / m2);
            h = 0.5 * (1.0 + h);
            p = h * (p + 2.0 * r * s);
            q = q + 0.5 * qs;
            r = -0.5 * (d0 + (z0 + 2.01 * e) / (d0 * m2));
            if (r < s || d0 < 0.0) {
                r = a2 + s;
            }
            else {
                r = a2 + r;
            }
            if (0.0 < p * q) {
                a3 = a2 + p / q;
            }
            else {
                a3 = r;
            }
            for (;;) {
                a3 = Math.max(a3, r);
                if (b <= a3) {
                    a3 = b;
                    y3 = yb;
                }
                else {
                    y3 = f(a3);
                }
                if (y3 < y) {
                    x = a3;
                    y = y3;
                }
                d0 = a3 - a2;
                if (a3 <= r) {
                    break;
                }
                p = 2.0 * (y2 - y3) / (m * d0);
                if ((1.0 + 9.0 * machep) * d0 <= Math.abs(p)) {
                    break;
                }
                if (0.5 * m2 * (d0 * d0 + p * p) <= (y2 - y) + (y3 - y) + 2.0 * t) {
                    break;
                }
                a3 = 0.5 * (a2 + a3);
                h = 0.9 * h;
            }
            if (b <= a3) {
                break;
            }
            a0 = sc;
            sc = a2;
            a2 = a3;
            y0 = y1;
            y1 = y2;
            y2 = y3;
        }
        return [x, y];
    }
    /**
     * Determine all roots of a polynomial with real or complex coefficients by using the
     * iterative method attributed to Weierstrass, Durand, Kerner, Aberth, and Ehrlich. In particular,
     * the iteration method with cubic convergence is used that is usually attributed to Ehrlich-Aberth.
     * <p>
     * The returned roots are sorted with respect to their real values.
     * <p> This method makes use of the JSXGraph classes {@link JXG.Complex} and {@link C. to handle
     * complex numbers.
     *
     * @param {Array} a Array of coefficients of the polynomial a[0] + a[1]*x+ a[2]*x**2...
     * The coefficients are of type Number or JXG.Complex.
     * @param {Number} [deg] Optional degree of the polynomial. Otherwise all entries are taken, with
     * leading zeros removed.
     * @param {Number} [tol=Number.EPSILON] Approximation tolerance
     * @param {Number} [max_it=30] Maximum number of iterations
     * @param {Array} [initial_values=null] Array of initial values for the roots. If not given,
     * starting values are determined by the method of Ozawa.
     * @returns {Array} Array of complex numbers (of JXG.Complex) approximating the roots of the polynomial.
     * @memberof JXG.Math.Numerics
     * @see JXG.Complex
     * @see JXG.C
     *
     * @example
     * // Polynomial p(z) = -1 + 1z^2
     * var i, roots,
     *     p = [-1, 0, 1];
     *
     * roots = JXG.Math.Numerics.polzeros(p);
     * for (i = 0; i < roots.length; i++) {
     *     console.log(i, roots[i].toString());
     * }
     * // Output:
     *   0 -1 + -3.308722450212111e-24i
     *   1 1 + 0i
     *
     * @example
     * // Polynomial p(z) = -1 + 3z - 9z^2 + z^3 - 8z^6 + 9z^7 - 9z^8 + z^9
     * var i, roots,
     *     p = [-1, 3, -9, 1, 0, 0, -8, 9, -9, 1];
     *
     * roots = JXG.Math.Numerics.polzeros(p);
     * for (i = 0; i < roots.length; i++) {
     *     console.log(i, roots[i].toString());
     * }
     * // Output:
     * 0 -0.7424155888401961 + 0.4950476539211721i
     * 1 -0.7424155888401961 + -0.4950476539211721i
     * 2 0.16674869833354108 + 0.2980502714610669i
     * 3 0.16674869833354108 + -0.29805027146106694i
     * 4 0.21429002063640837 + 1.0682775088132996i
     * 5 0.21429002063640842 + -1.0682775088132999i
     * 6 0.861375497926218 + -0.6259177003583295i
     * 7 0.8613754979262181 + 0.6259177003583295i
     * 8 8.000002743888055 + -1.8367099231598242e-40i
     *
     */
    static polzeros(coeffs, deg, tol, max_it, initial_values) {
    }
    /**
     * Horner method to evaluate reciprocal polynomial or the derivative thereof for complex numbers,
     * i.e. coefficients and variable are complex.
     * @function
     * @param {Array} a Array of complex coefficients of the polynomial a[0] + a[1]*x+ a[2]*x**2...
     * @param {JXG.Complex} z Value for which the reciprocal polynomial will be evaluated.
     * @param {Boolean} [derivative=false] If true the derivative will be evaluated.
     * @ignore
     */
    static hornerRec(a, x, derivative) {
        var i, s, n = a.length - 1;
        derivative = derivative || false;
        if (derivative) {
            // s = n * a_0
            s = C.mult(n, a[0]);
            for (i = n - 1; i > 0; i--) {
                // s = s * x + i * a_{n-i}
                s.mult(x);
                s.add(C.mult(a[n - i], i));
            }
        }
        else {
            // s = a_0
            s = C.copy(a[0]);
            for (i = n - 1; i >= 0; i--) {
                // s = s * x + a_{n-i}
                s.mult(x);
                s.add(a[n - i]);
            }
        }
        return s;
    }
    ///////////// references HornerComplex which is not independent
    // /**
    //  * Determine start values for the Aberth iteration, see
    //  * Ozawa, "An experimental study of the starting values
    //  * of the Durand-Kerner-Aberth iteration" (1995).
    //  *
    //  * @function
    //  * @param {Array} a Array of complex coefficients of the polynomial a[0] + a[1]*x+ a[2]*x**2...
    //  * @returns {Array} Array Initial values for the roots.
    //  * @ignore
    //  */
    // static initial_guess = function (a) {
    //     var i, r,
    //         n = a.length - 1, // degree
    //         alpha1 = Math.PI * 2 / n,
    //         alpha0 = Math.PI / n * 0.5,
    //         b, z,
    //         init = [];
    //     // From Ozawa, "An experimental study of the starting values
    //     // of the Durand-Kerner-Aberth iteration" (1995)
    //     // b is the arithmetic mean of the roots.
    //     // With is Vieta's formula <https://en.wikipedia.org/wiki/Vieta%27s_formulas>
    //     //   b = -a_{n-1} / (n * a_n)
    //     b = C.mult(-1, a[n - 1]);
    //     b.div(C.mult(n, a[n]));
    //     // r is the geometric mean of the deviations |b - root_i|.
    //     // Using
    //     //   p(z) = a_n prod(z - root_i)
    //     // and therefore
    //     //   |p(b)| = |a_n| prod(|b - root_i|)
    //     // we arrive at:
    //     //   r = |p(b)/a_n|^(1/n)
    //     z = C.div(hornerComplex(a, b), a[n]);
    //     r = Math.pow(C.abs(z), 1 / n);
    //     if (r === 0) { r = 1; }
    //     for (i = 0; i < n; i++) {
    //         a = new JXG.Complex(r * Math.cos(alpha1 * i + alpha0), r * Math.sin(alpha1 * i + alpha0));
    //         init[i] = C.add(b, a);
    //     }
    //     return init;
    // }
    ////////////// reference horner, which is not an independent function
    // /**
    //  * Ehrlich-Aberth iteration. The stopping criterion is from
    //  * D.A. Bini, "Numerical computation of polynomial zeros
    //  * by means of Aberths's method", Numerical Algorithms (1996).
    //  *
    //  * @function
    //  * @param {Array} a Array of complex coefficients of the polynomial a[0] + a[1]*x+ a[2]*x**2...
    //  * @param {Number} mu Machine precision
    //  * @param {Number} max_it Maximum number of iterations
    //  * @param {Array} z Initial guess for the roots. Will be changed in place.
    //  * @returns {Number} Number of iterations
    //  * @ignore
    //  */
    // static aberthIteration = (cc, mu, max_it, z)=> {
    //     var k, i, j,
    //         done:boolean[] = [],
    //         cr:number[] = [],
    //         gamma, x,
    //         done_sum = 0,
    //         num, denom, s, pp,
    //         n = z.length;
    //     for (i = 0; i < n; i++) {
    //         done.push(false);
    //     }
    //     for (i = 0; i < cc.length; i++) {
    //         cr.push(C.abs(cc[i]) * (4 * i + 1));
    //     }
    //     for (k = 0; k < max_it && done_sum < n; k++) {
    //         for (i = 0; i < n; i++) {
    //             if (done[i]) {
    //                 continue;
    //             }
    //             num = this.hornerComplex(cc, z[i]);
    //             x = C.abs(z[i]);
    //             // Stopping criterion by D.A. Bini
    //             // "Numerical computation of polynomial zeros
    //             // by means of Aberths's method", Numerical Algorithms (1996).
    //             //
    //             if (C.abs(num) < mu * this.horner(cr, x)) {
    //                 done[i] = true;
    //                 done_sum++;
    //                 if (done_sum === n) {
    //                     break;
    //                 }
    //                 continue;
    //             }
    //             // num = P(z_i) / P'(z_i)
    //             if (x > 1) {
    //                 gamma = C.div(1, z[i]);
    //                 pp = this.hornerRec(cc, gamma, true);
    //                 pp.div(this.hornerRec(cc, gamma));
    //                 pp.mult(gamma);
    //                 num = C.sub(n, pp);
    //                 num = C.div(z[i], num);
    //             } else {
    //                 num.div(this.hornerComplex(cc, z[i], true));
    //             }
    //             // denom = sum_{i\neq j} 1 / (z_i  - z_j)
    //             denom = new Complex(0);
    //             for (j = 0; j < n; j++) {
    //                 if (j === i) {
    //                     continue;
    //                 }
    //                 s = C.sub(z[i], z[j]);
    //                 s = C.div(1, s);
    //                 denom.add(s);
    //             }
    //             // num = num / 1 - num * sum_{i\neq j} 1 / (z_i - z_j)
    //             denom.mult(num);
    //             denom = C.sub(1, denom);
    //             num.div(denom);
    //             // z_i = z_i - num
    //             z[i].sub(num);
    //         }
    //     }
    //     return k;
    // };
    /////////////////// TODO:  WHAT IS THIS ???
    //     tol = tol || Number.EPSILON;
    //     max_it = max_it || 30;
    //     le = coeffs.length;
    //     if(JXG.isNumber(deg) && deg >= 0 && deg < le - 1) {
    //     le = deg + 1;
    // }
    // // Convert coefficient array to complex numbers
    // for (i = 0; i < le; i++) {
    //     cc.push(new JXG.Complex(coeffs[i]));
    // }
    // // Search for (multiple) roots at x=0
    // for (i = 0; i < le; i++) {
    //     if (cc[i].real !== 0 || cc[i].imaginary !== 0) {
    //         off = i;
    //         break;
    //     }
    // }
    // // Deflate root x=0, store roots at x=0 in obvious
    // for (i = 0; i < off; i++) {
    //     obvious.push(new JXG.Complex(0));
    // }
    // cc = cc.slice(off);
    // le = cc.length;
    // // Remove leading zeros from the coefficient array
    // for (i = le - 1; i >= 0; i--) {
    //     if (cc[i].real !== 0 || cc[i].imaginary !== 0) {
    //         break;
    //     }
    //     cc.pop();
    // }
    // le = cc.length;
    // if (le === 0) {
    //     return [];
    // }
    // // From now on we can assume that the
    // // constant coefficient and the leading coefficient
    // // are not zero.
    // if (initial_values) {
    //     for (i = 0; i < le - 1; i++) {
    //         roots.push(new JXG.Complex(initial_values[i]));
    //     }
    // } else {
    //     roots = initial_guess(cc);
    // }
    // it = aberthIteration(cc, tol, max_it, roots);
    // // Append the roots at x=0
    // roots = obvious.concat(roots);
    // if (debug) {
    //     console.log("Iterations:", it);
    //     console.log('Roots:');
    //     for (i = 0; i < roots.length; i++) {
    //         console.log(i, roots[i].toString(), C.abs(hornerComplex(cc, roots[i])));
    //     }
    // }
    // // Sort roots according to their real part
    // roots.sort(function (a, b) {
    //     if (a.real < b.real) {
    //         return -1;
    //     }
    //     if (a.real > b.real) {
    //         return 1;
    //     }
    //     return 0;
    // });
    // return roots;
    //     }
    /**
     * Implements the Ramer-Douglas-Peucker algorithm.
     * It discards points which are not necessary from the polygonal line defined by the point array
     * pts. The computation is done in screen coordinates.
     * Average runtime is O(nlog(n)), worst case runtime is O(n^2), where n is the number of points.
     * @param {Array} pts Array of {@link JXG.Coords}
     * @param {Number} eps If the absolute value of a given number <tt>x</tt> is smaller than <tt>eps</tt> it is considered to be equal <tt>0</tt>.
     * @returns {Array} An array containing points which represent an apparently identical curve as the points of pts do, but contains fewer points.
     * @memberof JXG.Math.Numerics
     */
    static RamerDouglasPeucker(pts, eps) {
        var allPts = [], newPts = [], i, k, len, endless = true;
        /**
         * findSplit() is a subroutine of {@link JXG.Math.Numerics.RamerDouglasPeucker}.
         * It searches for the point between index i and j which
         * has the largest distance from the line between the points i and j.
         * @param {Array} pts Array of {@link JXG.Coords}
         * @param {Number} i Index of a point in pts
         * @param {Number} j Index of a point in pts
         * @ignore
         * @private
         */
        let findSplit = function (pts, i, j) {
            var d, k, ci, cj, ck, x0, y0, x1, y1, den, lbda, eps = JSXMath.eps * JSXMath.eps, huge = 10000, dist = 0, f = i;
            if (j - i < 2) {
                return [-1, 0];
            }
            ci = pts[i].scrCoords;
            cj = pts[j].scrCoords;
            if (isNaN(ci[1]) || isNaN(ci[2])) {
                return [NaN, i];
            }
            if (isNaN(cj[1]) || isNaN(cj[2])) {
                return [NaN, j];
            }
            for (k = i + 1; k < j; k++) {
                ck = pts[k].scrCoords;
                if (isNaN(ck[1]) || isNaN(ck[2])) {
                    return [NaN, k];
                }
                x0 = ck[1] - ci[1];
                y0 = ck[2] - ci[2];
                x1 = cj[1] - ci[1];
                y1 = cj[2] - ci[2];
                x0 = x0 === Infinity ? huge : x0;
                y0 = y0 === Infinity ? huge : y0;
                x1 = x1 === Infinity ? huge : x1;
                y1 = y1 === Infinity ? huge : y1;
                x0 = x0 === -Infinity ? -huge : x0;
                y0 = y0 === -Infinity ? -huge : y0;
                x1 = x1 === -Infinity ? -huge : x1;
                y1 = y1 === -Infinity ? -huge : y1;
                den = x1 * x1 + y1 * y1;
                if (den > eps) {
                    lbda = (x0 * x1 + y0 * y1) / den;
                    if (lbda < 0.0) {
                        lbda = 0.0;
                    }
                    else if (lbda > 1.0) {
                        lbda = 1.0;
                    }
                    x0 = x0 - lbda * x1;
                    y0 = y0 - lbda * y1;
                    d = x0 * x0 + y0 * y0;
                }
                else {
                    lbda = 0.0;
                    d = x0 * x0 + y0 * y0;
                }
                if (d > dist) {
                    dist = d;
                    f = k;
                }
            }
            return [Math.sqrt(dist), f];
        };
        /**
         * RDP() is a private subroutine of {@link JXG.Math.Numerics.RamerDouglasPeucker}.
         * It runs recursively through the point set and searches the
         * point which has the largest distance from the line between the first point and
         * the last point. If the distance from the line is greater than eps, this point is
         * included in our new point set otherwise it is discarded.
         * If it is taken, we recursively apply the subroutine to the point set before
         * and after the chosen point.
         * @param {Array} pts Array of {@link JXG.Coords}
         * @param {Number} i Index of an element of pts
         * @param {Number} j Index of an element of pts
         * @param {Number} eps If the absolute value of a given number <tt>x</tt> is smaller than <tt>eps</tt> it is considered to be equal <tt>0</tt>.
         * @param {Array} newPts Array of {@link JXG.Coords}
         * @ignore
         * @private
         */
        let RDP = function (pts, i, j, eps, newPts) {
            var result = findSplit(pts, i, j), k = result[1];
            if (isNaN(result[0])) {
                RDP(pts, i, k - 1, eps, newPts);
                newPts.push(pts[k]);
                do {
                    ++k;
                } while (k <= j && isNaN(pts[k].scrCoords[1] + pts[k].scrCoords[2]));
                if (k <= j) {
                    newPts.push(pts[k]);
                }
                RDP(pts, k + 1, j, eps, newPts);
            }
            else if (result[0] > eps) {
                RDP(pts, i, k, eps, newPts);
                RDP(pts, k, j, eps, newPts);
            }
            else {
                newPts.push(pts[j]);
            }
        };
        len = pts.length;
        i = 0;
        while (endless) {
            // Search for the next point without NaN coordinates
            while (i < len && isNaN(pts[i].scrCoords[1] + pts[i].scrCoords[2])) {
                i += 1;
            }
            // Search for the next position of a NaN point
            k = i + 1;
            while (k < len && !isNaN(pts[k].scrCoords[1] + pts[k].scrCoords[2])) {
                k += 1;
            }
            k--;
            // Only proceed if something is left
            if (i < len && k > i) {
                newPts = [];
                newPts[0] = pts[i];
                RDP(pts, i, k, eps, newPts);
                allPts = allPts.concat(newPts);
            }
            if (i >= len) {
                break;
            }
            // Push the NaN point
            if (k < len - 1) {
                allPts.push(pts[k + 1]);
            }
            i = k + 1;
        }
        return allPts;
    }
    /**
     * Old name for the implementation of the Ramer-Douglas-Peucker algorithm.
     * @deprecated Use {@link JXG.Math.Numerics.RamerDouglasPeucker}
     * @memberof JXG.Math.Numerics
     */
    static RamerDouglasPeuker(pts, eps) {
        console.warn("deprecated RamerDouglasPeuker(), use RamerDouglasPeucker()");
        return this.RamerDouglasPeucker(pts, eps);
    }
    /**
     * Implements the Visvalingam-Whyatt algorithm.
     * See M. Visvalingam, J. D. Whyatt:
     * "Line generalisation by repeated elimination of the smallest area", C.I.S.R.G Discussion paper 10, July 1992
     *
     * The algorithm discards points which are not necessary from the polygonal line defined by the point array
     * pts (consisting of type JXG.Coords).
     * @param {Array} pts Array of {@link JXG.Coords}
     * @param {Number} numPoints Number of remaining intermediate points. The first and the last point of the original points will
     *    be taken in any case.
     * @returns {Array} An array containing points which approximates the curve defined by pts.
     * @memberof JXG.Math.Numerics
     *
     * @example
     *     var i, p = [];
     *     for (i = 0; i < 5; ++i) {
     *         p.push(board.create('point', [Math.random() * 12 - 6, Math.random() * 12 - 6]));
     *     }
     *
     *     // Plot a cardinal spline curve
     *     var splineArr = JXG.Math.Numerics.CardinalSpline(p, 0.5);
     *     var cu1 = board.create('curve', splineArr, {strokeColor: 'green'});
     *
     *     var c = board.create('curve', [[0],[0]], {strokeWidth: 2, strokeColor: 'black'});
     *     c.updateDataArray = function() {
     *         var i, len, points;
     *
     *         // Reduce number of intermediate points with Visvakingam-Whyatt to 6
     *         points = JXG.Math.Numerics.Visvalingam(cu1.points, 6);
     *         // Plot the remaining points
     *         len = points.length;
     *         this.dataX = [];
     *         this.dataY = [];
     *         for (i = 0; i < len; i++) {
     *             this.dataX.push(points[i].usrCoords[1]);
     *             this.dataY.push(points[i].usrCoords[2]);
     *         }
     *     };
     *     board.update();
     *
     * </pre><div id="JXGce0cc55c-b592-11e6-8270-104a7d3be7eb" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGce0cc55c-b592-11e6-8270-104a7d3be7eb',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *
     *         var i, p = [];
     *         for (i = 0; i < 5; ++i) {
     *             p.push(board.create('point', [Math.random() * 12 - 6, Math.random() * 12 - 6]));
     *         }
     *
     *         // Plot a cardinal spline curve
     *         var splineArr = JXG.Math.Numerics.CardinalSpline(p, 0.5);
     *         var cu1 = board.create('curve', splineArr, {strokeColor: 'green'});
     *
     *         var c = board.create('curve', [[0],[0]], {strokeWidth: 2, strokeColor: 'black'});
     *         c.updateDataArray = function() {
     *             var i, len, points;
     *
     *             // Reduce number of intermediate points with Visvakingam-Whyatt to 6
     *             points = JXG.Math.Numerics.Visvalingam(cu1.points, 6);
     *             // Plot the remaining points
     *             len = points.length;
     *             this.dataX = [];
     *             this.dataY = [];
     *             for (i = 0; i < len; i++) {
     *                 this.dataX.push(points[i].usrCoords[1]);
     *                 this.dataY.push(points[i].usrCoords[2]);
     *             }
     *         };
     *         board.update();
     *
     *     })();
     *
     * </script><pre>
     *
     */
    static Visvalingam(pts, numPoints) {
        var i, len, vol, lastVol, linkedList = [], heap = [], points = [], lft, rt, lft2, rt2, nodeObj;
        len = pts.length;
        // At least one intermediate point is needed
        if (len <= 2) {
            return pts;
        }
        // Fill the linked list
        // Add first point to the linked list
        linkedList[0] = {
            used: true,
            lft: null,
            node: null,
            rt: null
        };
        // Add all intermediate points to the linked list,
        // whose triangle area is nonzero.
        lft = 0;
        for (i = 1; i < len - 1; i++) {
            vol = Math.abs(Numerics.det([
                pts[i - 1].usrCoords,
                pts[i].usrCoords,
                pts[i + 1].usrCoords
            ]));
            if (!isNaN(vol)) {
                nodeObj = {
                    v: vol,
                    idx: i
                };
                heap.push(nodeObj);
                linkedList[i] = {
                    used: true,
                    lft: lft,
                    node: nodeObj,
                    rt: null
                };
                linkedList[lft].rt = i;
                lft = i;
            }
        }
        // Add last point to the linked list
        linkedList[len - 1] = {
            used: true,
            rt: null,
            lft: lft,
            node: null
        };
        linkedList[lft].rt = len - 1;
        // Remove points until only numPoints intermediate points remain
        lastVol = -Infinity;
        while (heap.length > numPoints) {
            // Sort the heap with the updated volume values
            heap.sort((a, b) => {
                // descending sort
                return b.v - a.v;
            });
            // Remove the point with the smallest triangle
            i = heap.pop().idx; // we guarantee not null
            linkedList[i].used = false;
            lastVol = linkedList[i].node.v; // we guarantee not null
            // Update the pointers of the linked list
            lft = linkedList[i].lft;
            rt = linkedList[i].rt;
            linkedList[lft].rt = rt;
            linkedList[rt].lft = lft;
            // Update the values for the volumes in the linked list
            lft2 = linkedList[lft].lft;
            if (lft2 !== null) {
                vol = Math.abs(Numerics.det([
                    pts[lft2].usrCoords,
                    pts[lft].usrCoords,
                    pts[rt].usrCoords
                ]));
                linkedList[lft].node.v = vol >= lastVol ? vol : lastVol; // we guarantee not nulll
            }
            rt2 = linkedList[rt].rt;
            if (rt2 !== null) {
                vol = Math.abs(Numerics.det([
                    pts[lft].usrCoords,
                    pts[rt].usrCoords,
                    pts[rt2].usrCoords
                ]));
                linkedList[rt].node.v = vol >= lastVol ? vol : lastVol; // we guarantee not null
            }
        }
        // Return an array with the remaining points
        i = 0;
        points = [pts[i]];
        do {
            i = linkedList[i].rt;
            points.push(pts[i]);
        } while (linkedList[i].rt !== null);
        return points;
    }
}
/**
 * Maximum number of iterations in {@link JXG.Math.Numerics.fzero} and
 * {@link JXG.Math.Numerics.chandrupatla}
 * @type Number
 * @default 80
 * @memberof JXG.Math.Numerics
 */
Numerics.maxIterationsRoot = 80;
/**
 * Maximum number of iterations in {@link JXG.Math.Numerics.fminbr}
 * @type Number
 * @default 500
 * @memberof JXG.Math.Numerics
 */
Numerics.maxIterationsMinimize = 500;
/**
 * Horner method to evaluate real polynomial at a real value.
 * @function
 * @param {Array} a Array of real coefficients of the polynomial a[0] + a[1]*x+ a[2]*x**2...
 * @param {Number} z Value for which the polynomial will be evaluated.
 * @ignore
 */
Numerics.horner = function (a, x) {
    var i, s, n = a.length - 1;
    s = a[n];
    for (i = n - 1; i >= 0; i--) {
        s = s * x + a[i];
    }
    return s;
};

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */
/**
 * The JXG.Expect namespace provides method to normalize access on coordinates,
 * i.e. provides utilities for parameter magic by normalizing multi-type parameters.
 * @namespace
 */
class Expect {
    /**
     * Apply an expect method on every element of an array.
     *
     * @param {Array} a
     * @param {function} format
     * @param {Boolean} [copy=false]
     *
     * @returns {Array}
     */
    static each(a, format, copy = false) {
        var i, len, r = [];
        if (Type.exists(a.length)) {
            len = a.length;
            for (i = 0; i < len; i++) {
                r.push(format.call(this, a[i], copy));
            }
        }
        return r;
    }
    /**
     * Normalize points and coord objects into a coord object.
     *
     * @param {JXG.Point|JXG.Coords} c
     * @param {Boolean} [copy=false] Return a copy, not a reference
     *
     * @returns {JXG.Coords}
     */
    static coords(c, copy = false) {
        var coord = c;
        if (c && c.elementClass === OBJECT_CLASS.POINT) {
            coord = c.coords;
        }
        else if (c.usrCoords && c.scrCoords && c.usr2screen) {
            coord = c;
        }
        if (copy) {
            coord = new Coords$1(COORDS_BY.USER, coord.usrCoords, coord.board);
        }
        return coord;
    }
    /**
     * Normalize points, coordinate arrays and coord objects into a coordinate array.
     *
     * @param {JXG.Point|JXG.Coords|Array} c
     * @param {Boolean} [copy=false] Return a copy, not a reference
     *
     * @returns {Array} Homogeneous coordinates
     */
    static coordsArray(c, copy = false) {
        var coord;
        if (!Array.isArray(c)) {
            coord = this.coords(c).usrCoords;
        }
        else {
            coord = c;
        }
        if (coord.length < 3) {
            coord.unshift(1);
        }
        if (copy) {
            coord = [coord[0], coord[1], coord[2]];
        }
        return coord;
    }
}

/*
 Copyright 2008-2025
 Matthias Ehmann,
 Carsten Miller,
 Reinhard Oldenburg,
 Andreas Walter,
 Alfred Wassermann

 This file is part of JSXGraph.

 JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

 You can redistribute it and/or modify it under the terms of the

 * GNU Lesser General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version
 OR
 * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

 JSXGraph is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public License and
 the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
 and <https://opensource.org/licenses/MIT/>.

 This is a port of jcobyla

 - to JavaScript by Reihard Oldenburg and
 - to JSXGraph by Alfred Wassermann
 - optimized by Andreas Walter
 */
/*
 * jcobyla
 *
 * The MIT License
 *
 * Copyright (c) 2012 Anders Gustafsson, Cureos AB.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
 * FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Remarks:
 *
 * The original Fortran 77 version of this code was by Michael Powell (M.J.D.Powell @ damtp.cam.ac.uk)
 * The Fortran 90 version was by Alan Miller (Alan.Miller @ vic.cmis.csiro.au). Latest revision - 30 October 1998
 */
/**
 * Constrained Optimization BY Linear Approximation in Java.
 *
 * COBYLA2 is an implementation of Powell's nonlinear derivative free constrained optimization that uses
 * a linear approximation approach. The algorithm is a sequential trust region algorithm that employs linear
 * approximations to the objective and constraint functions, where the approximations are formed by linear
 * interpolation at n + 1 points in the space of the variables and tries to maintain a regular shaped simplex
 * over iterations.
 *
 * It solves nonsmooth NLP with a moderate number of variables (about 100). Inequality constraints only.
 *
 * The initial point X is taken as one vertex of the initial simplex with zero being another, so, X should
 * not be entered as the zero vector.
 *
 * @author Anders Gustafsson, Cureos AB. Translation to Javascript by Reinhard Oldenburg, Goethe-University
 */
/*global JXG: true, define: true*/
/*jslint nomen: true, plusplus: true, continue: true*/
// import {Type} from "../utils/type.js";
/**
 * The JXG.Math.Nlp namespace holds numerical algorithms for non-linear optimization.
 * @name JXG.Math.Nlp
 * @namespace
 *
 */
const Nlp = {
    arr: function (n) {
        // Is 0 initialized
        return new Float64Array(n);
    },
    arr2: function (n, m) {
        var i = 0, a = new Array(n);
        while (i < n) {
            a[i] = this.arr(m);
            i++;
        }
        return a;
    },
    arraycopy: function (x, a, iox, b, n) {
        var i = 0;
        while (i < n) {
            iox[i + b] = x[i + a];
            i++;
        }
    },
    lastNumberOfEvaluations: 0,
    GetLastNumberOfEvaluations: function () {
        return this.lastNumberOfEvaluations;
    },
    // status Variables
    Normal: 0,
    MaxIterationsReached: 1,
    DivergingRoundingErrors: 2,
    /**
     * Minimizes the objective function F with respect to a set of inequality constraints CON,
     * and returns the optimal variable array. F and CON may be non-linear, and should preferably be smooth.
     * Calls {@link JXG.Math.Nlp#cobylb}.
     *
     * @param calcfc Interface implementation for calculating objective function and constraints.
     * @param n Number of variables.
     * @param m Number of constraints.
     * @param x On input initial values of the variables (zero-based array). On output
     * optimal values of the variables obtained in the COBYLA minimization.
     * @param rhobeg Initial size of the simplex.
     * @param rhoend Final value of the simplex.
     * @param iprint Print level, 0 <= iprint <= 3, where 0 provides no output and
     * 3 provides full output to the console.
     * @param maxfun Maximum number of function evaluations before terminating.
     * @param [testForRoundingErrors=false]
     * @returns {Number} Exit status of the COBYLA2 optimization.
     */
    FindMinimum: function (calcfc, n, m, x, rhobeg, rhoend, iprint, maxfun, testForRoundingErrors) {
        // CobylaExitStatus FindMinimum(final Calcfc calcfc, int n, int m, double[] x, double rhobeg, double rhoend, int iprint, int maxfun)
        //     This subroutine minimizes an objective function F(X) subject to M
        //     inequality constraints on X, where X is a vector of variables that has
        //     N components.  The algorithm employs linear approximations to the
        //     objective and constraint functions, the approximations being formed by
        //     linear interpolation at N+1 points in the space of the variables.
        //     We regard these interpolation points as vertices of a simplex.  The
        //     parameter RHO controls the size of the simplex and it is reduced
        //     automatically from RHOBEG to RHOEND.  For each RHO the subroutine tries
        //     to achieve a good vector of variables for the current size, and then
        //     RHO is reduced until the value RHOEND is reached.  Therefore RHOBEG and
        //     RHOEND should be set to reasonable initial changes to and the required
        //     accuracy in the variables respectively, but this accuracy should be
        //     viewed as a subject for experimentation because it is not guaranteed.
        //     The subroutine has an advantage over many of its competitors, however,
        //     which is that it treats each constraint individually when calculating
        //     a change to the variables, instead of lumping the constraints together
        //     into a single penalty function.  The name of the subroutine is derived
        //     from the phrase Constrained Optimization BY Linear Approximations.
        //     The user must set the values of N, M, RHOBEG and RHOEND, and must
        //     provide an initial vector of variables in X.  Further, the value of
        //     IPRINT should be set to 0, 1, 2 or 3, which controls the amount of
        //     printing during the calculation. Specifically, there is no output if
        //     IPRINT=0 and there is output only at the end of the calculation if
        //     IPRINT=1.  Otherwise each new value of RHO and SIGMA is printed.
        //     Further, the vector of variables and some function information are
        //     given either when RHO is reduced or when each new value of F(X) is
        //     computed in the cases IPRINT=2 or IPRINT=3 respectively. Here SIGMA
        //     is a penalty parameter, it being assumed that a change to X is an
        //     improvement if it reduces the merit function
        //                F(X)+SIGMA*MAX(0.0, - C1(X), - C2(X),..., - CM(X)),
        //     where C1,C2,...,CM denote the constraint functions that should become
        //     nonnegative eventually, at least to the precision of RHOEND. In the
        //     printed output the displayed term that is multiplied by SIGMA is
        //     called MAXCV, which stands for 'MAXimum Constraint Violation'.  The
        //     argument ITERS is an integer variable that must be set by the user to a
        //     limit on the number of calls of CALCFC, the purpose of this routine being
        //     given below.  The value of ITERS will be altered to the number of calls
        //     of CALCFC that are made.
        //     In order to define the objective and constraint functions, we require
        //     a subroutine that has the name and arguments
        //                SUBROUTINE CALCFC (N,M,X,F,CON)
        //                DIMENSION X(:),CON(:)  .
        //     The values of N and M are fixed and have been defined already, while
        //     X is now the current vector of variables. The subroutine should return
        //     the objective and constraint functions at X in F and CON(1),CON(2),
        //     ...,CON(M).  Note that we are trying to adjust X so that F(X) is as
        //     small as possible subject to the constraint functions being nonnegative.
        // Local variables
        var mpp = m + 2, status, 
        // Internal base-1 X array
        iox = this.arr(n + 1), that = this, fcalcfc;
        this.lastNumberOfEvaluations = 0;
        if (testForRoundingErrors) {
            console.log("Experimental feature 'testForRoundingErrors' is activated.");
        }
        iox[0] = 0.0;
        this.arraycopy(x, 0, iox, 1, n);
        // Internal representation of the objective and constraints calculation method,
        // accounting for that X and CON arrays in the cobylb method are base-1 arrays.
        fcalcfc = function (n, m, thisx, con) {
            // int n, int m, double[] x, double[] con
            var ix = that.arr(n), ocon, f;
            that.lastNumberOfEvaluations = that.lastNumberOfEvaluations + 1;
            that.arraycopy(thisx, 1, ix, 0, n);
            ocon = that.arr(m);
            f = calcfc(n, m, ix, ocon);
            that.arraycopy(ocon, 0, con, 1, m);
            return f;
        };
        status = this.cobylb(fcalcfc, n, m, mpp, iox, rhobeg, rhoend, iprint, maxfun, testForRoundingErrors);
        this.arraycopy(iox, 1, x, 0, n);
        return status;
    },
    //    private static CobylaExitStatus cobylb(Calcfc calcfc, int n, int m, int mpp, double[] x,
    //      double rhobeg, double rhoend, int iprint, int maxfun)
    /**
     * JavaScript implementation of the non-linear optimization method COBYLA.
     * @param {Function} calcfc
     * @param {Number} n
     * @param {Number} m
     * @param {Number} mpp
     * @param {Number} x
     * @param {Number} rhobeg
     * @param {Number} rhoend
     * @param {Number} iprint
     * @param {Number} maxfun
     * @param {Boolean} [testForRoundingErrors=false]
     * @returns {Number} Exit status of the COBYLA2 optimization
     */
    cobylb: function (calcfc, n, m, mpp, x, rhobeg, rhoend, iprint, maxfun, testForRoundingErrors) {
        // calcf ist funktion die aufgerufen wird wie calcfc(n, m, ix, ocon)
        // N.B. Arguments CON, SIM, SIMI, DATMAT, A, VSIG, VETA, SIGBAR, DX, W & IACT
        //      have been removed.
        //     Set the initial values of some parameters. The last column of SIM holds
        //     the optimal vertex of the current simplex, and the preceding N columns
        //     hold the displacements from the optimal vertex to the other vertices.
        //     Further, SIMI holds the inverse of the matrix that is contained in the
        //     first N columns of SIM.
        // Local variables
        var status = -1, alpha = 0.25, beta = 2.1, gamma = 0.5, delta = 1.1, f = 0.0, resmax = 0.0, total, np = n + 1, mp = m + 1, rho = rhobeg, parmu = 0.0, iflag = false, ifull = false, parsig = 0.0, prerec = 0.0, prerem = 0.0, con = this.arr(1 + mpp), sim = this.arr2(1 + n, 1 + np), simi = this.arr2(1 + n, 1 + n), datmat = this.arr2(1 + mpp, 1 + np), a = this.arr2(1 + n, 1 + mp), vsig = this.arr(1 + n), veta = this.arr(1 + n), sigbar = this.arr(1 + n), dx = this.arr(1 + n), w = this.arr(1 + n), i, j, k, l, temp, tempa, nfvals, jdrop, ibrnch, skipVertexIdent, phimin, nbest, error, pareta, wsig, weta, cvmaxp, cvmaxm, dxsign, resnew, barmu, phi, vmold, vmnew, trured, ratio, edgmax, cmin, cmax, denom, endless = true;
        if (iprint >= 2) {
            console.log("The initial value of RHO is " + rho + " and PARMU is set to zero.");
        }
        nfvals = 0;
        temp = 1.0 / rho;
        for (i = 1; i <= n; ++i) {
            sim[i][np] = x[i];
            sim[i][i] = rho;
            simi[i][i] = temp;
        }
        jdrop = np;
        ibrnch = false;
        //     Make the next call of the user-supplied subroutine CALCFC. These
        //     instructions are also used for calling CALCFC during the iterations of
        //     the algorithm.
        //alert("Iteration "+nfvals+" x="+x);
        L_40: do {
            if (nfvals >= maxfun && nfvals > 0) {
                status = this.MaxIterationsReached;
                break L_40;
            }
            ++nfvals;
            f = calcfc(n, m, x, con);
            resmax = 0.0;
            for (k = 1; k <= m; ++k) {
                resmax = Math.max(resmax, -con[k]);
            }
            //alert(    "   f="+f+"  resmax="+resmax);
            if (nfvals === iprint - 1 || iprint === 3) {
                this.PrintIterationResult(nfvals, f, resmax, x, n, iprint);
            }
            con[mp] = f;
            con[mpp] = resmax;
            //     Set the recently calculated function values in a column of DATMAT. This
            //     array has a column for each vertex of the current simplex, the entries of
            //     each column being the values of the constraint functions (if any)
            //     followed by the objective function and the greatest constraint violation
            //     at the vertex.
            skipVertexIdent = true;
            if (!ibrnch) {
                skipVertexIdent = false;
                for (i = 1; i <= mpp; ++i) {
                    datmat[i][jdrop] = con[i];
                }
                if (nfvals <= np) {
                    //     Exchange the new vertex of the initial simplex with the optimal vertex if
                    //     necessary. Then, if the initial simplex is not complete, pick its next
                    //     vertex and calculate the function values there.
                    if (jdrop <= n) {
                        if (datmat[mp][np] <= f) {
                            x[jdrop] = sim[jdrop][np];
                        }
                        else {
                            sim[jdrop][np] = x[jdrop];
                            for (k = 1; k <= mpp; ++k) {
                                datmat[k][jdrop] = datmat[k][np];
                                datmat[k][np] = con[k];
                            }
                            for (k = 1; k <= jdrop; ++k) {
                                sim[jdrop][k] = -rho;
                                temp = 0.0;
                                for (i = k; i <= jdrop; ++i) {
                                    temp -= simi[i][k];
                                }
                                simi[jdrop][k] = temp;
                            }
                        }
                    }
                    if (nfvals <= n) {
                        jdrop = nfvals;
                        x[jdrop] += rho;
                        continue L_40;
                    }
                }
                ibrnch = true;
            }
            L_140: do {
                L_550: do {
                    if (!skipVertexIdent) {
                        //     Identify the optimal vertex of the current simplex.
                        phimin = datmat[mp][np] + parmu * datmat[mpp][np];
                        nbest = np;
                        for (j = 1; j <= n; ++j) {
                            temp = datmat[mp][j] + parmu * datmat[mpp][j];
                            if (temp < phimin) {
                                nbest = j;
                                phimin = temp;
                            }
                            else if (temp === phimin &&
                                parmu === 0.0 &&
                                datmat[mpp][j] < datmat[mpp][nbest]) {
                                nbest = j;
                            }
                        }
                        //     Switch the best vertex into pole position if it is not there already,
                        //     and also update SIM, SIMI and DATMAT.
                        if (nbest <= n) {
                            for (i = 1; i <= mpp; ++i) {
                                temp = datmat[i][np];
                                datmat[i][np] = datmat[i][nbest];
                                datmat[i][nbest] = temp;
                            }
                            for (i = 1; i <= n; ++i) {
                                temp = sim[i][nbest];
                                sim[i][nbest] = 0.0;
                                sim[i][np] += temp;
                                tempa = 0.0;
                                for (k = 1; k <= n; ++k) {
                                    sim[i][k] -= temp;
                                    tempa -= simi[k][i];
                                }
                                simi[nbest][i] = tempa;
                            }
                        }
                        //     Make an error return if SIGI is a poor approximation to the inverse of
                        //     the leading N by N submatrix of SIG.
                        error = 0.0;
                        if (testForRoundingErrors) {
                            for (i = 1; i <= n; ++i) {
                                for (j = 1; j <= n; ++j) {
                                    temp =
                                        this.DOT_PRODUCT_ROW_COL(simi, i, sim, j, 1, n) -
                                            (i === j ? 1.0 : 0.0);
                                    // temp = this.DOT_PRODUCT(
                                    //     this.PART(this.ROW(simi, i), 1, n),
                                    //     this.PART(this.COL(sim, j), 1, n)
                                    // ) - (i === j ? 1.0 : 0.0);
                                    error = Math.max(error, Math.abs(temp));
                                }
                            }
                        }
                        if (error > 0.1) {
                            status = this.DivergingRoundingErrors;
                            break L_40;
                        }
                        //     Calculate the coefficients of the linear approximations to the objective
                        //     and constraint functions, placing minus the objective function gradient
                        //     after the constraint gradients in the array A. The vector W is used for
                        //     working space.
                        for (k = 1; k <= mp; ++k) {
                            con[k] = -datmat[k][np];
                            for (j = 1; j <= n; ++j) {
                                w[j] = datmat[k][j] + con[k];
                            }
                            for (i = 1; i <= n; ++i) {
                                a[i][k] =
                                    (k === mp ? -1 : 1.0) *
                                        this.DOT_PRODUCT_ROW_COL(w, -1, simi, i, 1, n);
                                // this.DOT_PRODUCT(this.PART(w, 1, n), this.PART(this.COL(simi, i), 1, n));
                            }
                        }
                        //     Calculate the values of sigma and eta, and set IFLAG = 0 if the current
                        //     simplex is not acceptable.
                        iflag = true;
                        parsig = alpha * rho;
                        pareta = beta * rho;
                        for (j = 1; j <= n; ++j) {
                            wsig = 0.0;
                            weta = 0.0;
                            for (k = 1; k <= n; ++k) {
                                wsig += simi[j][k] * simi[j][k];
                                weta += sim[k][j] * sim[k][j];
                            }
                            vsig[j] = 1.0 / Math.sqrt(wsig);
                            veta[j] = Math.sqrt(weta);
                            if (vsig[j] < parsig || veta[j] > pareta) {
                                iflag = false;
                            }
                        }
                        //     If a new vertex is needed to improve acceptability, then decide which
                        //     vertex to drop from the simplex.
                        if (!ibrnch && !iflag) {
                            jdrop = 0;
                            temp = pareta;
                            for (j = 1; j <= n; ++j) {
                                if (veta[j] > temp) {
                                    jdrop = j;
                                    temp = veta[j];
                                }
                            }
                            if (jdrop === 0) {
                                for (j = 1; j <= n; ++j) {
                                    if (vsig[j] < temp) {
                                        jdrop = j;
                                        temp = vsig[j];
                                    }
                                }
                            }
                            //     Calculate the step to the new vertex and its sign.
                            temp = gamma * rho * vsig[jdrop];
                            for (k = 1; k <= n; ++k) {
                                dx[k] = temp * simi[jdrop][k];
                            }
                            cvmaxp = 0.0;
                            cvmaxm = 0.0;
                            total = 0.0;
                            for (k = 1; k <= mp; ++k) {
                                // total = this.DOT_PRODUCT(this.PART(this.COL(a, k), 1, n), this.PART(dx, 1, n));
                                total = this.DOT_PRODUCT_ROW_COL(dx, -1, a, k, 1, n);
                                if (k < mp) {
                                    temp = datmat[k][np];
                                    cvmaxp = Math.max(cvmaxp, -total - temp);
                                    cvmaxm = Math.max(cvmaxm, total - temp);
                                }
                            }
                            dxsign = parmu * (cvmaxp - cvmaxm) > 2.0 * total ? -1 : 1.0;
                            //     Update the elements of SIM and SIMI, and set the next X.
                            temp = 0.0;
                            for (i = 1; i <= n; ++i) {
                                dx[i] = dxsign * dx[i];
                                sim[i][jdrop] = dx[i];
                                temp += simi[jdrop][i] * dx[i];
                            }
                            for (k = 1; k <= n; ++k) {
                                simi[jdrop][k] /= temp;
                            }
                            for (j = 1; j <= n; ++j) {
                                if (j !== jdrop) {
                                    // temp = this.DOT_PRODUCT(this.PART(this.ROW(simi, j), 1, n), this.PART(dx, 1, n));
                                    temp = this.DOT_PRODUCT_ROW_COL(simi, j, dx, -1, 1, n);
                                    for (k = 1; k <= n; ++k) {
                                        simi[j][k] -= temp * simi[jdrop][k];
                                    }
                                }
                                x[j] = sim[j][np] + dx[j];
                            }
                            continue L_40;
                        }
                        //     Calculate DX = x(*)-x(0).
                        //     Branch if the length of DX is less than 0.5*RHO.
                        ifull = this.trstlp(n, m, a, con, rho, dx);
                        if (!ifull) {
                            temp = 0.0;
                            for (k = 1; k <= n; ++k) {
                                temp += dx[k] * dx[k];
                            }
                            if (temp < 0.25 * rho * rho) {
                                ibrnch = true;
                                break L_550;
                            }
                        }
                        //     Predict the change to F and the new maximum constraint violation if the
                        //     variables are altered from x(0) to x(0) + DX.
                        total = 0.0;
                        resnew = 0.0;
                        con[mp] = 0.0;
                        for (k = 1; k <= mp; ++k) {
                            //total = con[k] - this.DOT_PRODUCT(this.PART(this.COL(a, k), 1, n), this.PART(dx, 1, n));
                            total = con[k] - this.DOT_PRODUCT_ROW_COL(dx, -1, a, k, 1, n);
                            if (k < mp) {
                                resnew = Math.max(resnew, total);
                            }
                        }
                        //     Increase PARMU if necessary and branch back if this change alters the
                        //     optimal vertex. Otherwise PREREM and PREREC will be set to the predicted
                        //     reductions in the merit function and the maximum constraint violation
                        //     respectively.
                        prerec = datmat[mpp][np] - resnew;
                        barmu = prerec > 0.0 ? total / prerec : 0.0;
                        if (parmu < 1.5 * barmu) {
                            parmu = 2.0 * barmu;
                            if (iprint >= 2) {
                                console.log("Increase in PARMU to " + parmu);
                            }
                            phi = datmat[mp][np] + parmu * datmat[mpp][np];
                            for (j = 1; j <= n; ++j) {
                                temp = datmat[mp][j] + parmu * datmat[mpp][j];
                                if (temp < phi ||
                                    (temp === phi &&
                                        parmu === 0.0 &&
                                        datmat[mpp][j] < datmat[mpp][np])) {
                                    continue L_140;
                                }
                            }
                        }
                        prerem = parmu * prerec - total;
                        //     Calculate the constraint and objective functions at x(*).
                        //     Then find the actual reduction in the merit function.
                        for (k = 1; k <= n; ++k) {
                            x[k] = sim[k][np] + dx[k];
                        }
                        ibrnch = true;
                        continue L_40;
                    }
                    skipVertexIdent = false;
                    vmold = datmat[mp][np] + parmu * datmat[mpp][np];
                    vmnew = f + parmu * resmax;
                    trured = vmold - vmnew;
                    if (parmu === 0.0 && f === datmat[mp][np]) {
                        prerem = prerec;
                        trured = datmat[mpp][np] - resmax;
                    }
                    //     Begin the operations that decide whether x(*) should replace one of the
                    //     vertices of the current simplex, the change being mandatory if TRURED is
                    //     positive. Firstly, JDROP is set to the index of the vertex that is to be
                    //     replaced.
                    ratio = trured <= 0.0 ? 1.0 : 0.0;
                    jdrop = 0;
                    for (j = 1; j <= n; ++j) {
                        // temp = Math.abs(this.DOT_PRODUCT(this.PART(this.ROW(simi, j), 1, n), this.PART(dx, 1, n)));
                        temp = Math.abs(this.DOT_PRODUCT_ROW_COL(simi, j, dx, -1, 1, n));
                        if (temp > ratio) {
                            jdrop = j;
                            ratio = temp;
                        }
                        sigbar[j] = temp * vsig[j];
                    }
                    //     Calculate the value of ell.
                    edgmax = delta * rho;
                    l = 0;
                    for (j = 1; j <= n; ++j) {
                        if (sigbar[j] >= parsig || sigbar[j] >= vsig[j]) {
                            temp = veta[j];
                            if (trured > 0.0) {
                                temp = 0.0;
                                for (k = 1; k <= n; ++k) {
                                    temp += Math.pow(dx[k] - sim[k][j], 2.0);
                                }
                                temp = Math.sqrt(temp);
                            }
                            if (temp > edgmax) {
                                l = j;
                                edgmax = temp;
                            }
                        }
                    }
                    if (l > 0) {
                        jdrop = l;
                    }
                    if (jdrop !== 0) {
                        //     Revise the simplex by updating the elements of SIM, SIMI and DATMAT.
                        temp = 0.0;
                        for (i = 1; i <= n; ++i) {
                            sim[i][jdrop] = dx[i];
                            temp += simi[jdrop][i] * dx[i];
                        }
                        for (k = 1; k <= n; ++k) {
                            simi[jdrop][k] /= temp;
                        }
                        for (j = 1; j <= n; ++j) {
                            if (j !== jdrop) {
                                // temp = this.DOT_PRODUCT(this.PART(this.ROW(simi, j), 1, n), this.PART(dx, 1, n));
                                temp = this.DOT_PRODUCT_ROW_COL(simi, j, dx, -1, 1, n);
                                for (k = 1; k <= n; ++k) {
                                    simi[j][k] -= temp * simi[jdrop][k];
                                }
                            }
                        }
                        for (k = 1; k <= mpp; ++k) {
                            datmat[k][jdrop] = con[k];
                        }
                        //     Branch back for further iterations with the current RHO.
                        if (trured > 0.0 && trured >= 0.1 * prerem) {
                            continue L_140;
                        }
                    }
                    // If we end up here, we drop out.
                } while (!endless);
                if (!iflag) {
                    ibrnch = false;
                    continue L_140;
                }
                if (rho <= rhoend) {
                    status = this.Normal;
                    break L_40;
                }
                //     Otherwise reduce RHO if it is not at its least value and reset PARMU.
                cmin = 0.0;
                cmax = 0.0;
                rho *= 0.5;
                if (rho <= 1.5 * rhoend) {
                    rho = rhoend;
                }
                if (parmu > 0.0) {
                    denom = 0.0;
                    for (k = 1; k <= mp; ++k) {
                        cmin = datmat[k][np];
                        cmax = cmin;
                        for (i = 1; i <= n; ++i) {
                            cmin = Math.min(cmin, datmat[k][i]);
                            cmax = Math.max(cmax, datmat[k][i]);
                        }
                        if (k <= m && cmin < 0.5 * cmax) {
                            temp = Math.max(cmax, 0.0) - cmin;
                            denom = denom <= 0.0 ? temp : Math.min(denom, temp);
                        }
                    }
                    if (denom === 0.0) {
                        parmu = 0.0;
                    }
                    else if (cmax - cmin < parmu * denom) {
                        parmu = (cmax - cmin) / denom;
                    }
                }
                if (iprint >= 2) {
                    console.log("Reduction in RHO to " + rho + "  and PARMU = " + parmu);
                }
                if (iprint === 2) {
                    this.PrintIterationResult(nfvals, datmat[mp][np], datmat[mpp][np], this.COL(sim, np), n, iprint);
                }
            } while (endless);
        } while (endless);
        switch (status) {
            case this.Normal:
                if (iprint >= 1) {
                    console.log("%nNormal return from subroutine COBYLA%n");
                }
                if (ifull) {
                    if (iprint >= 1) {
                        this.PrintIterationResult(nfvals, f, resmax, x, n, iprint);
                    }
                    return status;
                }
                break;
            case this.MaxIterationsReached:
                if (iprint >= 1) {
                    console.log("%nReturn from subroutine COBYLA because the MAXFUN limit has been reached.%n");
                }
                break;
            case this.DivergingRoundingErrors:
                if (iprint >= 1) {
                    console.log("%nReturn from subroutine COBYLA because rounding errors are becoming damaging.%n");
                }
                break;
        }
        for (k = 1; k <= n; ++k) {
            x[k] = sim[k][np];
        }
        f = datmat[mp][np];
        resmax = datmat[mpp][np];
        if (iprint >= 1) {
            this.PrintIterationResult(nfvals, f, resmax, x, n, iprint);
        }
        return status;
    },
    trstlp: function (n, m, a, b, rho, dx) {
        //(int n, int m, double[][] a, double[] b, double rho, double[] dx)
        // N.B. Arguments Z, ZDOTA, VMULTC, SDIRN, DXNEW, VMULTD & IACT have been removed.
        //     This subroutine calculates an N-component vector DX by applying the
        //     following two stages. In the first stage, DX is set to the shortest
        //     vector that minimizes the greatest violation of the constraints
        //       A(1,K)*DX(1)+A(2,K)*DX(2)+...+A(N,K)*DX(N) .GE. B(K), K = 2,3,...,M,
        //     subject to the Euclidean length of DX being at most RHO. If its length is
        //     strictly less than RHO, then we use the resultant freedom in DX to
        //     minimize the objective function
        //              -A(1,M+1)*DX(1) - A(2,M+1)*DX(2) - ... - A(N,M+1)*DX(N)
        //     subject to no increase in any greatest constraint violation. This
        //     notation allows the gradient of the objective function to be regarded as
        //     the gradient of a constraint. Therefore the two stages are distinguished
        //     by MCON .EQ. M and MCON .GT. M respectively. It is possible that a
        //     degeneracy may prevent DX from attaining the target length RHO. Then the
        //     value IFULL = 0 would be set, but usually IFULL = 1 on return.
        //
        //     In general NACT is the number of constraints in the active set and
        //     IACT(1),...,IACT(NACT) are their indices, while the remainder of IACT
        //     contains a permutation of the remaining constraint indices.  Further, Z
        //     is an orthogonal matrix whose first NACT columns can be regarded as the
        //     result of Gram-Schmidt applied to the active constraint gradients.  For
        //     J = 1,2,...,NACT, the number ZDOTA(J) is the scalar product of the J-th
        //     column of Z with the gradient of the J-th active constraint.  DX is the
        //     current vector of variables and here the residuals of the active
        //     constraints should be zero. Further, the active constraints have
        //     nonnegative Lagrange multipliers that are held at the beginning of
        //     VMULTC. The remainder of this vector holds the residuals of the inactive
        //     constraints at DX, the ordering of the components of VMULTC being in
        //     agreement with the permutation of the indices of the constraints that is
        //     in IACT. All these residuals are nonnegative, which is achieved by the
        //     shift RESMAX that makes the least residual zero.
        //     Initialize Z and some other variables. The value of RESMAX will be
        //     appropriate to DX = 0, while ICON will be the index of a most violated
        //     constraint if RESMAX is positive. Usually during the first stage the
        //     vector SDIRN gives a search direction that reduces all the active
        //     constraint violations by one simultaneously.
        // Local variables
        var temp = 0, nactx = 0, resold = 0.0, z = this.arr2(1 + n, 1 + n), zdota = this.arr(2 + m), vmultc = this.arr(2 + m), sdirn = this.arr(1 + n), dxnew = this.arr(1 + n), vmultd = this.arr(2 + m), iact = this.arr(2 + m), mcon = m, nact = 0, icon, resmax, i, k, first, optold, icount, step, stpful, optnew, ratio, isave, vsave, total, kp, kk, sp, alpha, beta, tot, spabs, acca, accb, zdotv, zdvabs, kw, dd, ss, sd, zdotw, zdwabs, kl, sumabs, tempa, endless = true;
        for (i = 1; i <= n; ++i) {
            z[i][i] = 1.0;
            dx[i] = 0.0;
        }
        icon = 0;
        resmax = 0.0;
        if (m >= 1) {
            for (k = 1; k <= m; ++k) {
                if (b[k] > resmax) {
                    resmax = b[k];
                    icon = k;
                }
            }
            for (k = 1; k <= m; ++k) {
                iact[k] = k;
                vmultc[k] = resmax - b[k];
            }
        }
        //     End the current stage of the calculation if 3 consecutive iterations
        //     have either failed to reduce the best calculated value of the objective
        //     function or to increase the number of active constraints since the best
        //     value was calculated. This strategy prevents cycling, but there is a
        //     remote possibility that it will cause premature termination.
        first = true;
        do {
            L_60: do {
                if (!first || (first && resmax === 0.0)) {
                    mcon = m + 1;
                    icon = mcon;
                    iact[mcon] = mcon;
                    vmultc[mcon] = 0.0;
                }
                first = false;
                optold = 0.0;
                icount = 0;
                step = 0;
                stpful = 0;
                L_70: do {
                    // optnew = (mcon === m) ? resmax : -this.DOT_PRODUCT(this.PART(dx, 1, n), this.PART(this.COL(a, mcon), 1, n));
                    optnew =
                        mcon === m ? resmax : -this.DOT_PRODUCT_ROW_COL(dx, -1, a, mcon, 1, n);
                    if (icount === 0 || optnew < optold) {
                        optold = optnew;
                        nactx = nact;
                        icount = 3;
                    }
                    else if (nact > nactx) {
                        nactx = nact;
                        icount = 3;
                    }
                    else {
                        --icount;
                    }
                    if (icount === 0) {
                        break L_60;
                    }
                    //     If ICON exceeds NACT, then we add the constraint with index IACT(ICON) to
                    //     the active set. Apply Givens rotations so that the last N-NACT-1 columns
                    //     of Z are orthogonal to the gradient of the new constraint, a scalar
                    //     product being set to zero if its nonzero value could be due to computer
                    //     rounding errors. The array DXNEW is used for working space.
                    ratio = 0;
                    if (icon <= nact) {
                        if (icon < nact) {
                            //     Delete the constraint that has the index IACT(ICON) from the active set.
                            isave = iact[icon];
                            vsave = vmultc[icon];
                            k = icon;
                            do {
                                kp = k + 1;
                                kk = iact[kp];
                                sp = this.DOT_PRODUCT(this.PART(this.COL(z, k), 1, n), this.PART(this.COL(a, kk), 1, n));
                                temp = Mat.hypot(sp, zdota[kp]);
                                alpha = zdota[kp] / temp;
                                beta = sp / temp;
                                zdota[kp] = alpha * zdota[k];
                                zdota[k] = temp;
                                for (i = 1; i <= n; ++i) {
                                    temp = alpha * z[i][kp] + beta * z[i][k];
                                    z[i][kp] = alpha * z[i][k] - beta * z[i][kp];
                                    z[i][k] = temp;
                                }
                                iact[k] = kk;
                                vmultc[k] = vmultc[kp];
                                k = kp;
                            } while (k < nact);
                            iact[k] = isave;
                            vmultc[k] = vsave;
                        }
                        --nact;
                        //     If stage one is in progress, then set SDIRN to the direction of the next
                        //     change to the current vector of variables.
                        if (mcon > m) {
                            //     Pick the next search direction of stage two.
                            temp = 1.0 / zdota[nact];
                            for (k = 1; k <= n; ++k) {
                                sdirn[k] = temp * z[k][nact];
                            }
                        }
                        else {
                            // temp = this.DOT_PRODUCT(this.PART(sdirn, 1, n), this.PART(this.COL(z, nact + 1), 1, n));
                            temp = this.DOT_PRODUCT_ROW_COL(sdirn, -1, z, nact + 1, 1, n);
                            for (k = 1; k <= n; ++k) {
                                sdirn[k] -= temp * z[k][nact + 1];
                            }
                        }
                    }
                    else {
                        kk = iact[icon];
                        for (k = 1; k <= n; ++k) {
                            dxnew[k] = a[k][kk];
                        }
                        tot = 0.0;
                        // {
                        k = n;
                        while (k > nact) {
                            sp = 0.0;
                            spabs = 0.0;
                            for (i = 1; i <= n; ++i) {
                                temp = z[i][k] * dxnew[i];
                                sp += temp;
                                spabs += Math.abs(temp);
                            }
                            acca = spabs + 0.1 * Math.abs(sp);
                            accb = spabs + 0.2 * Math.abs(sp);
                            if (spabs >= acca || acca >= accb) {
                                sp = 0.0;
                            }
                            if (tot === 0.0) {
                                tot = sp;
                            }
                            else {
                                kp = k + 1;
                                temp = Mat.hypot(sp, tot);
                                alpha = sp / temp;
                                beta = tot / temp;
                                tot = temp;
                                for (i = 1; i <= n; ++i) {
                                    temp = alpha * z[i][k] + beta * z[i][kp];
                                    z[i][kp] = alpha * z[i][kp] - beta * z[i][k];
                                    z[i][k] = temp;
                                }
                            }
                            --k;
                        }
                        // }
                        if (tot === 0.0) {
                            //     The next instruction is reached if a deletion has to be made from the
                            //     active set in order to make room for the new active constraint, because
                            //     the new constraint gradient is a linear combination of the gradients of
                            //     the old active constraints.  Set the elements of VMULTD to the multipliers
                            //     of the linear combination.  Further, set IOUT to the index of the
                            //     constraint to be deleted, but branch if no suitable index can be found.
                            ratio = -1;
                            //{
                            k = nact;
                            do {
                                zdotv = 0.0;
                                zdvabs = 0.0;
                                for (i = 1; i <= n; ++i) {
                                    temp = z[i][k] * dxnew[i];
                                    zdotv += temp;
                                    zdvabs += Math.abs(temp);
                                }
                                acca = zdvabs + 0.1 * Math.abs(zdotv);
                                accb = zdvabs + 0.2 * Math.abs(zdotv);
                                if (zdvabs < acca && acca < accb) {
                                    temp = zdotv / zdota[k];
                                    if (temp > 0.0 && iact[k] <= m) {
                                        tempa = vmultc[k] / temp;
                                        if (ratio < 0.0 || tempa < ratio) {
                                            ratio = tempa;
                                        }
                                    }
                                    if (k >= 2) {
                                        kw = iact[k];
                                        for (i = 1; i <= n; ++i) {
                                            dxnew[i] -= temp * a[i][kw];
                                        }
                                    }
                                    vmultd[k] = temp;
                                }
                                else {
                                    vmultd[k] = 0.0;
                                }
                            } while (--k > 0);
                            //}
                            if (ratio < 0.0) {
                                break L_60;
                            }
                            //     Revise the Lagrange multipliers and reorder the active constraints so
                            //     that the one to be replaced is at the end of the list. Also calculate the
                            //     new value of ZDOTA(NACT) and branch if it is not acceptable.
                            for (k = 1; k <= nact; ++k) {
                                vmultc[k] = Math.max(0.0, vmultc[k] - ratio * vmultd[k]);
                            }
                            if (icon < nact) {
                                isave = iact[icon];
                                vsave = vmultc[icon];
                                k = icon;
                                do {
                                    kp = k + 1;
                                    kw = iact[kp];
                                    sp = this.DOT_PRODUCT(this.PART(this.COL(z, k), 1, n), this.PART(this.COL(a, kw), 1, n));
                                    temp = Mat.hypot(sp, zdota[kp]);
                                    alpha = zdota[kp] / temp;
                                    beta = sp / temp;
                                    zdota[kp] = alpha * zdota[k];
                                    zdota[k] = temp;
                                    for (i = 1; i <= n; ++i) {
                                        temp = alpha * z[i][kp] + beta * z[i][k];
                                        z[i][kp] = alpha * z[i][k] - beta * z[i][kp];
                                        z[i][k] = temp;
                                    }
                                    iact[k] = kw;
                                    vmultc[k] = vmultc[kp];
                                    k = kp;
                                } while (k < nact);
                                iact[k] = isave;
                                vmultc[k] = vsave;
                            }
                            temp = this.DOT_PRODUCT(this.PART(this.COL(z, nact), 1, n), this.PART(this.COL(a, kk), 1, n));
                            if (temp === 0.0) {
                                break L_60;
                            }
                            zdota[nact] = temp;
                            vmultc[icon] = 0.0;
                            vmultc[nact] = ratio;
                        }
                        else {
                            //     Add the new constraint if this can be done without a deletion from the
                            //     active set.
                            ++nact;
                            zdota[nact] = tot;
                            vmultc[icon] = vmultc[nact];
                            vmultc[nact] = 0.0;
                        }
                        //     Update IACT and ensure that the objective function continues to be
                        //     treated as the last active constraint when MCON>M.
                        iact[icon] = iact[nact];
                        iact[nact] = kk;
                        if (mcon > m && kk !== mcon) {
                            k = nact - 1;
                            sp = this.DOT_PRODUCT(this.PART(this.COL(z, k), 1, n), this.PART(this.COL(a, kk), 1, n));
                            temp = Mat.hypot(sp, zdota[nact]);
                            alpha = zdota[nact] / temp;
                            beta = sp / temp;
                            zdota[nact] = alpha * zdota[k];
                            zdota[k] = temp;
                            for (i = 1; i <= n; ++i) {
                                temp = alpha * z[i][nact] + beta * z[i][k];
                                z[i][nact] = alpha * z[i][k] - beta * z[i][nact];
                                z[i][k] = temp;
                            }
                            iact[nact] = iact[k];
                            iact[k] = kk;
                            temp = vmultc[k];
                            vmultc[k] = vmultc[nact];
                            vmultc[nact] = temp;
                        }
                        //     If stage one is in progress, then set SDIRN to the direction of the next
                        //     change to the current vector of variables.
                        if (mcon > m) {
                            //     Pick the next search direction of stage two.
                            temp = 1.0 / zdota[nact];
                            for (k = 1; k <= n; ++k) {
                                sdirn[k] = temp * z[k][nact];
                            }
                        }
                        else {
                            kk = iact[nact];
                            // temp = (this.DOT_PRODUCT(this.PART(sdirn, 1, n),this.PART(this.COL(a, kk), 1, n)) - 1.0) / zdota[nact];
                            temp =
                                (this.DOT_PRODUCT_ROW_COL(sdirn, -1, a, kk, 1, n) - 1.0) /
                                    zdota[nact];
                            for (k = 1; k <= n; ++k) {
                                sdirn[k] -= temp * z[k][nact];
                            }
                        }
                    }
                    //     Calculate the step to the boundary of the trust region or take the step
                    //     that reduces RESMAX to zero. The two statements below that include the
                    //     factor 1.0E-6 prevent some harmless underflows that occurred in a test
                    //     calculation. Further, we skip the step if it could be zero within a
                    //     reasonable tolerance for computer rounding errors.
                    dd = rho * rho;
                    sd = 0.0;
                    ss = 0.0;
                    for (i = 1; i <= n; ++i) {
                        if (Math.abs(dx[i]) >= 1.0e-6 * rho) {
                            dd -= dx[i] * dx[i];
                        }
                        sd += dx[i] * sdirn[i];
                        ss += sdirn[i] * sdirn[i];
                    }
                    if (dd <= 0.0) {
                        break L_60;
                    }
                    temp = Math.sqrt(ss * dd);
                    if (Math.abs(sd) >= 1.0e-6 * temp) {
                        temp = Math.sqrt(ss * dd + sd * sd);
                    }
                    stpful = dd / (temp + sd);
                    step = stpful;
                    if (mcon === m) {
                        acca = step + 0.1 * resmax;
                        accb = step + 0.2 * resmax;
                        if (step >= acca || acca >= accb) {
                            break L_70;
                        }
                        step = Math.min(step, resmax);
                    }
                    //     Set DXNEW to the new variables if STEP is the steplength, and reduce
                    //     RESMAX to the corresponding maximum residual if stage one is being done.
                    //     Because DXNEW will be changed during the calculation of some Lagrange
                    //     multipliers, it will be restored to the following value later.
                    for (k = 1; k <= n; ++k) {
                        dxnew[k] = dx[k] + step * sdirn[k];
                    }
                    if (mcon === m) {
                        resold = resmax;
                        resmax = 0.0;
                        for (k = 1; k <= nact; ++k) {
                            kk = iact[k];
                            // temp = b[kk] - this.DOT_PRODUCT(this.PART(this.COL(a, kk), 1, n), this.PART(dxnew, 1, n));
                            temp = b[kk] - this.DOT_PRODUCT_ROW_COL(dxnew, -1, a, kk, 1, n);
                            resmax = Math.max(resmax, temp);
                        }
                    }
                    //     Set VMULTD to the VMULTC vector that would occur if DX became DXNEW. A
                    //     device is included to force VMULTD(K) = 0.0 if deviations from this value
                    //     can be attributed to computer rounding errors. First calculate the new
                    //     Lagrange multipliers.
                    //{
                    k = nact;
                    do {
                        zdotw = 0.0;
                        zdwabs = 0.0;
                        for (i = 1; i <= n; ++i) {
                            temp = z[i][k] * dxnew[i];
                            zdotw += temp;
                            zdwabs += Math.abs(temp);
                        }
                        acca = zdwabs + 0.1 * Math.abs(zdotw);
                        accb = zdwabs + 0.2 * Math.abs(zdotw);
                        if (zdwabs >= acca || acca >= accb) {
                            zdotw = 0.0;
                        }
                        vmultd[k] = zdotw / zdota[k];
                        if (k >= 2) {
                            kk = iact[k];
                            for (i = 1; i <= n; ++i) {
                                dxnew[i] -= vmultd[k] * a[i][kk];
                            }
                        }
                    } while (k-- >= 2);
                    if (mcon > m) {
                        vmultd[nact] = Math.max(0.0, vmultd[nact]);
                    }
                    //}
                    //     Complete VMULTC by finding the new constraint residuals.
                    for (k = 1; k <= n; ++k) {
                        dxnew[k] = dx[k] + step * sdirn[k];
                    }
                    if (mcon > nact) {
                        kl = nact + 1;
                        for (k = kl; k <= mcon; ++k) {
                            kk = iact[k];
                            total = resmax - b[kk];
                            sumabs = resmax + Math.abs(b[kk]);
                            for (i = 1; i <= n; ++i) {
                                temp = a[i][kk] * dxnew[i];
                                total += temp;
                                sumabs += Math.abs(temp);
                            }
                            acca = sumabs + 0.1 * Math.abs(total);
                            accb = sumabs + 0.2 * Math.abs(total);
                            if (sumabs >= acca || acca >= accb) {
                                total = 0.0;
                            }
                            vmultd[k] = total;
                        }
                    }
                    //     Calculate the fraction of the step from DX to DXNEW that will be taken.
                    ratio = 1.0;
                    icon = 0;
                    for (k = 1; k <= mcon; ++k) {
                        if (vmultd[k] < 0.0) {
                            temp = vmultc[k] / (vmultc[k] - vmultd[k]);
                            if (temp < ratio) {
                                ratio = temp;
                                icon = k;
                            }
                        }
                    }
                    //     Update DX, VMULTC and RESMAX.
                    temp = 1.0 - ratio;
                    for (k = 1; k <= n; ++k) {
                        dx[k] = temp * dx[k] + ratio * dxnew[k];
                    }
                    for (k = 1; k <= mcon; ++k) {
                        vmultc[k] = Math.max(0.0, temp * vmultc[k] + ratio * vmultd[k]);
                    }
                    if (mcon === m) {
                        resmax = resold + ratio * (resmax - resold);
                    }
                    //     If the full step is not acceptable then begin another iteration.
                    //     Otherwise switch to stage two or end the calculation.
                } while (icon > 0);
                if (step === stpful) {
                    return true;
                }
            } while (endless);
            //     We employ any freedom that may be available to reduce the objective
            //     function before returning a DX whose length is less than RHO.
        } while (mcon === m);
        return false;
    },
    PrintIterationResult: function (nfvals, f, resmax, x, n, iprint) {
        if (iprint > 1) {
            console.log("NFVALS = " + nfvals + "  F = " + f + "  MAXCV = " + resmax);
        }
        if (iprint > 1) {
            console.log("X = " + this.PART(x, 1, n));
        }
    },
    ROW: function (src, rowidx) {
        return src[rowidx].slice();
        // var col,
        //     cols = src[0].length,
        //     dest = this.arr(cols);
        // for (col = 0; col < cols; ++col) {
        //     dest[col] = src[rowidx][col];
        // }
        // return dest;
    },
    COL: function (src, colidx) {
        var row, rows = src.length, dest = []; // this.arr(rows);
        for (row = 0; row < rows; ++row) {
            dest[row] = src[row][colidx];
        }
        return dest;
    },
    PART: function (src, from, to) {
        return src.slice(from, to + 1);
        // var srcidx,
        //     dest = this.arr(to - from + 1),
        //     destidx = 0;
        // for (srcidx = from; srcidx <= to; ++srcidx, ++destidx) {
        //     dest[destidx] = src[srcidx];
        // }
        // return dest;
    },
    FORMAT: function (x) {
        return x.join(",");
        // var i, fmt = "";
        // for (i = 0; i < x.length; ++i) {
        //     fmt += ", " + x[i];
        // }
        // return fmt;
    },
    DOT_PRODUCT: function (lhs, rhs) {
        var i, sum = 0.0, len = lhs.length;
        for (i = 0; i < len; ++i) {
            sum += lhs[i] * rhs[i];
        }
        return sum;
    },
    DOT_PRODUCT_ROW_COL: function (lhs, row, rhs, col, start, end) {
        var i, sum = 0.0;
        if (row === -1) {
            // lhs is vector
            for (i = start; i <= end; ++i) {
                sum += lhs[i] * rhs[i][col];
            }
        }
        else {
            // lhs is row of matrix
            if (col === -1) {
                // rhs is vector
                for (i = start; i <= end; ++i) {
                    sum += lhs[row][i] * rhs[i];
                }
            }
            else {
                // rhs is column of matrix
                for (i = start; i <= end; ++i) {
                    sum += lhs[row][i] * rhs[i][col];
                }
            }
        }
        return sum;
    }
};

// some dummies for testing
class Coords {
    constructor(by, coordinates, board) {
        this.usrCoords = [1, 1];
        this.scrCoords = [100, 100];
    }
}
/**
 * Math.Geometry namespace definition. This namespace holds geometrical algorithms,
 * especially intersection algorithms.
 * @name JXG.Math.Geometry
 * @exports Mat.Geometry as JXG.Math.Geometry
 * @namespace
 */
class Geometry {
    // the splitting is necessary due to the shortcut for the circumcircleMidpoint method to circumcenter.
    /* ***************************************/
    /* *** GENERAL GEOMETRIC CALCULATIONS ****/
    /* ***************************************/
    static angle(A, B, C) {
        throw new Error('deprecated, use Geometry.rad()');
    }
    /**
     * Calculates the angle defined by the three points A, B, C if you're going from A to C around B counterclockwise.
     * @param {JXG.Point|Array} A Point or [x,y] array
     * @param {JXG.Point|Array} B Point or [x,y] array
     * @param {JXG.Point|Array} C Point or [x,y] array
     * @see Geometry.rad
     * @returns {Number} The angle in degrees.
     */
    static trueAngle(A, B, C) {
        return this.rad(A, B, C) * 57.295779513082323; // *180.0/Math.PI;
    }
    /**
     * Calculates the internal angle defined by the three points A, B, C if you're going from A to C around B counterclockwise.
     * @param {JXG.Point|Array} A Point or [x,y] array
     * @param {JXG.Point|Array} B Point or [x,y] array
     * @param {JXG.Point|Array} C Point or [x,y] array
     * @see Geometry.trueAngle
     * @returns {Number} Angle in radians.
     */
    static rad(A, B, C) {
        var ax, ay, bx, by, cx, cy, phi;
        if (!Array.isArray(A)) {
            ax = A.usrCoords[1];
            ay = A.usrCoords[2];
        }
        else {
            ax = A[0];
            ay = A[1];
        }
        if (!Array.isArray(B)) {
            bx = B.usrCoords[1];
            by = B.usrCoords[2];
        }
        else {
            bx = B[0];
            by = B[1];
        }
        if (!Array.isArray(C)) {
            cx = C.usrCoords[1];
            cy = C.usrCoords[2];
        }
        else {
            cx = C[0];
            cy = C[1];
        }
        phi = Math.atan2(cy - by, cx - bx) - Math.atan2(ay - by, ax - bx);
        if (phi < 0) {
            phi += 6.2831853071795862;
        }
        return phi;
    }
    /**
     * Calculates a point on the bisection line between the three points A, B, C.
     * As a result, the bisection line is defined by two points:
     * Parameter B and the point with the coordinates calculated in this function.
     * Does not work for ideal points.
     * @param {JXG.Point} A Point
     * @param {JXG.Point} B Point
     * @param {JXG.Point} C Point
     * @param [board=A.board] Reference to the board
     * @returns {JXG.Coords} Coordinates of the second point defining the bisection.
     */
    static angleBisector(A, B, C, board) {
        return new Coords(COORDS_BY.USER, this.angleBisector2(A, B, C), board);
    }
    static angleBisector2(A, B, C) {
        var phiA, phiC, phi, Ac = A.usrCoords, Bc = B.usrCoords, Cc = C.usrCoords, x, y;
        // Parallel lines
        if (Bc[0] === 0) {
            return [1, (Ac[1] + Cc[1]) * 0.5, (Ac[2] + Cc[2]) * 0.5];
        }
        // Non-parallel lines
        x = Ac[1] - Bc[1];
        y = Ac[2] - Bc[2];
        phiA = Math.atan2(y, x);
        x = Cc[1] - Bc[1];
        y = Cc[2] - Bc[2];
        phiC = Math.atan2(y, x);
        phi = (phiA + phiC) * 0.5;
        if (phiA > phiC) {
            phi += Math.PI;
        }
        x = Math.cos(phi) + Bc[1];
        y = Math.sin(phi) + Bc[2];
        return [1, x, y];
    }
    /**
     * Calculates a point on the m-section line between the three points A, B, C.
     * As a result, the m-section line is defined by two points:
     * Parameter B and the point with the coordinates calculated in this function.
     * The m-section generalizes the bisector to any real number.
     * For example, the trisectors of an angle are simply the 1/3-sector and the 2/3-sector.
     * Does not work for ideal points.
     * @param {JXG.Point} A Point
     * @param {JXG.Point} B Point
     * @param {JXG.Point} C Point
     * @param {Number} m Number
     * @param [board=A.board] Reference to the board
     * @returns {JXG.Coords} Coordinates of the second point defining the bisection.
     */
    static angleMsector(A, B, C, m, board) {
        var phiA, phiC, phi, Ac = A.coords.usrCoords, Bc = B.coords.usrCoords, Cc = C.coords.usrCoords, x, y;
        if (!Type.exists(board)) {
            board = A.board;
        }
        // Parallel lines
        if (Bc[0] === 0) {
            return new Coords(COORDS_BY.USER, [1, (Ac[1] + Cc[1]) * m, (Ac[2] + Cc[2]) * m], board);
        }
        // Non-parallel lines
        x = Ac[1] - Bc[1];
        y = Ac[2] - Bc[2];
        phiA = Math.atan2(y, x);
        x = Cc[1] - Bc[1];
        y = Cc[2] - Bc[2];
        phiC = Math.atan2(y, x);
        phi = phiA + ((phiC - phiA) * m);
        if (phiA - phiC > Math.PI) {
            phi += 2 * m * Math.PI;
        }
        x = Math.cos(phi) + Bc[1];
        y = Math.sin(phi) + Bc[2];
        return new Coords(COORDS_BY.USER, [1, x, y], board);
    }
    /**
     * Reflects the point along the line.
     * @param {JXG.Line} line Axis of reflection.
     * @param {JXG.Point} point Point to reflect.
     * @param [board=point.board] Reference to the board
     * @returns {JXG.Coords} Coordinates of the reflected point.
     */
    static reflection(line, point, board) {
        // (v,w) defines the slope of the line
        var x0, y0, x1, y1, v, w, mu, pc = point.coords.usrCoords, p1c = line.point1.coords.usrCoords, p2c = line.point2.coords.usrCoords;
        if (!Type.exists(board)) {
            board = point.board;
        }
        v = p2c[1] - p1c[1];
        w = p2c[2] - p1c[2];
        x0 = pc[1] - p1c[1];
        y0 = pc[2] - p1c[2];
        mu = (v * y0 - w * x0) / (v * v + w * w);
        // point + mu*(-y,x) is the perpendicular foot
        x1 = pc[1] + 2 * mu * w;
        y1 = pc[2] - 2 * mu * v;
        return new Coords(COORDS_BY.USER, [x1, y1], board);
    }
    /**
     * Computes the new position of a point which is rotated
     * around a second point (called rotpoint) by the angle phi.
     * @param {JXG.Point} rotpoint Center of the rotation
     * @param {JXG.Point} point point to be rotated
     * @param {Number} phi rotation angle in arc length
     * @param {JXG.Board} [board=point.board] Reference to the board
     * @returns {JXG.Coords} Coordinates of the new position.
     */
    static rotation(rotpoint, point, phi, board) {
        var x0, y0, c, s, x1, y1, pc = point.coords.usrCoords, rotpc = rotpoint.coords.usrCoords;
        if (!Type.exists(board)) {
            board = point.board;
        }
        x0 = pc[1] - rotpc[1];
        y0 = pc[2] - rotpc[2];
        c = Math.cos(phi);
        s = Math.sin(phi);
        x1 = x0 * c - y0 * s + rotpc[1];
        y1 = x0 * s + y0 * c + rotpc[2];
        return new Coords(COORDS_BY.USER, [x1, y1], board);
    }
    /**
     * Calculates the coordinates of a point on the perpendicular to the given line through
     * the given point.
     * @param {JXG.Line} line A line.
     * @param {JXG.Point} point Point which is projected to the line.
     * @param {JXG.Board} [board=point.board] Reference to the board
     * @returns {Array} Array of length two containing coordinates of a point on the perpendicular to the given line
     *                  through the given point and boolean flag "change".
     */
    static perpendicular(line, point, board) {
        var x, y, change, c, z, A = line.point1.coords.usrCoords, B = line.point2.coords.usrCoords, C = point.coords.usrCoords;
        if (!Type.exists(board)) {
            board = point.board;
        }
        // special case: point is the first point of the line
        if (point === line.point1) {
            x = A[1] + B[2] - A[2];
            y = A[2] - B[1] + A[1];
            z = A[0] * B[0];
            if (Math.abs(z) < JSXMath.eps) {
                x = B[2];
                y = -B[1];
            }
            c = [z, x, y];
            change = true;
            // special case: point is the second point of the line
        }
        else if (point === line.point2) {
            x = B[1] + A[2] - B[2];
            y = B[2] - A[1] + B[1];
            z = A[0] * B[0];
            if (Math.abs(z) < JSXMath.eps) {
                x = A[2];
                y = -A[1];
            }
            c = [z, x, y];
            change = false;
            // special case: point lies somewhere else on the line
        }
        else if (Math.abs(JSXMath.innerProduct(C, line.stdform, 3)) < JSXMath.eps) {
            x = C[1] + B[2] - C[2];
            y = C[2] - B[1] + C[1];
            z = B[0];
            if (Math.abs(z) < JSXMath.eps) {
                x = B[2];
                y = -B[1];
            }
            change = true;
            if (Math.abs(z) > JSXMath.eps &&
                Math.abs(x - C[1]) < JSXMath.eps &&
                Math.abs(y - C[2]) < JSXMath.eps) {
                x = C[1] + A[2] - C[2];
                y = C[2] - A[1] + C[1];
                change = false;
            }
            c = [z, x, y];
            // general case: point does not lie on the line
            // -> calculate the foot of the dropped perpendicular
        }
        else {
            c = [0, line.stdform[1], line.stdform[2]];
            c = JSXMath.crossProduct(c, C); // perpendicuar to line
            c = JSXMath.crossProduct(c, line.stdform); // intersection of line and perpendicular
            change = true;
        }
        return [new Coords(COORDS_BY.USER, c, board), change];
    }
    // /**
    //  * @deprecated Please use {@link Geometry.circumcenter} instead.
    //  */
    // static circumcenterMidpoint() {
    //     JXG.deprecated("Geometry.circumcenterMidpoint()", "Geometry.circumcenter()");
    //     this.circumcenter.apply(this, arguments);
    // }
    /**
     * Calculates the center of the circumcircle of the three given points.
     * @param {JXG.Point} point1 Point
     * @param {JXG.Point} point2 Point
     * @param {JXG.Point} point3 Point
     * @param {JXG.Board} [board=point1.board] Reference to the board
     * @returns {JXG.Coords} Coordinates of the center of the circumcircle of the given points.
     */
    circumcenter(point1, point2, point3, board) {
        var u, v, m1, m2, A = point1.coords.usrCoords, B = point2.coords.usrCoords, C = point3.coords.usrCoords;
        if (!Type.exists(board)) {
            board = point1.board;
        }
        u = [B[0] - A[0], -B[2] + A[2], B[1] - A[1]];
        v = [(A[0] + B[0]) * 0.5, (A[1] + B[1]) * 0.5, (A[2] + B[2]) * 0.5];
        m1 = JSXMath.crossProduct(u, v);
        u = [C[0] - B[0], -C[2] + B[2], C[1] - B[1]];
        v = [(B[0] + C[0]) * 0.5, (B[1] + C[1]) * 0.5, (B[2] + C[2]) * 0.5];
        m2 = JSXMath.crossProduct(u, v);
        return new Coords(COORDS_BY.USER, JSXMath.crossProduct(m1, m2), board);
    }
    /**
     * Calculates the Euclidean distance for two given arrays of the same length.
     * @param  array1 Array of Number
     * @param  array2 Array of Number
     * @param n Length of the arrays. Default is the minimum length of the given arrays.
     * @returns  Euclidean distance of the given vectors.
     */
    static distance(array1, array2, n) {
        let sum = 0;
        if (!n) {
            n = Math.min(array1.length, array2.length);
        }
        for (let i = 0; i < n; i++) {
            sum += (array1[i] - array2[i]) * (array1[i] - array2[i]);
        }
        return Math.sqrt(sum);
    }
    /**
     * Calculates Euclidean distance for two given arrays of the same length.
     * If one of the arrays contains a zero in the first coordinate, and the Euclidean distance
     * is different from zero it is a point at infinity and we return Infinity.
     * @param {Array} array1 Array containing elements of type number.
     * @param {Array} array2 Array containing elements of type number.
     * @param {Number} [n] Length of the arrays. Default is the minimum length of the given arrays.
     * @returns {Number} Euclidean (affine) distance of the given vectors.
     */
    static affineDistance(array1, array2, n) {
        var d;
        d = this.distance(array1, array2, n);
        if (d > JSXMath.eps &&
            (Math.abs(array1[0]) < JSXMath.eps || Math.abs(array2[0]) < JSXMath.eps)) {
            return Infinity;
        }
        return d;
    }
    /**
     * Affine ratio of three collinear points a, b, c: (c - a) / (b - a).
     * If r > 1 or r < 0 then c is outside of the segment ab.
     *
     * @param {Array|JXG.Coords} a
     * @param {Array|JXG.Coords} b
     * @param {Array|JXG.Coords} c
     * @returns {Number} affine ratio (c - a) / (b - a)
     */
    static affineRatio(a, b, c) {
        var r = 0.0, dx;
        if (Type.exists(a.usrCoords)) {
            a = a.usrCoords;
        }
        if (Type.exists(b.usrCoords)) {
            b = b.usrCoords;
        }
        if (Type.exists(c.usrCoords)) {
            c = c.usrCoords;
        }
        dx = b[1] - a[1];
        if (Math.abs(dx) > JSXMath.eps) {
            r = (c[1] - a[1]) / dx;
        }
        else {
            r = (c[2] - a[2]) / (b[2] - a[2]);
        }
        return r;
    }
    /**
     * Sort vertices counter clockwise starting with the first point.
     * Used in Polygon.sutherlandHodgman, Geometry.signedPolygon.
     *
     * @param {Array} p An array containing {@link JXG.Point} {@link JXG.Coords} and/or arrays.
     *
     * @returns {Array}
     */
    static sortVertices(p) {
        var ll, ps = Expect.each(p, Expect.coordsArray), N = ps.length, lastPoint = null;
        // If the last point equals the first point, we take the last point out of the array.
        // It may be that the several points at the end of the array are equal to the first point.
        // The polygonal chain is been closed by JSXGraph, but this may also have been done by the user.
        // Therefore, we use a while loop to pop the last points.
        while (ps[0][0] === ps[N - 1][0] &&
            ps[0][1] === ps[N - 1][1] &&
            ps[0][2] === ps[N - 1][2]) {
            lastPoint = ps.pop();
            N--;
        }
        ll = ps[0];
        // Sort ps in increasing order of the angle between a point and the first point ll.
        // If a point is equal to the first point ll, the angle is defined to be -Infinity.
        // Otherwise, atan2 would return zero, which is a value which also attained by points
        // on the same horizontal line.
        ps.sort(function (a, b) {
            var rad1 = (a[2] === ll[2] && a[1] === ll[1])
                ? -Infinity
                : Math.atan2(a[2] - ll[2], a[1] - ll[1]), rad2 = (b[2] === ll[2] && b[1] === ll[1])
                ? -Infinity
                : Math.atan2(b[2] - ll[2], b[1] - ll[1]);
            return rad1 - rad2;
        });
        // If the last point has been taken out of the array, we put it in again.
        if (lastPoint !== null) {
            ps.push(lastPoint);
        }
        return ps;
    }
    /**
     * Signed triangle area of the three points given. It can also be used
     * to test the orientation of the triangle.
     * <ul>
     * <li> If the return value is < 0, then the point p2 is left of the line [p1, p3] (i.e p3 is right from [p1, p2]).
     * <li> If the return value is > 0, then the point p2 is right of the line [p1, p3] (i.e p3 is left from [p1, p2]).
     * <li> If the return value is = 0, then the points p1, p2, p3 are collinear.
     * </ul>
     *
     * @param {JXG.Point|JXG.Coords|Array} p1
     * @param {JXG.Point|JXG.Coords|Array} p2
     * @param {JXG.Point|JXG.Coords|Array} p3
     *
     * @returns {Number}
     */
    static signedTriangle(p1, p2, p3) {
        var A = Expect.coordsArray(p1), B = Expect.coordsArray(p2), C = Expect.coordsArray(p3);
        return 0.5 * ((B[1] - A[1]) * (C[2] - A[2]) - (B[2] - A[2]) * (C[1] - A[1]));
    }
    /**
     * Determine the signed area of a non-self-intersecting polygon.
     * Surveyor's Formula
     *
     * @param {Array} p An array containing {@link JXG.Point} {@link JXG.Coords} and/or arrays.
     * @param {Boolean} [sort=true]
     *
     * @returns {Number}
     */
    static signedPolygon(p, sort) {
        var i, N, A = 0, ps = Expect.each(p, Expect.coordsArray);
        if (sort === undefined) {
            sort = true;
        }
        if (!sort) {
            ps = this.sortVertices(ps);
        }
        else {
            // Make sure the polygon is closed. If it is already closed this won't change the sum because the last
            // summand will be 0.
            ps.unshift(ps[ps.length - 1]);
        }
        N = ps.length;
        for (i = 1; i < N; i++) {
            A += ps[i - 1][1] * ps[i][2] - ps[i][1] * ps[i - 1][2];
        }
        return 0.5 * A;
    }
    /**
     * Calculate the complex hull of a point cloud by the Graham scan algorithm.
     *
     * @param {Array} points An array containing {@link JXG.Point} {@link JXG.Coords} and/or arrays.
     *
     * @returns {Array} List of objects <pre>{i: index, c: coords}</pre> containing the convex hull points
     *  in form of the index in the original input array and a coords array.
     *
     * @example
     *     // Static example
     *
     *     var i, hull,
     *       p = [],
     *       q = [];
     *
     *     p.push( board.create('point', [4, 0], {withLabel:false }) );
     *     p.push( board.create('point', [0, 4], {withLabel:false }) );
     *     p.push( board.create('point', [0, 0], {withLabel:false }) );
     *     p.push([-1, 0]);
     *     p.push([-3, -3]);
     *
     *     hull = Geometry.GrahamScan(p);
     *     for (i = 0; i < hull.length; i++) {
     *       console.log(hull[i]);
     *       q.push(hull[i].c);
     *     }
     *     board.create('polygon', q);
     *     // Output:
     *     // { i: 4, c: [1, -3, 3]}
     *     // { i: 0, c: [1, 4, 0]}
     *     // { i: 1, c: [1, 0, 4]}
     *
     * </pre><div id="JXGb310b874-595e-4020-b0c2-566482797836" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGb310b874-595e-4020-b0c2-566482797836',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *         var i, hull,
     *           p = [],
     *           q = [];
     *
     *         p.push( board.create('point', [4, 0], {withLabel:false }) );
     *         p.push( board.create('point', [0, 4], {withLabel:false }) );
     *         p.push( board.create('point', [0, 0], {withLabel:false }) );
     *         p.push([-1, 0]);
     *         p.push([-3, -3]);
     *
     *         hull = Geometry.GrahamScan(p);
     *         for (i = 0; i < hull.length; i++) {
     *           console.log(hull[i]);
     *           q.push(hull[i].c);
     *         }
     *         board.create('polygon', q);
     *
     *     })();
     *
     * </script><pre>
     *
     */
    static GrahamScan(points) {
        var i, M, o, mi_idx, mi_x, mi_y, ma_x, ma_y, mi_xpy, mi_xmy, ma_xpy, ma_xmy, mi_x_i, ma_x_i, mi_y_i, ma_y_i, mi_xpy_i, mi_xmy_i, ma_xpy_i, ma_xmy_i, v, c, eps = JSXMath.eps * JSXMath.eps, that = this, ps_idx = [], stack = [], ps = Expect.each(points, Expect.coordsArray), // New array object, i.e. a copy of the input array.
        N, AklToussaint = 1024; // This is a rough threshold where the heuristic pays off.
        N = ps.length;
        if (N === 0) {
            return [];
        }
        if (N > AklToussaint) {
            //
            // Akl-Toussaint heuristic
            // Determine an irregular convex octagon whose inside can be discarded.
            //
            mi_x = ps[0][1];
            ma_x = mi_x;
            mi_y = ps[0][2];
            ma_y = mi_y;
            mi_xmy = ps[0][1] - ps[0][2];
            ma_xmy = mi_xmy;
            mi_xpy = ps[0][1] + ps[0][2];
            ma_xpy = mi_xpy;
            mi_x_i = 0;
            ma_x_i = 0;
            mi_y_i = 0;
            ma_y_i = 0;
            mi_xmy_i = 0;
            ma_xmy_i = 0;
            mi_xpy_i = 0;
            ma_xpy_i = 0;
            for (i = 1; i < N; i++) {
                v = ps[i][1];
                if (v < mi_x) {
                    mi_x = v;
                    mi_x_i = i;
                }
                else if (v > ma_x) {
                    ma_x = v;
                    ma_x_i = i;
                }
                v = ps[i][2];
                if (v < mi_y) {
                    mi_y = v;
                    mi_y_i = i;
                }
                else if (v > ma_y) {
                    ma_y = v;
                    ma_y_i = i;
                }
                v = ps[i][1] - ps[i][2];
                if (v < mi_xmy) {
                    mi_xmy = v;
                    mi_xmy_i = i;
                }
                else if (v > ma_xmy) {
                    ma_xmy = v;
                    ma_xmy_i = i;
                }
                v = ps[i][1] + ps[i][2];
                if (v < mi_xpy) {
                    mi_xpy = v;
                    mi_xpy_i = i;
                }
                else if (v > ma_xpy) {
                    ma_xpy = v;
                    ma_xpy_i = i;
                }
            }
        }
        // Keep track of the indices of the input points.
        for (i = 0; i < N; i++) {
            c = ps[i];
            if (N <= AklToussaint ||
                // Discard inside of the octagon according to the Akl-Toussaint heuristic
                i in [mi_x_i, ma_x_i, mi_y_i, ma_y_i, mi_xpy_i, mi_xmy_i, ma_xpy_i, ma_xmy_i] ||
                (mi_x_i !== mi_xmy_i && this.signedTriangle(ps[mi_x_i], ps[mi_xmy_i], c) >= -eps) ||
                (mi_xmy_i !== ma_y_i && this.signedTriangle(ps[mi_xmy_i], ps[ma_y_i], c) >= -eps) ||
                (ma_y_i !== ma_xpy_i && this.signedTriangle(ps[ma_y_i], ps[ma_xpy_i], c) >= -eps) ||
                (ma_xpy_i !== ma_x_i && this.signedTriangle(ps[ma_xpy_i], ps[ma_x_i], c) >= -eps) ||
                (ma_x_i !== ma_xmy_i && this.signedTriangle(ps[ma_x_i], ps[ma_xmy_i], c) >= -eps) ||
                (ma_xmy_i !== mi_y_i && this.signedTriangle(ps[ma_xmy_i], ps[mi_y_i], c) >= -eps) ||
                (mi_y_i !== mi_xpy_i && this.signedTriangle(ps[mi_y_i], ps[mi_xpy_i], c) >= -eps) ||
                (mi_xpy_i !== mi_x_i && this.signedTriangle(ps[mi_xpy_i], ps[mi_x_i], c) >= -eps)) {
                ps_idx.push({
                    i: i,
                    c: c
                });
            }
        }
        N = ps_idx.length;
        // Find the point with the lowest y value
        mi_idx = 0;
        mi_x = ps_idx[0].c[1];
        mi_y = ps_idx[0].c[2];
        for (i = 1; i < N; i++) {
            if ((ps_idx[i].c[2] < mi_y) || (ps_idx[i].c[2] === mi_y && ps_idx[i].c[1] < mi_x)) {
                mi_x = ps_idx[i].c[1];
                mi_y = ps_idx[i].c[2];
                mi_idx = i;
            }
        }
        ps_idx = Type.swap(ps_idx, mi_idx, 0);
        // Our origin o, i.e. the first point.
        o = ps_idx[0].c;
        // Sort according to the angle around o.
        ps_idx.sort(function (a_obj, b_obj) {
            var a = a_obj.c, b = b_obj.c, v = that.signedTriangle(o, a, b);
            if (v === 0) {
                // if o, a, b are collinear, the point which is further away
                // from o is considered greater.
                return JSXMath.hypot(a[1] - o[1], a[2] - o[2]) - JSXMath.hypot(b[1] - o[1], b[2] - o[2]);
            }
            // if v < 0, a is to the left of [o, b], i.e. angle(a) > angle(b)
            return -v;
        });
        // Do the Graham scan.
        M = 0;
        for (i = 0; i < N; i++) {
            while (M > 1 && this.signedTriangle(stack[M - 2].c, stack[M - 1].c, ps_idx[i].c) <= 0) {
                // stack[M - 1] is to the left of stack[M - 1], ps[i]: discard it
                stack.pop();
                M--;
            }
            stack.push(ps_idx[i]);
            M++;
        }
        return stack;
    }
    // Original method
    // GrahamScan(points, indices) {
    //     var i,
    //         M = 1,
    //         ps = Expect.each(points, Expect.coordsArray),
    //         N = ps.length;
    //     ps = this.sortVertices(ps);
    //     N = ps.length;
    //     for (i = 2; i < N; i++) {
    //         while (this.signedTriangle(ps[M - 1], ps[M], ps[i]) <= 0) {
    //             if (M > 1) {
    //                 M -= 1;
    //             } else if (i === N - 1) {
    //                 break;
    //             }
    //             i += 1;
    //         }
    //         M += 1;
    //         ps = Type.swap(ps, M, i);
    //         indices = Type.swap(indices, M, i);
    //     }
    //     return ps.slice(0, M);
    // }
    /**
     * Calculate the complex hull of a point cloud by the Graham scan algorithm.
     *
     * @param {Array} points An array containing {@link JXG.Point} {@link JXG.Coords} and/or arrays.
     * @param {Boolean} [returnCoords=false] If true, return an array of coords. Otherwise return a list of pointers
     * to the input list elements. That is, if the input is a list of {@link JXG.Point} elements, the returned list
     * will contain the points that form the convex hull.
     * @returns {Array} List containing the convex hull. Format depends on returnCoords.
     * @see Geometry.GrahamScan
     *
     * @example
     *     // Static example
     *     var i, hull,
     *         p = [];
     *
     *     p.push( board.create('point', [4, 0], {withLabel:false }) );
     *     p.push( board.create('point', [0, 4], {withLabel:false }) );
     *     p.push( board.create('point', [0, 0], {withLabel:false }) );
     *     p.push( board.create('point', [1, 1], {withLabel:false }) );
     *     hull = Geometry.convexHull(p);
     *     for (i = 0; i < hull.length; i++) {
     *       hull[i].setAttribute({color: 'blue'});
     *     }
     *
     * </pre><div id="JXGdfc76123-81b8-4250-96f9-419253bd95dd" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGdfc76123-81b8-4250-96f9-419253bd95dd',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *         var i, hull,
     *             p = [];
     *
     *         p.push( board.create('point', [4, 0], {withLabel:false }) );
     *         p.push( board.create('point', [0, 4], {withLabel:false }) );
     *         p.push( board.create('point', [0, 0], {withLabel:false }) );
     *         p.push( board.create('point', [1, 1], {withLabel:false }) );
     *         hull = Geometry.convexHull(p);
     *         for (i = 0; i < hull.length; i++) {
     *           hull[i].setAttribute({color: 'blue'});
     *         }
     *
     *     })();
     *
     * </script><pre>
     *
     * @example
     *     // Dynamic version using returnCoords==true: drag the points
     *     var p = [];
     *
     *     p.push( board.create('point', [4, 0], {withLabel:false }) );
     *     p.push( board.create('point', [0, 4], {withLabel:false }) );
     *     p.push( board.create('point', [0, 0], {withLabel:false }) );
     *     p.push( board.create('point', [1, 1], {withLabel:false }) );
     *
     *     var c = board.create('curve', [[], []], {fillColor: 'yellow', fillOpacity: 0.3});
     *     c.updateDataArray = function() {
     *       var i,
     *         hull = Geometry.convexHull(p, true);
     *
     *       this.dataX = [];
     *       this.dataY = [];
     *
     *       for (i = 0; i < hull.length; i ++) {
     *         this.dataX.push(hull[i][1]);
     *         this.dataY.push(hull[i][2]);
     *       }
     *       this.dataX.push(hull[0][1]);
     *       this.dataY.push(hull[0][2]);
     *     };
     *     board.update();
     *
     * </pre><div id="JXG61e51909-da0b-432f-9aa7-9fb0c8bb01c9" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG61e51909-da0b-432f-9aa7-9fb0c8bb01c9',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *         var p = [];
     *
     *         p.push( board.create('point', [4, 0], {withLabel:false }) );
     *         p.push( board.create('point', [0, 4], {withLabel:false }) );
     *         p.push( board.create('point', [0, 0], {withLabel:false }) );
     *         p.push( board.create('point', [1, 1], {withLabel:false }) );
     *
     *         var c = board.create('curve', [[], []], {fillColor: 'yellow', fillOpacity: 0.3});
     *         c.updateDataArray = function() {
     *           var i,
     *             hull = Geometry.convexHull(p, true);
     *
     *           this.dataX = [];
     *           this.dataY = [];
     *
     *           for (i = 0; i < hull.length; i ++) {
     *             this.dataX.push(hull[i][1]);
     *             this.dataY.push(hull[i][2]);
     *           }
     *           this.dataX.push(hull[0][1]);
     *           this.dataY.push(hull[0][2]);
     *         };
     *         board.update();
     *
     *
     *     })();
     *
     * </script><pre>
     *
     */
    static convexHull(points, returnCoords) {
        var i, hull, res = [];
        hull = this.GrahamScan(points);
        for (i = 0; i < hull.length; i++) {
            if (returnCoords) {
                res.push(hull[i].c);
            }
            else {
                res.push(points[hull[i].i]);
            }
        }
        return res;
    }
    // /**
    //  * Determine if a polygon or a path element is convex, non-convex or complex which are defined like this:
    //  * <ul>
    //  * <li> A polygon is convex if for every pair of points, the line segment connecting them does not intersect
    //  * an edge of the polygon in one point.
    //  * A single line segment or a a single point is considered as convex. A necessary condition for a polygon
    //  * to be convex that the angle sum of its interior angles equals &plusmn; 2 &pi;.
    //  * <li> A polygon is non-convex, if it does not self-intersect, but is not convex.
    //  * <li> A polygon is complex if its the angle sum is not equal to &plusmn; 2 &pi;.
    //  * That is, there must be self-intersection (contiguous coincident points in the path are not treated as self-intersection).
    //  * </ul>
    //  * A path  element might be specified as an array of coordinate arrays or {@link JXG.Coords}.
    //  *
    //  * @param {Array|Polygon|PolygonalChain} points Polygon or list of coordinates
    //  * @returns {Number} -1: if complex, 0: if non-convex, 1: if convex
    //  */
    /**
     * Determine if a polygon or a path element is convex:
     * <p>
     * A polygon is convex if for every pair of points, the line segment connecting them does not intersect
     * an edge of the polygon in one point.
     * A single line segment, a single point, or the empty set is considered as convex. A necessary condition for a polygon
     * to be convex that the angle sum of its interior angles equals &plusmn; 2 &pi;.
     * <p>
     * A path  element might be specified as an array of coordinate arrays or {@link JXG.Coords}.
     * See the discussion at <a href="https://stackoverflow.com/questions/471962/how-do-i-efficiently-determine-if-a-polygon-is-convex-non-convex-or-complex">stackoverflow</a>.
     *
     * @param {Array|Polygon|PolygonalChain} points Polygon or list of coordinates
     * @returns {Boolean} true if convex
     *
     * @example
     * var pol = board.create('polygon', [
     *     [-1, -1],
     *     [3, -1],
     *     [4, 2],
     *     [3, 3],
     *     [0, 4],
     *     [-3, 1]
     * ], {
     *     vertices: {
     *         color: 'blue',
     *         snapToGrid: true
     *     }
     * });
     *
     * console.log(Geometry.isConvex(pol));
     * // > true
     *
     *
     *
     * </pre><div id="JXG9b43cc53-15b4-49be-92cc-2a1dfc06665b" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG9b43cc53-15b4-49be-92cc-2a1dfc06665b',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var pol = board.create('polygon', [
     *         [-1, -1],
     *         [3, -1],
     *         [4, 2],
     *         [3, 3],
     *         [0, 4],
     *         [-3, 1]
     *     ], {
     *         vertices: {
     *             color: 'blue',
     *             snapToGrid: true
     *         }
     *     });
     *
     *     console.log(Geometry.isConvex(pol));
     *
     *
     *
     *     })();
     *
     * </script><pre>
     *
     */
    static isConvex(points) {
        var ps, le, i, eps = JSXMath.eps * JSXMath.eps, old_x, old_y, old_dir, new_x, new_y, new_dir, angle, orient, angle_sum = 0.0;
        if (Array.isArray(points)) {
            ps = Expect.each(points, Expect.coordsArray);
        }
        else if (Type.exists(points.type) && points.type === OBJECT_TYPE.POLYGON) {
            ps = Expect.each(points.vertices, Expect.coordsArray);
        }
        le = ps.length;
        if (le === 0) {
            // Empty set is convex
            return true;
        }
        if (le < 3) {
            // Segments and points are convex
            return true;
        }
        orient = null;
        old_x = ps[le - 2][1];
        old_y = ps[le - 2][2];
        new_x = ps[le - 1][1];
        new_y = ps[le - 1][2];
        new_dir = Math.atan2(new_y - old_y, new_x - old_x);
        for (i = 0; i < le; i++) {
            old_x = new_x;
            old_y = new_y;
            old_dir = new_dir;
            new_x = ps[i][1];
            new_y = ps[i][2];
            if (old_x === new_x && old_y === new_y) {
                // Repeated consecutive points are ignored
                continue;
            }
            new_dir = Math.atan2(new_y - old_y, new_x - old_x);
            angle = new_dir - old_dir;
            if (angle <= -Math.PI) {
                angle += 2 * Math.PI;
            }
            else if (angle > Math.PI) {
                angle -= 2 * Math.PI;
            }
            if (orient === null) {
                if (angle === 0.0) {
                    continue;
                }
                orient = (angle > 0) ? 1 : -1;
            }
            else {
                if (orient * angle < -eps) {
                    return false;
                }
            }
            angle_sum += angle;
        }
        if ((Math.abs(angle_sum / (2 * Math.PI)) - 1) < eps) {
            return true;
        }
        return false;
    }
    /**
     * A line can be a segment, a straight, or a ray. So it is not always delimited by point1 and point2
     * calcStraight determines the visual start point and end point of the line. A segment is only drawn
     * from start to end point, a straight line is drawn until it meets the boards boundaries.
     * @param {JXG.Line} el Reference to a line object, that needs calculation of start and end point.
     * @param {JXG.Coords} point1 Coordinates of the point where line drawing begins. This value is calculated and
     * set by this method.
     * @param {JXG.Coords} point2 Coordinates of the point where line drawing ends. This value is calculated and set
     * by this method.
     * @param {Number} margin Optional margin, to avoid the display of the small sides of lines.
     * @returns null
     * @see Line
     * @see JXG.Line
     */
    static calcStraight(el, point1, point2, margin) {
        var takePoint1, takePoint2, intersection, intersect1, intersect2, straightFirst, straightLast, c, p1, p2;
        if (!Type.exists(margin)) {
            // Enlarge the drawable region slightly. This hides the small sides
            // of thick lines in most cases.
            margin = 10;
        }
        straightFirst = el.evalVisProp('straightfirst');
        straightLast = el.evalVisProp('straightlast');
        // If one of the point is an ideal point in homogeneous coordinates
        // drawing of line segments or rays are not possible.
        if (Math.abs(point1.scrCoords[0]) < JSXMath.eps) {
            straightFirst = true;
        }
        if (Math.abs(point2.scrCoords[0]) < JSXMath.eps) {
            straightLast = true;
        }
        // Do nothing in case of line segments (inside or outside of the board)
        if (!straightFirst && !straightLast) {
            return;
        }
        // Compute the stdform of the line in screen coordinates.
        c = [];
        c[0] =
            el.stdform[0] -
                (el.stdform[1] * el.board.origin.scrCoords[1]) / el.board.unitX +
                (el.stdform[2] * el.board.origin.scrCoords[2]) / el.board.unitY;
        c[1] = el.stdform[1] / el.board.unitX;
        c[2] = -el.stdform[2] / el.board.unitY;
        // If p1=p2
        if (isNaN(c[0] + c[1] + c[2])) {
            return;
        }
        takePoint1 = false;
        takePoint2 = false;
        // Line starts at point1 and point1 is inside the board
        takePoint1 =
            !straightFirst &&
                Math.abs(point1.usrCoords[0]) >= JSXMath.eps &&
                point1.scrCoords[1] >= 0.0 &&
                point1.scrCoords[1] <= el.board.canvasWidth &&
                point1.scrCoords[2] >= 0.0 &&
                point1.scrCoords[2] <= el.board.canvasHeight;
        // Line ends at point2 and point2 is inside the board
        takePoint2 =
            !straightLast &&
                Math.abs(point2.usrCoords[0]) >= JSXMath.eps &&
                point2.scrCoords[1] >= 0.0 &&
                point2.scrCoords[1] <= el.board.canvasWidth &&
                point2.scrCoords[2] >= 0.0 &&
                point2.scrCoords[2] <= el.board.canvasHeight;
        // Intersect the line with the four borders of the board.
        intersection = this.meetLineBoard(c, el.board, margin);
        intersect1 = intersection[0];
        intersect2 = intersection[1];
        /**
         * At this point we have four points:
         * point1 and point2 are the first and the second defining point on the line,
         * intersect1, intersect2 are the intersections of the line with border around the board.
         */
        /*
         * Here we handle rays where both defining points are outside of the board.
         */
        // If both points are outside and the complete ray is outside we do nothing
        if (!takePoint1 && !takePoint2) {
            // Ray starting at point 1
            if (!straightFirst &&
                straightLast &&
                !this.isSameDirection(point1, point2, intersect1) &&
                !this.isSameDirection(point1, point2, intersect2)) {
                return;
            }
            // Ray starting at point 2
            if (straightFirst &&
                !straightLast &&
                !this.isSameDirection(point2, point1, intersect1) &&
                !this.isSameDirection(point2, point1, intersect2)) {
                return;
            }
        }
        /*
         * If at least one of the defining points is outside of the board
         * we take intersect1 or intersect2 as one of the end points
         * The order is also important for arrows of axes
         */
        if (!takePoint1) {
            if (!takePoint2) {
                // Two border intersection points are used
                if (this.isSameDir(point1, point2, intersect1, intersect2)) {
                    p1 = intersect1;
                    p2 = intersect2;
                }
                else {
                    p2 = intersect1;
                    p1 = intersect2;
                }
            }
            else {
                // One border intersection points is used
                if (this.isSameDir(point1, point2, intersect1, intersect2)) {
                    p1 = intersect1;
                }
                else {
                    p1 = intersect2;
                }
            }
        }
        else {
            if (!takePoint2) {
                // One border intersection points is used
                if (this.isSameDir(point1, point2, intersect1, intersect2)) {
                    p2 = intersect2;
                }
                else {
                    p2 = intersect1;
                }
            }
        }
        if (p1) {
            //point1.setCoordinates(COORDS_BY.USER, p1.usrCoords.slice(1));
            point1.setCoordinates(COORDS_BY.USER, p1.usrCoords);
        }
        if (p2) {
            //point2.setCoordinates(COORDS_BY.USER, p2.usrCoords.slice(1));
            point2.setCoordinates(COORDS_BY.USER, p2.usrCoords);
        }
    }
    /**
     * A line can be a segment, a straight, or a ray. so it is not always delimited by point1 and point2.
     *
     * This method adjusts the line's delimiting points taking into account its nature, the viewport defined
     * by the board.
     *
     * A segment is delimited by start and end point, a straight line or ray is delimited until it meets the
     * boards boundaries. However, if the line has infinite ticks, it will be delimited by the projection of
     * the boards vertices onto itself.
     *
     * @param {JXG.Line} el Reference to a line object, that needs calculation of start and end point.
     * @param {JXG.Coords} point1 Coordinates of the point where line drawing begins. This value is calculated and
     * set by this method.
     * @param {JXG.Coords} point2 Coordinates of the point where line drawing ends. This value is calculated and set
     * by this method.
     * @see Line
     * @see JXG.Line
     */
    static calcLineDelimitingPoints(el, point1, point2) {
        var distP1P2, boundingBox, lineSlope, intersect1, intersect2, straightFirst, straightLast, c, p1, p2, takePoint1 = false, takePoint2 = false;
        straightFirst = el.evalVisProp('straightfirst');
        straightLast = el.evalVisProp('straightlast');
        // If one of the point is an ideal point in homogeneous coordinates
        // drawing of line segments or rays are not possible.
        if (Math.abs(point1.scrCoords[0]) < JSXMath.eps) {
            straightFirst = true;
        }
        if (Math.abs(point2.scrCoords[0]) < JSXMath.eps) {
            straightLast = true;
        }
        // Compute the stdform of the line in screen coordinates.
        c = [];
        c[0] =
            el.stdform[0] -
                (el.stdform[1] * el.board.origin.scrCoords[1]) / el.board.unitX +
                (el.stdform[2] * el.board.origin.scrCoords[2]) / el.board.unitY;
        c[1] = el.stdform[1] / el.board.unitX;
        c[2] = -el.stdform[2] / el.board.unitY;
        // p1=p2
        if (isNaN(c[0] + c[1] + c[2])) {
            return;
        }
        takePoint1 = !straightFirst;
        takePoint2 = !straightLast;
        // Intersect the board vertices on the line to establish the available visual space for the infinite ticks
        // Based on the slope of the line we can optimise and only project the two outer vertices
        // boundingBox = [x1, y1, x2, y2] upper left, lower right vertices
        boundingBox = el.board.getBoundingBox();
        lineSlope = el.getSlope();
        if (lineSlope >= 0) {
            // project vertices (x2,y1) (x1, y2)
            intersect1 = this.projectPointToLine({ coords: { usrCoords: [1, boundingBox[2], boundingBox[1]] } }, el, el.board);
            intersect2 = this.projectPointToLine({ coords: { usrCoords: [1, boundingBox[0], boundingBox[3]] } }, el, el.board);
        }
        else {
            // project vertices (x1, y1) (x2, y2)
            intersect1 = this.projectPointToLine({ coords: { usrCoords: [1, boundingBox[0], boundingBox[1]] } }, el, el.board);
            intersect2 = this.projectPointToLine({ coords: { usrCoords: [1, boundingBox[2], boundingBox[3]] } }, el, el.board);
        }
        /**
         * we have four points:
         * point1 and point2 are the first and the second defining point on the line,
         * intersect1, intersect2 are the intersections of the line with border around the board.
         */
        /*
         * Here we handle rays/segments where both defining points are outside of the board.
         */
        if (!takePoint1 && !takePoint2) {
            // Segment, if segment does not cross the board, do nothing
            if (!straightFirst && !straightLast) {
                distP1P2 = point1.distance(COORDS_BY.USER, point2);
                // if  intersect1 not between point1 and point2
                if (Math.abs(point1.distance(COORDS_BY.USER, intersect1) +
                    intersect1.distance(COORDS_BY.USER, point2) -
                    distP1P2) > JSXMath.eps) {
                    return;
                }
                // if insersect2 not between point1 and point2
                if (Math.abs(point1.distance(COORDS_BY.USER, intersect2) +
                    intersect2.distance(COORDS_BY.USER, point2) -
                    distP1P2) > JSXMath.eps) {
                    return;
                }
            }
            // If both points are outside and the complete ray is outside we do nothing
            // Ray starting at point 1
            if (!straightFirst &&
                straightLast &&
                !this.isSameDirection(point1, point2, intersect1) &&
                !this.isSameDirection(point1, point2, intersect2)) {
                return;
            }
            // Ray starting at point 2
            if (straightFirst &&
                !straightLast &&
                !this.isSameDirection(point2, point1, intersect1) &&
                !this.isSameDirection(point2, point1, intersect2)) {
                return;
            }
        }
        /*
         * If at least one of the defining points is outside of the board
         * we take intersect1 or intersect2 as one of the end points
         * The order is also important for arrows of axes
         */
        if (!takePoint1) {
            if (!takePoint2) {
                // Two border intersection points are used
                if (this.isSameDir(point1, point2, intersect1, intersect2)) {
                    p1 = intersect1;
                    p2 = intersect2;
                }
                else {
                    p2 = intersect1;
                    p1 = intersect2;
                }
            }
            else {
                // One border intersection points is used
                if (this.isSameDir(point1, point2, intersect1, intersect2)) {
                    p1 = intersect1;
                }
                else {
                    p1 = intersect2;
                }
            }
        }
        else {
            if (!takePoint2) {
                // One border intersection points is used
                if (this.isSameDir(point1, point2, intersect1, intersect2)) {
                    p2 = intersect2;
                }
                else {
                    p2 = intersect1;
                }
            }
        }
        if (p1) {
            //point1.setCoordinates(COORDS_BY.USER, p1.usrCoords.slice(1));
            point1.setCoordinates(COORDS_BY.USER, p1.usrCoords);
        }
        if (p2) {
            //point2.setCoordinates(COORDS_BY.USER, p2.usrCoords.slice(1));
            point2.setCoordinates(COORDS_BY.USER, p2.usrCoords);
        }
    }
    /**
     * Calculates the visProp.position corresponding to a given angle.
     * @param {number} angle angle in radians. Must be in range (-2pi,2pi).
     */
    static calcLabelQuadrant(angle) {
        var q;
        if (angle < 0) {
            angle += 2 * Math.PI;
        }
        q = Math.floor((angle + Math.PI / 8) / (Math.PI / 4)) % 8;
        return ["rt", "urt", "top", "ulft", "lft", "llft", "lrt"][q];
    }
    /**
     * The vectors <tt>p2-p1</tt> and <tt>i2-i1</tt> are supposed to be collinear. If their cosine is positive
     * they point into the same direction otherwise they point in opposite direction.
     * @param {JXG.Coords} p1
     * @param {JXG.Coords} p2
     * @param {JXG.Coords} i1
     * @param {JXG.Coords} i2
     * @returns {Boolean} True, if <tt>p2-p1</tt> and <tt>i2-i1</tt> point into the same direction
     */
    static isSameDir(p1, p2, i1, i2) {
        var dpx = p2.usrCoords[1] - p1.usrCoords[1], dpy = p2.usrCoords[2] - p1.usrCoords[2], dix = i2.usrCoords[1] - i1.usrCoords[1], diy = i2.usrCoords[2] - i1.usrCoords[2];
        if (Math.abs(p2.usrCoords[0]) < JSXMath.eps) {
            dpx = p2.usrCoords[1];
            dpy = p2.usrCoords[2];
        }
        if (Math.abs(p1.usrCoords[0]) < JSXMath.eps) {
            dpx = -p1.usrCoords[1];
            dpy = -p1.usrCoords[2];
        }
        return dpx * dix + dpy * diy >= 0;
    }
    /**
     * If you're looking from point "start" towards point "s" and you can see the point "p", return true.
     * Otherwise return false.
     * @param {JXG.Coords} start The point you're standing on.
     * @param {JXG.Coords} p The point in which direction you're looking.
     * @param {JXG.Coords} s The point that should be visible.
     * @returns {Boolean} True, if from start the point p is in the same direction as s is, that means s-start = k*(p-start) with k>=0.
     */
    static isSameDirection(start, p, s) {
        var dx, dy, sx, sy, r = false;
        dx = p.usrCoords[1] - start.usrCoords[1];
        dy = p.usrCoords[2] - start.usrCoords[2];
        sx = s.usrCoords[1] - start.usrCoords[1];
        sy = s.usrCoords[2] - start.usrCoords[2];
        if (Math.abs(dx) < JSXMath.eps) {
            dx = 0;
        }
        if (Math.abs(dy) < JSXMath.eps) {
            dy = 0;
        }
        if (Math.abs(sx) < JSXMath.eps) {
            sx = 0;
        }
        if (Math.abs(sy) < JSXMath.eps) {
            sy = 0;
        }
        if (dx >= 0 && sx >= 0) {
            r = (dy >= 0 && sy >= 0) || (dy <= 0 && sy <= 0);
        }
        else if (dx <= 0 && sx <= 0) {
            r = (dy >= 0 && sy >= 0) || (dy <= 0 && sy <= 0);
        }
        return r;
    }
    /**
     * Determinant of three points in the Euclidean plane.
     * Zero, if the points are collinear. Used to determine of a point q is left or
     * right to a segment defined by points p1 and p2.
     * <p>
     * Non-homogeneous version.
     *
     * @param  {Array|JXG.Point} p1 First point or its coordinates of the segment. Point object or array of length 3. First (homogeneous) coordinate is equal to 1.
     * @param  {Array|JXG.Point} p2 Second point or its coordinates of the segment. Point object or array of length 3. First (homogeneous) coordinate is equal to 1.
     * @param  {Array|JXG.Point} q Point or its coordinates. Point object or array of length 3. First (homogeneous) coordinate is equal to 1.
     * @return {Number} Signed area of the triangle formed by these three points.
     *
     * @see Geometry.windingNumber
     */
    static det3p(p1, p2, q) {
        var pp1, pp2, qq;
        if (Type.isPoint(p1)) {
            pp1 = p1.Coords(true);
        }
        else {
            pp1 = p1;
        }
        if (Type.isPoint(p2)) {
            pp2 = p2.Coords(true);
        }
        else {
            pp2 = p2;
        }
        if (Type.isPoint(q)) {
            qq = q.Coords(true);
        }
        else {
            qq = q;
        }
        return (pp1[1] - qq[1]) * (pp2[2] - qq[2]) - (pp2[1] - qq[1]) * (pp1[2] - qq[2]);
    }
    /**
     * Winding number of a point in respect to a polygon path.
     *
     * The point is regarded outside if the winding number is zero,
     * inside otherwise. The algorithm tries to find degenerate cases, i.e.
     * if the point is on the path. This is regarded as "outside".
     * If the point is a vertex of the path, it is regarded as "inside".
     *
     * Implementation of algorithm 7 from "The point in polygon problem for
     * arbitrary polygons" by Kai Hormann and Alexander Agathos, Computational Geometry,
     * Volume 20, Issue 3, November 2001, Pages 131-144.
     *
     * @param  {Array} usrCoords Homogenous coordinates of the point
     * @param  {Array} path      Array of points / coords determining a path, i.e. the vertices of the polygon / path. The array elements
     * do not have to be full points, but have to have a subobject "coords" or should be of type JXG.Coords.
     * @param  {Boolean} [doNotClosePath=false] If true the last point of the path is not connected to the first point.
     * This is necessary if the path consists of two or more closed subpaths, e.g. if the figure has a hole.
     *
     * @return {Number}          Winding number of the point. The point is
     *                           regarded outside if the winding number is zero,
     *                           inside otherwise.
     */
    static windingNumber(usrCoords, path, doNotClosePath) {
        var wn = 0, le = path.length, x = usrCoords[1], y = usrCoords[2], p0, p1, p2, d, sign, i, off = 0;
        if (le === 0) {
            return 0;
        }
        doNotClosePath = doNotClosePath || false;
        if (doNotClosePath) {
            off = 1;
        }
        // Infinite points are declared outside
        if (isNaN(x) || isNaN(y)) {
            return 1;
        }
        if (Type.exists(path[0].coords)) {
            p0 = path[0].coords;
            p1 = path[le - 1].coords;
        }
        else {
            p0 = path[0];
            p1 = path[le - 1];
        }
        // Handle the case if the point is the first vertex of the path, i.e. inside.
        if (p0.usrCoords[1] === x && p0.usrCoords[2] === y) {
            return 1;
        }
        for (i = 0; i < le - off; i++) {
            // Consider the edge from p1 = path[i] to p2 = path[i+1]isClosedPath
            if (Type.exists(path[i].coords)) {
                p1 = path[i].coords.usrCoords;
                p2 = path[(i + 1) % le].coords.usrCoords;
            }
            else {
                p1 = path[i].usrCoords;
                p2 = path[(i + 1) % le].usrCoords;
            }
            // If one of the two points p1, p2 is undefined or infinite,
            // move on.
            if (p1[0] === 0 ||
                p2[0] === 0 ||
                isNaN(p1[1]) ||
                isNaN(p2[1]) ||
                isNaN(p1[2]) ||
                isNaN(p2[2])) {
                continue;
            }
            if (p2[2] === y) {
                if (p2[1] === x) {
                    return 1;
                }
                if (p1[2] === y && p2[1] > x === p1[1] < x) {
                    return 0;
                }
            }
            if (p1[2] < y !== p2[2] < y) {
                // Crossing
                sign = 2 * (p2[2] > p1[2] ? 1 : 0) - 1;
                if (p1[1] >= x) {
                    if (p2[1] > x) {
                        wn += sign;
                    }
                    else {
                        d = this.det3p(p1, p2, usrCoords);
                        if (d === 0) {
                            // Point is on line, i.e. outside
                            return 0;
                        }
                        if (d > 0 + JSXMath.eps === p2[2] > p1[2]) {
                            // Right crossing
                            wn += sign;
                        }
                    }
                }
                else {
                    if (p2[1] > x) {
                        d = this.det3p(p1, p2, usrCoords);
                        if (d > 0 + JSXMath.eps === p2[2] > p1[2]) {
                            // Right crossing
                            wn += sign;
                        }
                    }
                }
            }
        }
        return wn;
    }
    /**
     * Decides if a point (x,y) is inside of a path / polygon.
     * Does not work correct if the path has hole. In this case, windingNumber is the preferred method.
     * Implements W. Randolf Franklin's pnpoly method.
     *
     * See <a href="https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html">https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html</a>.
     *
     * @param {Number} x_in x-coordinate (screen or user coordinates)
     * @param {Number} y_in y-coordinate (screen or user coordinates)
     * @param  {Array} path  Array of points / coords determining a path, i.e. the vertices of the polygon / path. The array elements
     * do not have to be full points, but have to have a subobject "coords" or should be of type JXG.Coords.
     * @param {Number} [coord_type=COORDS_BY.SCREEN] Type of coordinates used here.
     *   Possible values are <b>COORDS_BY.USER</b> and <b>COORDS_BY.SCREEN</b>.
     *   Default value is COORDS_BY.SCREEN.
     * @param {JXG.Board} board Board object
     *
     * @returns {Boolean} if (x_in, y_in) is inside of the polygon.
     * @see JXG.Polygon#hasPoint
     * @see JXG.Polygon#pnpoly
     * @see Geometry.windingNumber
     *
     * @example
     * var pol = board.create('polygon', [[-1,2], [2,2], [-1,4]]);
     * var p = board.create('point', [4, 3]);
     * var txt = board.create('text', [-1, 0.5, function() {
     *   return 'Point A is inside of the polygon = ' +
     *     Geometry.pnpoly(p.X(), p.Y(), pol.vertices, COORDS_BY.USER, board);
     * }]);
     *
     * </pre><div id="JXG4656ed42-f965-4e35-bb66-c334a4529683" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG4656ed42-f965-4e35-bb66-c334a4529683',
     *             {boundingbox: [-2, 5, 5,-2], axis: true, showcopyright: false, shownavigation: false});
     *     var pol = board.create('polygon', [[-1,2], [2,2], [-1,4]]);
     *     var p = board.create('point', [4, 3]);
     *     var txt = board.create('text', [-1, 0.5, function() {
     *     		return 'Point A is inside of the polygon = ' + Geometry.pnpoly(p.X(), p.Y(), pol.vertices, COORDS_BY.USER, board);
     *     }]);
     *
     *     })();
     *
     * </script><pre>
     *
     */
    static pnpoly(x_in, y_in, path, coord_type, board) {
        var i, j, vi, vj, len, x, y, crds, v = path, isIn = false;
        if (coord_type === COORDS_BY.USER) {
            crds = new Coords(COORDS_BY.USER, [x_in, y_in], board);
            x = crds.scrCoords[1];
            y = crds.scrCoords[2];
        }
        else {
            x = x_in;
            y = y_in;
        }
        len = path.length;
        for (i = 0, j = len - 2; i < len - 1; j = i++) {
            vi = Type.exists(v[i].coords) ? v[i].coords : v[i];
            vj = Type.exists(v[j].coords) ? v[j].coords : v[j];
            if (vi.scrCoords[2] > y !== vj.scrCoords[2] > y &&
                x <
                    ((vj.scrCoords[1] - vi.scrCoords[1]) * (y - vi.scrCoords[2])) /
                        (vj.scrCoords[2] - vi.scrCoords[2]) +
                        vi.scrCoords[1]) {
                isIn = !isIn;
            }
        }
        return isIn;
    }
    /****************************************/
    /****          INTERSECTIONS         ****/
    /****************************************/
    /**
     * Generate the function which computes the coordinates of the intersection point.
     * Primarily used in {@link JXG.Point.createIntersectionPoint}.
     * @param {JXG.Board} board object
     * @param {JXG.Line,JXG.Circle_JXG.Line,JXG.Circle_Number|Function} el1,el2,i The result will be a intersection point on el1 and el2.
     * i determines the intersection point if two points are available: <ul>
     *   <li>i==0: use the positive square root,</li>
     *   <li>i==1: use the negative square root.</li></ul>
     * @param {Boolean} alwaysintersect. Flag that determines if segments and arc can have an outer intersection point
     * on their defining line or circle.
     * @returns {Function} Function returning a {@link JXG.Coords} object that determines
     * the intersection point.
     *
     * @see JXG.Point.createIntersectionPoint
     */
    static intersectionFunction(board, el1, el2, i, j, alwaysintersect) {
        var func, that = this, el1_isArcType = false, el2_isArcType = false;
        el1_isArcType =
            el1.elementClass === OBJECT_CLASS.CURVE &&
                (el1.type === OBJECT_TYPE.ARC || el1.type === OBJECT_TYPE.SECTOR)
                ? true
                : false;
        el2_isArcType =
            el2.elementClass === OBJECT_CLASS.CURVE &&
                (el2.type === OBJECT_TYPE.ARC || el2.type === OBJECT_TYPE.SECTOR)
                ? true
                : false;
        if ((el1.elementClass === OBJECT_CLASS.CURVE ||
            el2.elementClass === OBJECT_CLASS.CURVE) &&
            (el1.elementClass === OBJECT_CLASS.CURVE ||
                el1.elementClass === OBJECT_CLASS.CIRCLE) &&
            (el2.elementClass === OBJECT_CLASS.CURVE ||
                el2.elementClass === OBJECT_CLASS.CIRCLE) /*&&
        !(el1_isArcType && el2_isArcType)*/) {
            // curve - curve
            // with the exception that both elements are arc types
            /** @ignore */
            func = function () {
                return that.meetCurveCurve(el1, el2, i, j, el1.board);
            };
        }
        else if ((el1.elementClass === OBJECT_CLASS.CURVE &&
            !el1_isArcType &&
            el2.elementClass === OBJECT_CLASS.LINE) ||
            (el2.elementClass === OBJECT_CLASS.CURVE &&
                !el2_isArcType &&
                el1.elementClass === OBJECT_CLASS.LINE)) {
            // curve - line (this includes intersections between conic sections and lines)
            // with the exception that the curve is of arc type
            /** @ignore */
            func = function () {
                return that.meetCurveLine(el1, el2, i, el1.board, Type.evaluate(alwaysintersect));
            };
        }
        else if (el1.type === OBJECT_TYPE.POLYGON ||
            el2.type === OBJECT_TYPE.POLYGON) {
            // polygon - other
            // Uses the Greiner-Hormann clipping algorithm
            // Not implemented: polygon - point
            if (el1.elementClass === OBJECT_CLASS.LINE) {
                // line - path
                /** @ignore */
                func = function () {
                    var first1 = el1.evalVisProp('straightfirst'), last1 = el1.evalVisProp('straightlast'), first2 = el2.evalVisProp('straightfirst'), last2 = el2.evalVisProp('straightlast'), a_not;
                    a_not = (!Type.evaluate(alwaysintersect) && (!first1 || !last1 || !first2 || !last2));
                    return that.meetPolygonLine(el2, el1, i, el1.board, a_not);
                };
            }
            else if (el2.elementClass === OBJECT_CLASS.LINE) {
                // path - line
                /** @ignore */
                func = function () {
                    var first1 = el1.evalVisProp('straightfirst'), last1 = el1.evalVisProp('straightlast'), first2 = el2.evalVisProp('straightfirst'), last2 = el2.evalVisProp('straightlast'), a_not;
                    a_not = (!Type.evaluate(alwaysintersect) && (!first1 || !last1 || !first2 || !last2));
                    return that.meetPolygonLine(el1, el2, i, el1.board, a_not);
                };
            }
            else {
                // path - path
                /** @ignore */
                func = function () {
                    return that.meetPathPath(el1, el2, i, el1.board);
                };
            }
        }
        else if (el1.elementClass === OBJECT_CLASS.LINE &&
            el2.elementClass === OBJECT_CLASS.LINE) {
            // line - line, lines may also be segments.
            /** @ignore */
            func = function () {
                var res, c, first1 = el1.evalVisProp('straightfirst'), last1 = el1.evalVisProp('straightlast'), first2 = el2.evalVisProp('straightfirst'), last2 = el2.evalVisProp('straightlast');
                /**
                 * If one of the lines is a segment or ray and
                 * the intersection point should disappear if outside
                 * of the segment or ray we call
                 * meetSegmentSegment
                 */
                if (!Type.evaluate(alwaysintersect) &&
                    (!first1 || !last1 || !first2 || !last2)) {
                    res = that.meetSegmentSegment(el1.point1.coords.usrCoords, el1.point2.coords.usrCoords, el2.point1.coords.usrCoords, el2.point2.coords.usrCoords);
                    if ((!first1 && res[1] < 0) ||
                        (!last1 && res[1] > 1) ||
                        (!first2 && res[2] < 0) ||
                        (!last2 && res[2] > 1)) {
                        // Non-existent
                        c = [0, NaN, NaN];
                    }
                    else {
                        c = res[0];
                    }
                    return new Coords(COORDS_BY.USER, c, el1.board);
                }
                return that.meet(el1.stdform, el2.stdform, i, el1.board);
            };
        }
        else {
            // All other combinations of circles and lines,
            // Arc types are treated as circles.
            /** @ignore */
            func = function () {
                var res = that.meet(el1.stdform, el2.stdform, i, el1.board), has = true, first, last, r;
                if (Type.evaluate(alwaysintersect)) {
                    return res;
                }
                if (el1.elementClass === OBJECT_CLASS.LINE) {
                    first = el1.evalVisProp('straightfirst');
                    last = el1.evalVisProp('straightlast');
                    if (!first || !last) {
                        r = that.affineRatio(el1.point1.coords, el1.point2.coords, res);
                        if ((!last && r > 1 + JSXMath.eps) || (!first && r < 0 - JSXMath.eps)) {
                            return new Coords(COORDS_BY.USER, [0, NaN, NaN], el1.board);
                        }
                    }
                }
                if (el2.elementClass === OBJECT_CLASS.LINE) {
                    first = el2.evalVisProp('straightfirst');
                    last = el2.evalVisProp('straightlast');
                    if (!first || !last) {
                        r = that.affineRatio(el2.point1.coords, el2.point2.coords, res);
                        if ((!last && r > 1 + JSXMath.eps) || (!first && r < 0 - JSXMath.eps)) {
                            return new Coords(COORDS_BY.USER, [0, NaN, NaN], el1.board);
                        }
                    }
                }
                if (el1_isArcType) {
                    has = that.coordsOnArc(el1, res);
                    if (has && el2_isArcType) {
                        has = that.coordsOnArc(el2, res);
                    }
                    if (!has) {
                        return new Coords(COORDS_BY.USER, [0, NaN, NaN], el1.board);
                    }
                }
                return res;
            };
        }
        return func;
    }
    static otherIntersectionFunction(input, others, alwaysintersect, precision) {
        var func, board, el1, el2, that = this;
        el1 = input[0];
        el2 = input[1];
        board = el1.board;
        /** @ignore */
        func = function () {
            var i, k, c, d, isClose, le = others.length, eps = Type.evaluate(precision);
            for (i = le; i >= 0; i--) {
                if (el1.elementClass === OBJECT_CLASS.CIRCLE &&
                    [OBJECT_CLASS.CIRCLE, OBJECT_CLASS.LINE].indexOf(el2.elementClass) >= 0) {
                    // circle, circle|line
                    c = that.meet(el1.stdform, el2.stdform, i, board);
                }
                else if (el1.elementClass === OBJECT_CLASS.CURVE &&
                    [OBJECT_CLASS.CURVE, OBJECT_CLASS.CIRCLE].indexOf(el2.elementClass) >= 0) {
                    // curve, circle|curve
                    c = that.meetCurveCurve(el1, el2, i, 0, board, 'segment');
                }
                else if (el1.elementClass === OBJECT_CLASS.CURVE && el2.elementClass === OBJECT_CLASS.LINE) {
                    // curve, line
                    if (Type.exists(el1.dataX)) {
                        c = Geometry.meetCurveLine(el1, el2, i, el1.board, Type.evaluate(alwaysintersect));
                    }
                    else {
                        c = Geometry.meetCurveLineContinuous(el1, el2, i, el1.board);
                    }
                }
                // If the intersection is close to one of the points in other
                // we have to search for another intersection point.
                isClose = false;
                for (k = 0; !isClose && k < le; k++) {
                    d = c.distance(COORDS_BY.USER, others[k].coords);
                    if (d < eps) {
                        isClose = true;
                    }
                }
                if (!isClose) {
                    // We are done, the intersection is away from any other
                    // intersection point.
                    return c;
                }
            }
            // Otherwise we return the last intersection point
            return c;
        };
        return func;
    }
    /**
     * Returns true if the coordinates are on the arc element,
     * false otherwise. Usually, coords is an intersection
     * on the circle line. Now it is decided if coords are on the
     * circle restricted to the arc line.
     * @param  {Arc} arc arc or sector element
     * @param  {JXG.Coords} coords Coords object of an intersection
     * @returns {Boolean}
     * @private
     */
    static coordsOnArc(arc, coords) {
        var angle = this.rad(arc.radiuspoint, arc.center, coords.usrCoords.slice(1)), alpha = 0.0, beta = this.rad(arc.radiuspoint, arc.center, arc.anglepoint), ev_s = arc.evalVisProp('selection');
        if ((ev_s === "minor" && beta > Math.PI) || (ev_s === "major" && beta < Math.PI)) {
            alpha = beta;
            beta = 2 * Math.PI;
        }
        if (angle < alpha || angle > beta) {
            return false;
        }
        return true;
    }
    /**
     * Computes the intersection of a pair of lines, circles or both.
     * It uses the internal data array stdform of these elements.
     * @param {Array} el1 stdform of the first element (line or circle)
     * @param {Array} el2 stdform of the second element (line or circle)
     * @param {Number|Function} i Index of the intersection point that should be returned.
     * @param board Reference to the board.
     * @returns {JXG.Coords} Coordinates of one of the possible two or more intersection points.
     * Which point will be returned is determined by i.
     */
    static meet(el1, el2, i, board) {
        var result, eps = JSXMath.eps;
        if (Math.abs(el1[3]) < eps && Math.abs(el2[3]) < eps) {
            // line line
            result = this.meetLineLine(el1, el2, i, board);
        }
        else if (Math.abs(el1[3]) >= eps && Math.abs(el2[3]) < eps) {
            // circle line
            result = this.meetLineCircle(el2, el1, i, board);
        }
        else if (Math.abs(el1[3]) < eps && Math.abs(el2[3]) >= eps) {
            // line circle
            result = this.meetLineCircle(el1, el2, i, board);
        }
        else {
            // circle circle
            result = this.meetCircleCircle(el1, el2, i, board);
        }
        return result;
    }
    /**
     * Intersection of the line with the board
     * @param  {Array}     line   stdform of the line in screen coordinates
     * @param  {JXG.Board} board  reference to a board.
     * @param  {Number}    margin optional margin, to avoid the display of the small sides of lines.
     * @returns {Array}            [intersection coords 1, intersection coords 2]
     */
    static meetLineBoard(line, board, margin) {
        // Intersect the line with the four borders of the board.
        var s = [], intersect1, intersect2, i, j;
        if (!Type.exists(margin)) {
            margin = 0;
        }
        // top
        s[0] = JSXMath.crossProduct(line, [margin, 0, 1]);
        // left
        s[1] = JSXMath.crossProduct(line, [margin, 1, 0]);
        // bottom
        s[2] = JSXMath.crossProduct(line, [-margin - board.canvasHeight, 0, 1]);
        // right
        s[3] = JSXMath.crossProduct(line, [-margin - board.canvasWidth, 1, 0]);
        // Normalize the intersections
        for (i = 0; i < 4; i++) {
            if (Math.abs(s[i][0]) > JSXMath.eps) {
                for (j = 2; j > 0; j--) {
                    s[i][j] /= s[i][0];
                }
                s[i][0] = 1.0;
            }
        }
        // line is parallel to "left", take "top" and "bottom"
        if (Math.abs(s[1][0]) < JSXMath.eps) {
            intersect1 = s[0]; // top
            intersect2 = s[2]; // bottom
            // line is parallel to "top", take "left" and "right"
        }
        else if (Math.abs(s[0][0]) < JSXMath.eps) {
            intersect1 = s[1]; // left
            intersect2 = s[3]; // right
            // left intersection out of board (above)
        }
        else if (s[1][2] < 0) {
            intersect1 = s[0]; // top
            // right intersection out of board (below)
            if (s[3][2] > board.canvasHeight) {
                intersect2 = s[2]; // bottom
            }
            else {
                intersect2 = s[3]; // right
            }
            // left intersection out of board (below)
        }
        else if (s[1][2] > board.canvasHeight) {
            intersect1 = s[2]; // bottom
            // right intersection out of board (above)
            if (s[3][2] < 0) {
                intersect2 = s[0]; // top
            }
            else {
                intersect2 = s[3]; // right
            }
        }
        else {
            intersect1 = s[1]; // left
            // right intersection out of board (above)
            if (s[3][2] < 0) {
                intersect2 = s[0]; // top
                // right intersection out of board (below)
            }
            else if (s[3][2] > board.canvasHeight) {
                intersect2 = s[2]; // bottom
            }
            else {
                intersect2 = s[3]; // right
            }
        }
        return [
            new Coords(COORDS_BY.SCREEN, intersect1.slice(1), board),
            new Coords(COORDS_BY.SCREEN, intersect2.slice(1), board)
        ];
    }
    /**
     * Intersection of two lines.
     * @param {Array} l1 stdform of the first line
     * @param {Array} l2 stdform of the second line
     * @param {number} i unused
     * @param {JXG.Board} board Reference to the board.
     * @returns {JXG.Coords} Coordinates of the intersection point.
     */
    static meetLineLine(l1, l2, i, board) {
        var s = isNaN(l1[5] + l2[5]) ? [0, 0, 0] : JSXMath.crossProduct(l1, l2);
        // Make intersection of parallel lines more robust:
        if (Math.abs(s[0]) < 1.0e-14) {
            s[0] = 0;
        }
        return new Coords(COORDS_BY.USER, s, board);
    }
    /**
     * Intersection of line and circle.
     * @param {Array} lin stdform of the line
     * @param {Array} circ stdform of the circle
     * @param {number|function} i number of the returned intersection point.
     *   i==0: use the positive square root,
     *   i==1: use the negative square root.
     * @param {JXG.Board} board Reference to a board.
     * @returns {JXG.Coords} Coordinates of the intersection point
     */
    static meetLineCircle(lin, circ, i, board) {
        var a, b, c, d, n, A, B, C, k, t;
        // Radius is zero, return center of circle
        if (circ[4] < JSXMath.eps) {
            if (Math.abs(JSXMath.innerProduct([1, circ[6], circ[7]], lin, 3)) < JSXMath.eps) {
                return new Coords(COORDS_BY.USER, circ.slice(6, 8), board);
            }
            return new Coords(COORDS_BY.USER, [NaN, NaN], board);
        }
        c = circ[0];
        b = circ.slice(1, 3);
        a = circ[3];
        d = lin[0];
        n = lin.slice(1, 3);
        // Line is assumed to be normalized. Therefore, nn==1 and we can skip some operations:
        /*
         var nn = n[0]*n[0]+n[1]*n[1];
         A = a*nn;
         B = (b[0]*n[1]-b[1]*n[0])*nn;
         C = a*d*d - (b[0]*n[0]+b[1]*n[1])*d + c*nn;
         */
        A = a;
        B = b[0] * n[1] - b[1] * n[0];
        C = a * d * d - (b[0] * n[0] + b[1] * n[1]) * d + c;
        k = B * B - 4 * A * C;
        if (k > -JSXMath.eps * JSXMath.eps) {
            k = Math.sqrt(Math.abs(k));
            t = [(-B + k) / (2 * A), (-B - k) / (2 * A)];
            return Type.evaluate(i) === 0
                ? new Coords(COORDS_BY.USER, [-t[0] * -n[1] - d * n[0], -t[0] * n[0] - d * n[1]], board)
                : new Coords(COORDS_BY.USER, [-t[1] * -n[1] - d * n[0], -t[1] * n[0] - d * n[1]], board);
        }
        return new Coords(COORDS_BY.USER, [0, 0, 0], board);
    }
    /**
     * Intersection of two circles.
     * @param {Array} circ1 stdform of the first circle
     * @param {Array} circ2 stdform of the second circle
     * @param {number|function} i number of the returned intersection point.
     *   i==0: use the positive square root,
     *   i==1: use the negative square root.
     * @param {JXG.Board} board Reference to the board.
     * @returns {JXG.Coords} Coordinates of the intersection point
     */
    static meetCircleCircle(circ1, circ2, i, board) {
        var radicalAxis;
        // Radius is zero, return center of circle, if on other circle
        if (circ1[4] < JSXMath.eps) {
            if (Math.abs(this.distance(circ1.slice(6, 2), circ2.slice(6, 8)) - circ2[4]) <
                JSXMath.eps) {
                return new Coords(COORDS_BY.USER, circ1.slice(6, 8), board);
            }
            return new Coords(COORDS_BY.USER, [0, 0, 0], board);
        }
        // Radius is zero, return center of circle, if on other circle
        if (circ2[4] < JSXMath.eps) {
            if (Math.abs(this.distance(circ2.slice(6, 2), circ1.slice(6, 8)) - circ1[4]) <
                JSXMath.eps) {
                return new Coords(COORDS_BY.USER, circ2.slice(6, 8), board);
            }
            return new Coords(COORDS_BY.USER, [0, 0, 0], board);
        }
        radicalAxis = [
            circ2[3] * circ1[0] - circ1[3] * circ2[0],
            circ2[3] * circ1[1] - circ1[3] * circ2[1],
            circ2[3] * circ1[2] - circ1[3] * circ2[2],
            0,
            1,
            Infinity,
            Infinity,
            Infinity
        ];
        radicalAxis = JSXMath.normalize(radicalAxis);
        return this.meetLineCircle(radicalAxis, circ1, i, board);
    }
    /**
     * Compute an intersection of the curves c1 and c2.
     * We want to find values t1, t2 such that
     * c1(t1) = c2(t2), i.e. (c1_x(t1)-c2_x(t2),c1_y(t1)-c2_y(t2)) = (0,0).
     *
     * Methods: segment-wise intersections (default) or generalized Newton method.
     * @param {JXG.Curve} c1 Curve, Line or Circle
     * @param {JXG.Curve} c2 Curve, Line or Circle
     * @param {Number|Function} nr the nr-th intersection point will be returned.
     * @param {Number} t2ini not longer used.
     * @param {JXG.Board} [board=c1.board] Reference to a board object.
     * @param {String} [method='segment'] Intersection method, possible values are 'newton' and 'segment'.
     * @returns {JXG.Coords} intersection point
     */
    static meetCurveCurve(c1, c2, nr, t2ini, board, method = 'newton') {
        var co, i = Type.evaluate(nr);
        if (Type.exists(method) && method === "newton") {
            // delete Numerics.generalizedNewton.t1memo;
            // delete Numerics.generalizedNewton.t2memo;
            co = Numerics.generalizedNewton(c1, c2, i, t2ini);
        }
        else {
            if (c1.bezierDegree === 3 || c2.bezierDegree === 3) {
                co = this.meetBezierCurveRedBlueSegments(c1, c2, i);
            }
            else {
                co = this.meetCurveRedBlueSegments(c1, c2, i, board);
            }
            // // We might add a Newton iteration if the segment search fails?
            // // However, we would have to apply evt. transformations to the curves
            // if (co[0] === 0 && isNaN(co[1]) && isNaN(co[2])) {
            //     co = Numerics.generalizedNewton(c1, c2, i, t2ini);
            // }
        }
        return new Coords(COORDS_BY.USER, co, board);
    }
    /**
     * Intersection of curve with line,
     * Order of input does not matter for el1 and el2.
     * From version 0.99.7 on this method calls
     * {@link Geometry.meetCurveLineDiscrete}.
     * If higher precision is needed, {@link Geometry.meetCurveLineContinuous}
     * has to be used.
     *
     * @param {JXG.Curve|JXG.Line} el1 Curve or Line
     * @param {JXG.Curve|JXG.Line} el2 Curve or Line
     * @param {Number|Function} nr the nr-th intersection point will be returned.
     * @param {JXG.Board} [board=el1.board] Reference to a board object.
     * @param {Boolean} alwaysIntersect If false just the segment between the two defining points are tested for intersection
     * @returns {JXG.Coords} Intersection point. In case no intersection point is detected,
     * the ideal point [0,1,0] is returned.
     */
    static meetCurveLine(el1, el2, nr, board, alwaysIntersect) {
        var v = [0, NaN, NaN], cu, li;
        if (!Type.exists(board)) {
            board = el1.board;
        }
        if (el1.elementClass === OBJECT_CLASS.CURVE) {
            cu = el1;
            li = el2;
        }
        else {
            cu = el2;
            li = el1;
        }
        v = this.meetCurveLineDiscrete(cu, li, nr, board, !alwaysIntersect);
        return v;
    }
    /**
     * Intersection of line and curve, continuous case.
     * Finds the nr-th intersection point
     * Uses {@link Geometry.meetCurveLineDiscrete} as a first approximation.
     * A more exact solution is then found with {@link JXG.Math.Numerics.root}.
     *
     * @param {JXG.Curve} cu Curve
     * @param {JXG.Line} li Line
     * @param {NumberFunction} nr Will return the nr-th intersection point.
     * @param {JXG.Board} board
     * @param {Boolean} testSegment Test if intersection has to be inside of the segment or somewhere on the
     * line defined by the segment
     * @returns {JXG.Coords} Coords object containing the intersection.
     */
    static meetCurveLineContinuous(cu, li, nr, board, testSegment = false) {
        var func0, func1, t, v, x, y, z, eps = JSXMath.eps, epsLow = JSXMath.eps, steps, delta, tnew, tmin, fmin, i, ft;
        v = this.meetCurveLineDiscrete(cu, li, nr, board, testSegment);
        x = v.usrCoords[1];
        y = v.usrCoords[2];
        func0 = function (t) {
            var c1, c2;
            if (t > cu.maxX() || t < cu.minX()) {
                return Infinity;
            }
            c1 = cu.X(t) - x;
            c2 = cu.Y(t) - y;
            return c1 * c1 + c2 * c2;
            // return c1 * (cu.X(t + h) - cu.X(t - h)) + c2 * (cu.Y(t + h) - cu.Y(t - h)) / h;
        };
        func1 = function (t) {
            var v = li.stdform[0] + li.stdform[1] * cu.X(t) + li.stdform[2] * cu.Y(t);
            return v * v;
        };
        // Find t
        steps = 50;
        delta = (cu.maxX() - cu.minX()) / steps;
        tnew = cu.minX();
        fmin = 0.0001; //eps;
        tmin = NaN;
        for (i = 0; i < steps; i++) {
            t = Numerics.root(func0, [
                Math.max(tnew, cu.minX()),
                Math.min(tnew + delta, cu.maxX())
            ]);
            ft = Math.abs(func0(t));
            if (ft <= fmin) {
                fmin = ft;
                tmin = t;
                if (fmin < eps) {
                    break;
                }
            }
            tnew += delta;
        }
        t = tmin;
        // Compute "exact" t
        t = Numerics.root(func1, [
            Math.max(t - delta, cu.minX()),
            Math.min(t + delta, cu.maxX())
        ]);
        ft = func1(t);
        // Is the point on the line?
        if (isNaN(ft) || Math.abs(ft) > epsLow) {
            z = 0.0; //NaN;
        }
        else {
            z = 1.0;
        }
        return new Coords(COORDS_BY.USER, [z, cu.X(t), cu.Y(t)], board);
    }
    /**
     * Intersection of line and curve, discrete case.
     * Segments are treated as lines.
     * Finding the nr-th intersection point should work for all nr.
     * @param {JXG.Curve} cu
     * @param {JXG.Line} li
     * @param {Number|Function} nr
     * @param {JXG.Board} board
     * @param {Boolean} testSegment Test if intersection has to be inside of the segment or somewhere on the
     * line defined by the segment
     *
     * @returns {JXG.Coords} Intersection point. In case no intersection point is detected,
     * the ideal point [0,1,0] is returned.
     */
    static meetCurveLineDiscrete(cu, li, nr, board, testSegment) {
        var i, j, n = Type.evaluate(nr), p1, p2, p, q, lip1 = li.point1.coords.usrCoords, lip2 = li.point2.coords.usrCoords, d, res, cnt = 0, len = cu.numberPoints, ev_sf = li.evalVisProp('straightfirst'), ev_sl = li.evalVisProp('straightlast');
        // In case, no intersection will be found we will take this
        q = new Coords(COORDS_BY.USER, [0, NaN, NaN], board);
        if (lip1[0] === 0.0) {
            lip1 = [1, lip2[1] + li.stdform[2], lip2[2] - li.stdform[1]];
        }
        else if (lip2[0] === 0.0) {
            lip2 = [1, lip1[1] + li.stdform[2], lip1[2] - li.stdform[1]];
        }
        p2 = cu.points[0].usrCoords;
        for (i = 1; i < len; i += cu.bezierDegree) {
            p1 = p2.slice(0);
            p2 = cu.points[i].usrCoords;
            d = this.distance(p1, p2);
            // The defining points are not identical
            if (d > JSXMath.eps) {
                if (cu.bezierDegree === 3) {
                    res = this.meetBeziersegmentBeziersegment([
                        cu.points[i - 1].usrCoords.slice(1),
                        cu.points[i].usrCoords.slice(1),
                        cu.points[i + 1].usrCoords.slice(1),
                        cu.points[i + 2].usrCoords.slice(1)
                    ], [lip1.slice(1), lip2.slice(1)], testSegment);
                }
                else {
                    res = [this.meetSegmentSegment(p1, p2, lip1, lip2)];
                }
                for (j = 0; j < res.length; j++) {
                    p = res[j];
                    if (0 <= p[1] && p[1] <= 1) {
                        if (cnt === n) {
                            /**
                             * If the intersection point is not part of the segment,
                             * this intersection point is set to non-existent.
                             * This prevents jumping behavior of the intersection points.
                             * But it may be discussed if it is the desired behavior.
                             */
                            if (testSegment &&
                                ((!ev_sf && p[2] < 0) || (!ev_sl && p[2] > 1))) {
                                return q; // break;
                            }
                            q = new Coords(COORDS_BY.USER, p[0], board);
                            return q; // break;
                        }
                        cnt += 1;
                    }
                }
            }
        }
        return q;
    }
    /**
     * Find the n-th intersection point of two curves named red (first parameter) and blue (second parameter).
     * We go through each segment of the red curve and search if there is an intersection with a segment of the blue curve.
     * This double loop, i.e. the outer loop runs along the red curve and the inner loop runs along the blue curve, defines
     * the n-th intersection point. The segments are either line segments or Bezier curves of degree 3. This depends on
     * the property bezierDegree of the curves.
     * <p>
     * This method works also for transformed curves, since only the already
     * transformed points are used.
     *
     * @param {JXG.Curve} red
     * @param {JXG.Curve} blue
     * @param {Number|Function} nr
     * @param {JXG.Board} board Reference to a board object.
     */
    static meetCurveRedBlueSegments(red, blue, nr, board) {
        var i, j, n = Type.evaluate(nr), red1, red2, blue1, blue2, m, minX, maxX, minY, maxY, 
        // For short curve segments, we slightly enlarge
        // the intersection regions in the segments from [0, 1] to [-0.3, 1.3]
        eps = 1 / board.unitX, start = -0.3, end = 1.3, shortRed = false, shortBlue = false, startRed = 0.0, startBlue = 0.0, endRed = 1.0, endBlue = 1.0, 
        // ---
        iFound = 0, lenBlue = blue.numberPoints, lenRed = red.numberPoints;
        if (lenBlue <= 1 || lenRed <= 1) {
            return [0, NaN, NaN];
        }
        //var cnt = 0
        for (i = 1; i < lenRed; i++) {
            red1 = red.points[i - 1].usrCoords;
            red2 = red.points[i].usrCoords;
            shortRed = (this.distance(red1, red2, 3) < eps);
            startRed = ((shortRed) ? start : 0.0) - JSXMath.eps;
            endRed = ((shortRed) ? end : 1.0) + JSXMath.eps;
            minX = Math.min(red1[1], red2[1]);
            maxX = Math.max(red1[1], red2[1]);
            minY = Math.min(red1[2], red2[2]);
            maxY = Math.max(red1[2], red2[2]);
            blue2 = blue.points[0].usrCoords;
            for (j = 1; j < lenBlue; j++) {
                blue1 = blue2;
                blue2 = blue.points[j].usrCoords;
                if (Math.min(blue1[1], blue2[1]) < maxX + eps &&
                    Math.max(blue1[1], blue2[1]) > minX - eps
                    &&
                        Math.min(blue1[2], blue2[2]) < maxY + eps &&
                    Math.max(blue1[2], blue2[2]) > minY - eps) {
                    shortBlue = (this.distance(blue1, blue2, 3) < eps);
                    startBlue = ((shortBlue) ? start : 0.0) - JSXMath.eps;
                    endBlue = ((shortBlue) ? end : 1.0) + JSXMath.eps;
                    //cnt++
                    m = this.meetSegmentSegment(red1, red2, blue1, blue2);
                    // console.log(m[0][1], red1[1], blue1[1], m)
                    if (m[1] >= startRed && m[2] >= startBlue &&
                        // The two segments meet in the interior or at the start points
                        // ((m[1] < 1.0 && m[2] < 1.0) ||
                        ((m[1] <= endRed && m[2] <= endBlue) ||
                            // One of the curve is intersected in the very last point
                            (i === lenRed - 1 && (m[1] - 1.0) < JSXMath.eps) ||
                            (j === lenBlue - 1 && (m[2] - 1.0) < JSXMath.eps))) {
                        if (iFound === n) {
                            //console.log('blue', blue.points.length, 'red', red.points.length, "Pairs:", cnt)
                            return m[0];
                        }
                        iFound++;
                        // } else {
                        //     let c = Mat.crossProduct(
                        //         [red2[0] - red1[0], red2[1] - red1[1], red2[2] - red1[2]],
                        //         [blue2[0] - blue1[0], blue2[1] - blue1[1], blue2[2] - blue1[2]]
                        //     )
                    }
                }
            }
        }
        //console.log('blue', blue.points.length, 'red', red.points.length, "Pairs:", cnt)
        return [0, NaN, NaN];
    }
    /**
     * (Virtual) Intersection of two segments.
     * @param {Array} p1 First point of segment 1 using normalized homogeneous coordinates [1,x,y]
     * @param {Array} p2 Second point or direction of segment 1 using normalized homogeneous coordinates [1,x,y] or point at infinity [0,x,y], respectively
     * @param {Array} q1 First point of segment 2 using normalized homogeneous coordinates [1,x,y]
     * @param {Array} q2 Second point or direction of segment 2 using normalized homogeneous coordinates [1,x,y] or point at infinity [0,x,y], respectively
     * @returns {Array} [Intersection point, t, u] The first entry contains the homogeneous coordinates
     * of the intersection point. The second and third entry give the position of the intersection with respect
     * to the definiting parameters. For example, the second entry t is defined by: intersection point = p1 + t * deltaP, where
     * deltaP = (p2 - p1) when both parameters are coordinates, and deltaP = p2 if p2 is a point at infinity.
     * If the two segments are collinear, [[0,0,0], Infinity, Infinity] is returned.
     **/
    static meetSegmentSegment(p1, p2, q1, q2) {
        var t, u, i, d, li1 = JSXMath.crossProduct(p1, p2), li2 = JSXMath.crossProduct(q1, q2), c = JSXMath.crossProduct(li1, li2);
        if (Math.abs(c[0]) < JSXMath.eps) {
            return [c, Infinity, Infinity];
        }
        // Normalize the intersection coordinates
        c[1] /= c[0];
        c[2] /= c[0];
        c[0] /= c[0];
        // Now compute in principle:
        //    t = dist(c - p1) / dist(p2 - p1) and
        //    u = dist(c - q1) / dist(q2 - q1)
        // However: the points q1, q2, p1, p2 might be ideal points - or in general - the
        // coordinates might be not normalized.
        // Note that the z-coordinates of p2 and q2 are used to determine whether it should be interpreted
        // as a segment coordinate or a direction.
        i = Math.abs(p2[1] - p2[0] * p1[1]) < JSXMath.eps ? 2 : 1;
        d = p1[i] / p1[0];
        t = (c[i] - d) / (p2[0] !== 0 ? p2[i] / p2[0] - d : p2[i]);
        i = Math.abs(q2[1] - q2[0] * q1[1]) < JSXMath.eps ? 2 : 1;
        d = q1[i] / q1[0];
        u = (c[i] - d) / (q2[0] !== 0 ? q2[i] / q2[0] - d : q2[i]);
        return [c, t, u];
    }
    /**
     * Find the n-th intersection point of two pathes, usually given by polygons. Uses parts of the
     * Greiner-Hormann algorithm in JXG.Math.Clip.
     *
     * @param {JXG.Circle|JXG.Curve|JXG.Polygon} path1
     * @param {JXG.Circle|JXG.Curve|JXG.Polygon} path2
     * @param {Number|Function} n
     * @param {JXG.Board} board
     *
     * @returns {JXG.Coords} Intersection point. In case no intersection point is detected,
     * the ideal point [0,0,0] is returned.
     *
     */
    static meetPathPath(path1, path2, nr, board) {
        // TOD fix clip
        throw new Error('fix clip');
        // var S, C, len, intersections,
        //     n = Type.evaluate(nr);
        // S = JXG.Math.Clip._getPath(path1, board);
        // len = S.length;
        // if (
        //     len > 0 &&
        //     this.distance(S[0].coords.usrCoords, S[len - 1].coords.usrCoords, 3) < JSXMath.eps
        // ) {
        //     S.pop();
        // }
        // C = JXG.Math.Clip._getPath(path2, board);
        // len = C.length;
        // if (
        //     len > 0 &&
        //     this.distance(C[0].coords.usrCoords, C[len - 1].coords.usrCoords, 3) <
        //     JSXMath.eps * JSXMath.eps
        // ) {
        //     C.pop();
        // }
        // // Handle cases where at least one of the paths is empty
        // if (nr < 0 || JXG.Math.Clip.isEmptyCase(S, C, "intersection")) {
        //     return new Coords(COORDS_BY.USER, [0, 0, 0], board);
        // }
        // JXG.Math.Clip.makeDoublyLinkedList(S);
        // JXG.Math.Clip.makeDoublyLinkedList(C);
        // intersections = JXG.Math.Clip.findIntersections(S, C, board)[0];
        // if (n < intersections.length) {
        //     return intersections[n].coords;
        // }
        // return new Coords(COORDS_BY.USER, [0, 0, 0], board);
    }
    /**
     * Find the n-th intersection point between a polygon and a line.
     * @param {JXG.Polygon} path
     * @param {JXG.Line} line
     * @param {Number|Function} nr
     * @param {JXG.Board} board
     * @param {Boolean} alwaysIntersect If false just the segment between the two defining points of the line are tested for intersection.
     *
     * @returns {JXG.Coords} Intersection point. In case no intersection point is detected,
     * the ideal point [0,0,0] is returned.
     */
    static meetPolygonLine(path, line, nr, board, alwaysIntersect) {
        var i, n = Type.evaluate(nr), res, border, crds = [0, 0, 0], len = path.borders.length, intersections = [];
        for (i = 0; i < len; i++) {
            border = path.borders[i];
            res = this.meetSegmentSegment(border.point1.coords.usrCoords, border.point2.coords.usrCoords, line.point1.coords.usrCoords, line.point2.coords.usrCoords);
            if ((!alwaysIntersect || (res[2] >= 0 && res[2] < 1)) &&
                res[1] >= 0 &&
                res[1] < 1) {
                intersections.push(res[0]);
            }
        }
        if (n >= 0 && n < intersections.length) {
            crds = intersections;
        }
        return new Coords(COORDS_BY.USER, crds, board);
    }
    /****************************************/
    /****   BEZIER CURVE ALGORITHMS      ****/
    /****************************************/
    /**
     * Splits a Bezier curve segment defined by four points into
     * two Bezier curve segments. Dissection point is t=1/2.
     * @param {Array} curve Array of four coordinate arrays of length 2 defining a
     * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].
     * @returns {Array} Array consisting of two coordinate arrays for Bezier curves.
     */
    static _bezierSplit(curve) {
        var p0, p1, p2, p00, p22, p000;
        p0 = [(curve[0][0] + curve[1][0]) * 0.5, (curve[0][1] + curve[1][1]) * 0.5];
        p1 = [(curve[1][0] + curve[2][0]) * 0.5, (curve[1][1] + curve[2][1]) * 0.5];
        p2 = [(curve[2][0] + curve[3][0]) * 0.5, (curve[2][1] + curve[3][1]) * 0.5];
        p00 = [(p0[0] + p1[0]) * 0.5, (p0[1] + p1[1]) * 0.5];
        p22 = [(p1[0] + p2[0]) * 0.5, (p1[1] + p2[1]) * 0.5];
        p000 = [(p00[0] + p22[0]) * 0.5, (p00[1] + p22[1]) * 0.5];
        return [
            [curve[0], p0, p00, p000],
            [p000, p22, p2, curve[3]]
        ];
    }
    /**
     * Computes the bounding box [minX, maxY, maxX, minY] of a Bezier curve segment
     * from its control points.
     * @param {Array} curve Array of four coordinate arrays of length 2 defining a
     * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].
     * @returns {Array} Bounding box [minX, maxY, maxX, minY]
     */
    static _bezierBbox(curve) {
        var bb = [];
        if (curve.length === 4) {
            // bezierDegree == 3
            bb[0] = Math.min(curve[0][0], curve[1][0], curve[2][0], curve[3][0]); // minX
            bb[1] = Math.max(curve[0][1], curve[1][1], curve[2][1], curve[3][1]); // maxY
            bb[2] = Math.max(curve[0][0], curve[1][0], curve[2][0], curve[3][0]); // maxX
            bb[3] = Math.min(curve[0][1], curve[1][1], curve[2][1], curve[3][1]); // minY
        }
        else {
            // bezierDegree == 1
            bb[0] = Math.min(curve[0][0], curve[1][0]); // minX
            bb[1] = Math.max(curve[0][1], curve[1][1]); // maxY
            bb[2] = Math.max(curve[0][0], curve[1][0]); // maxX
            bb[3] = Math.min(curve[0][1], curve[1][1]); // minY
        }
        return bb;
    }
    /**
     * Decide if two Bezier curve segments overlap by comparing their bounding boxes.
     * @param {Array} bb1 Bounding box of the first Bezier curve segment
     * @param {Array} bb2 Bounding box of the second Bezier curve segment
     * @returns {Boolean} true if the bounding boxes overlap, false otherwise.
     */
    static _bezierOverlap(bb1, bb2) {
        return bb1[2] >= bb2[0] && bb1[0] <= bb2[2] && bb1[1] >= bb2[3] && bb1[3] <= bb2[1];
    }
    /**
     * Append list of intersection points to a list.
     * @private
     */
    static _bezierListConcat(L, Lnew, t1, t2) {
        var i, t2exists = Type.exists(t2), start = 0, len = Lnew.length, le = L.length;
        if (le > 0 &&
            len > 0 &&
            ((L[le - 1][1] === 1 && Lnew[0][1] === 0) ||
                (t2exists && L[le - 1][2] === 1 && Lnew[0][2] === 0))) {
            start = 1;
        }
        for (i = start; i < len; i++) {
            if (t2exists) {
                Lnew[i][2] *= 0.5;
                Lnew[i][2] += t2;
            }
            Lnew[i][1] *= 0.5;
            Lnew[i][1] += t1;
            L.push(Lnew[i]);
        }
    }
    /**
     * Find intersections of two Bezier curve segments by recursive subdivision.
     * Below maxlevel determine intersections by intersection line segments.
     * @param {Array} red Array of four coordinate arrays of length 2 defining the first
     * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].
     * @param {Array} blue Array of four coordinate arrays of length 2 defining the second
     * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].
     * @param {Number} level Recursion level
     * @returns {Array} List of intersection points (up to nine). Each intersection point is an
     * array of length three (homogeneous coordinates) plus preimages.
     */
    static _bezierMeetSubdivision(red, blue, level) {
        var bbb, bbr, ar, b0, b1, r0, r1, m, p0, p1, q0, q1, L = [], maxLev = 5; // Maximum recursion level
        bbr = this._bezierBbox(blue);
        bbb = this._bezierBbox(red);
        if (!this._bezierOverlap(bbr, bbb)) {
            return [];
        }
        if (level < maxLev) {
            ar = this._bezierSplit(red);
            r0 = ar[0];
            r1 = ar[1];
            ar = this._bezierSplit(blue);
            b0 = ar[0];
            b1 = ar[1];
            this._bezierListConcat(L, this._bezierMeetSubdivision(r0, b0, level + 1), 0.0, 0.0);
            this._bezierListConcat(L, this._bezierMeetSubdivision(r0, b1, level + 1), 0, 0.5);
            this._bezierListConcat(L, this._bezierMeetSubdivision(r1, b0, level + 1), 0.5, 0.0);
            this._bezierListConcat(L, this._bezierMeetSubdivision(r1, b1, level + 1), 0.5, 0.5);
            return L;
        }
        // Make homogeneous coordinates
        q0 = [1].concat(red[0]);
        q1 = [1].concat(red[3]);
        p0 = [1].concat(blue[0]);
        p1 = [1].concat(blue[3]);
        m = this.meetSegmentSegment(q0, q1, p0, p1);
        if (m[1] >= 0.0 && m[2] >= 0.0 && m[1] <= 1.0 && m[2] <= 1.0) {
            return [m];
        }
        return [];
    }
    /**
     * @param {Boolean} testSegment Test if intersection has to be inside of the segment or somewhere on the line defined by the segment
     */
    static _bezierLineMeetSubdivision(red, blue, level, testSegment = false) {
        var bbb, bbr, ar, r0, r1, m, p0, p1, q0, q1, L = [], maxLev = 5; // Maximum recursion level
        bbb = this._bezierBbox(blue);
        bbr = this._bezierBbox(red);
        if (testSegment && !this._bezierOverlap(bbr, bbb)) {
            return [];
        }
        if (level < maxLev) {
            ar = this._bezierSplit(red);
            r0 = ar[0];
            r1 = ar[1];
            this._bezierListConcat(L, this._bezierLineMeetSubdivision(r0, blue, level + 1), 0.0);
            this._bezierListConcat(L, this._bezierLineMeetSubdivision(r1, blue, level + 1), 0.5);
            return L;
        }
        // Make homogeneous coordinates
        q0 = [1].concat(red[0]);
        q1 = [1].concat(red[3]);
        p0 = [1].concat(blue[0]);
        p1 = [1].concat(blue[1]);
        m = this.meetSegmentSegment(q0, q1, p0, p1);
        if (m[1] >= 0.0 && m[1] <= 1.0) {
            if (!testSegment || (m[2] >= 0.0 && m[2] <= 1.0)) {
                return [m];
            }
        }
        return [];
    }
    /**
     * Find the nr-th intersection point of two Bezier curve segments.
     * @param {Array} red Array of four coordinate arrays of length 2 defining the first
     * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].
     * @param {Array} blue Array of four coordinate arrays of length 2 defining the second
     * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].
     * @param {Boolean} testSegment Test if intersection has to be inside of the segment or somewhere on the line defined by the segment
     * @returns {Array} Array containing the list of all intersection points as homogeneous coordinate arrays plus
     * preimages [x,y], t_1, t_2] of the two Bezier curve segments.
     *
     */
    static meetBeziersegmentBeziersegment(red, blue, testSegment = false) {
        var L, L2, i;
        if (red.length === 4 && blue.length === 4) {
            L = this._bezierMeetSubdivision(red, blue, 0);
        }
        else {
            L = this._bezierLineMeetSubdivision(red, blue, 0, testSegment);
        }
        L.sort(function (a, b) {
            return (a[1] - b[1]) * 10000000.0 + (a[2] - b[2]);
        });
        L2 = [];
        for (i = 0; i < L.length; i++) {
            // Only push entries different from their predecessor
            if (i === 0 || L[i][1] !== L[i - 1][1] || L[i][2] !== L[i - 1][2]) {
                L2.push(L[i]);
            }
        }
        return L2;
    }
    /**
     * Find the nr-th intersection point of two Bezier curves, i.e. curves with bezierDegree == 3.
     * @param {JXG.Curve} red Curve with bezierDegree == 3
     * @param {JXG.Curve} blue Curve with bezierDegree == 3
     * @param {Number|Function} nr The number of the intersection point which should be returned.
     * @returns {Array} The homogeneous coordinates of the nr-th intersection point.
     */
    static meetBezierCurveRedBlueSegments(red, blue, nr) {
        var p, i, j, k, n = Type.evaluate(nr), po, tmp, redArr, blueArr, bbr, bbb, intersections, startRed = 0, startBlue = 0, lenBlue, lenRed, L = [];
        if (blue.numberPoints < blue.bezierDegree + 1 || red.numberPoints < red.bezierDegree + 1) {
            return [0, NaN, NaN];
        }
        if (red.bezierDegree === 1 && blue.bezierDegree === 3) {
            tmp = red;
            red = blue;
            blue = tmp;
        }
        lenBlue = blue.numberPoints - blue.bezierDegree;
        lenRed = red.numberPoints - red.bezierDegree;
        // For sectors, we ignore the "legs"
        if (red.type === OBJECT_TYPE.SECTOR) {
            startRed = 3;
            lenRed -= 3;
        }
        if (blue.type === OBJECT_TYPE.SECTOR) {
            startBlue = 3;
            lenBlue -= 3;
        }
        for (i = startRed; i < lenRed; i += red.bezierDegree) {
            p = red.points;
            redArr = [p[i].usrCoords.slice(1), p[i + 1].usrCoords.slice(1)];
            if (red.bezierDegree === 3) {
                redArr[2] = p[i + 2].usrCoords.slice(1);
                redArr[3] = p[i + 3].usrCoords.slice(1);
            }
            bbr = this._bezierBbox(redArr);
            for (j = startBlue; j < lenBlue; j += blue.bezierDegree) {
                p = blue.points;
                blueArr = [p[j].usrCoords.slice(1), p[j + 1].usrCoords.slice(1)];
                if (blue.bezierDegree === 3) {
                    blueArr[2] = p[j + 2].usrCoords.slice(1);
                    blueArr[3] = p[j + 3].usrCoords.slice(1);
                }
                bbb = this._bezierBbox(blueArr);
                if (this._bezierOverlap(bbr, bbb)) {
                    intersections = this.meetBeziersegmentBeziersegment(redArr, blueArr);
                    if (intersections.length === 0) {
                        continue;
                    }
                    for (k = 0; k < intersections.length; k++) {
                        po = intersections[k];
                        if (po[1] < -JSXMath.eps ||
                            po[1] > 1 + JSXMath.eps ||
                            po[2] < -JSXMath.eps ||
                            po[2] > 1 + JSXMath.eps) {
                            continue;
                        }
                        L.push(po);
                    }
                    if (L.length > n) {
                        return L[n][0];
                    }
                }
            }
        }
        if (L.length > n) {
            return L[n][0];
        }
        return [0, NaN, NaN];
    }
    static bezierSegmentEval(t, curve) {
        var f, x, y, t1 = 1.0 - t;
        x = 0;
        y = 0;
        f = t1 * t1 * t1;
        x += f * curve[0][0];
        y += f * curve[0][1];
        f = 3.0 * t * t1 * t1;
        x += f * curve[1][0];
        y += f * curve[1][1];
        f = 3.0 * t * t * t1;
        x += f * curve[2][0];
        y += f * curve[2][1];
        f = t * t * t;
        x += f * curve[3][0];
        y += f * curve[3][1];
        return [1.0, x, y];
    }
    /**
     * Generate the defining points of a 3rd degree bezier curve that approximates
     * a circle sector defined by three coordinate points A, B, C, each defined by an array of length three.
     * The coordinate arrays are given in homogeneous coordinates.
     * @param {Array} A First point
     * @param {Array} B Second point (intersection point)
     * @param {Array} C Third point
     * @param {Boolean} withLegs Flag. If true the legs to the intersection point are part of the curve.
     * @param {Number} sgn Wither 1 or -1. Needed for minor and major arcs. In case of doubt, use 1.
     */
    static bezierArc(A, B, C, withLegs, sgn = 1) {
        var p1, p2, p3, p4, r, phi, beta, delta, 
        // PI2 = Math.PI * 0.5,
        x = B[1], y = B[2], z = B[0], dataX = [], dataY = [], co, si, ax, ay, bx, by, k, v, d, matrix;
        r = this.distance(B, A);
        // x,y, z is intersection point. Normalize it.
        x /= z;
        y /= z;
        phi = this.rad(A.slice(1), B.slice(1), C.slice(1));
        if (sgn === -1) {
            phi = 2 * Math.PI - phi;
        }
        // Always divide the arc into four Bezier arcs.
        // Otherwise, the position of gliders on this arc
        // will be wrong.
        delta = phi / 4;
        p1 = A;
        p1[1] /= p1[0];
        p1[2] /= p1[0];
        p1[0] /= p1[0];
        p4 = p1.slice(0);
        if (withLegs) {
            dataX = [x, x + 0.333 * (p1[1] - x), x + 0.666 * (p1[1] - x), p1[1]];
            dataY = [y, y + 0.333 * (p1[2] - y), y + 0.666 * (p1[2] - y), p1[2]];
        }
        else {
            dataX = [p1[1]];
            dataY = [p1[2]];
        }
        while (phi > JSXMath.eps) {
            // if (phi > PI2) {
            //     beta = PI2;
            //     phi -= PI2;
            // } else {
            //     beta = phi;
            //     phi = 0;
            // }
            if (phi > delta) {
                beta = delta;
                phi -= delta;
            }
            else {
                beta = phi;
                phi = 0;
            }
            co = Math.cos(sgn * beta);
            si = Math.sin(sgn * beta);
            matrix = [
                [1, 0, 0],
                [x * (1 - co) + y * si, co, -si],
                [y * (1 - co) - x * si, si, co]
            ];
            v = JSXMath.matVecMult(matrix, p1);
            p4 = [v[0] / v[0], v[1] / v[0], v[2] / v[0]];
            ax = p1[1] - x;
            ay = p1[2] - y;
            bx = p4[1] - x;
            by = p4[2] - y;
            d = JSXMath.hypot(ax + bx, ay + by);
            if (Math.abs(by - ay) > JSXMath.eps) {
                k = ((((ax + bx) * (r / d - 0.5)) / (by - ay)) * 8) / 3;
            }
            else {
                k = ((((ay + by) * (r / d - 0.5)) / (ax - bx)) * 8) / 3;
            }
            p2 = [1, p1[1] - k * ay, p1[2] + k * ax];
            p3 = [1, p4[1] + k * by, p4[2] - k * bx];
            Type.concat(dataX, [p2[1], p3[1], p4[1]]);
            Type.concat(dataY, [p2[2], p3[2], p4[2]]);
            p1 = p4.slice(0);
        }
        if (withLegs) {
            Type.concat(dataX, [
                p4[1] + 0.333 * (x - p4[1]),
                p4[1] + 0.666 * (x - p4[1]),
                x
            ]);
            Type.concat(dataY, [
                p4[2] + 0.333 * (y - p4[2]),
                p4[2] + 0.666 * (y - p4[2]),
                y
            ]);
        }
        return [dataX, dataY];
    }
    /****************************************/
    /****           PROJECTIONS          ****/
    /****************************************/
    /**
     * Calculates the coordinates of the projection of a given point on a given circle. I.o.w. the
     * nearest one of the two intersection points of the line through the given point and the circles
     * center.
     * @param {JXG.Point|JXG.Coords} point Point to project or coords object to project.
     * @param {JXG.Circle} circle Circle on that the point is projected.
     * @param {JXG.Board} [board=point.board] Reference to the board
     * @returns {JXG.Coords} The coordinates of the projection of the given point on the given circle.
     */
    static projectPointToCircle(point, circle, board) {
        var dist, P, x, y, factor, M = circle.center.coords.usrCoords;
        if (!Type.exists(board)) {
            board = point.board;
        }
        // gave us a point
        if (Type.isPoint(point)) {
            dist = point.coords.distance(COORDS_BY.USER, circle.center.coords);
            P = point.coords.usrCoords;
            // gave us coords
        }
        else {
            dist = point.distance(COORDS_BY.USER, circle.center.coords);
            P = point.usrCoords;
        }
        if (Math.abs(dist) < JSXMath.eps) {
            dist = JSXMath.eps;
        }
        factor = circle.Radius() / dist;
        x = M[1] + factor * (P[1] - M[1]);
        y = M[2] + factor * (P[2] - M[2]);
        return new Coords(COORDS_BY.USER, [x, y], board);
    }
    /**
     * Calculates the coordinates of the orthogonal projection of a given point on a given line. I.o.w. the
     * intersection point of the given line and its perpendicular through the given point.
     * @param {JXG.Point|JXG.Coords} point Point to project.
     * @param {JXG.Line} line Line on that the point is projected.
     * @param {JXG.Board} [board=point.board|board=line.board] Reference to a board.
     * @returns {JXG.Coords} The coordinates of the projection of the given point on the given line.
     */
    static projectPointToLine(point, line, board) {
        var v = [0, line.stdform[1], line.stdform[2]], coords;
        if (!Type.exists(board)) {
            if (Type.exists(point.coords)) {
                board = point.board;
            }
            else {
                board = line.board;
            }
        }
        if (Type.exists(point.coords)) {
            coords = point.coords.usrCoords;
        }
        else {
            coords = point.usrCoords;
        }
        v = JSXMath.crossProduct(v, coords);
        return new Coords(COORDS_BY.USER, JSXMath.crossProduct(v, line.stdform), board);
    }
    /**
     * Calculates the coordinates of the orthogonal projection of a given coordinate array on a given line
     * segment defined by two coordinate arrays.
     * @param {Array} p Point to project.
     * @param {Array} q1 Start point of the line segment on that the point is projected.
     * @param {Array} q2 End point of the line segment on that the point is projected.
     * @returns {Array} The coordinates of the projection of the given point on the given segment
     * and the factor that determines the projected point as a convex combination of the
     * two endpoints q1 and q2 of the segment.
     */
    static projectCoordsToSegment(p, q1, q2) {
        var t, denom, s = [q2[1] - q1[1], q2[2] - q1[2]], v = [p[1] - q1[1], p[2] - q1[2]];
        /**
         * If the segment has length 0, i.e. is a point,
         * the projection is equal to that point.
         */
        if (Math.abs(s[0]) < JSXMath.eps && Math.abs(s[1]) < JSXMath.eps) {
            return [q1, 0];
        }
        t = JSXMath.innerProduct(v, s);
        denom = JSXMath.innerProduct(s, s);
        t /= denom;
        return [[1, t * s[0] + q1[1], t * s[1] + q1[2]], t];
    }
    /**
     * Finds the coordinates of the closest point on a Bezier segment of a
     * {@link JXG.Curve} to a given coordinate array.
     * @param {Array} pos Point to project in homogeneous coordinates.
     * @param {JXG.Curve} curve Curve of type "plot" having Bezier degree 3.
     * @param {Number} start Number of the Bezier segment of the curve.
     * @returns {Array} The coordinates of the projection of the given point
     * on the given Bezier segment and the preimage of the curve which
     * determines the closest point.
     */
    static projectCoordsToBeziersegment(pos, curve, start) {
        var t0, 
        /** @ignore */
        minfunc = function (t) {
            var z = [1, curve.X(start + t), curve.Y(start + t)];
            z[1] -= pos[1];
            z[2] -= pos[2];
            return z[1] * z[1] + z[2] * z[2];
        };
        t0 = Numerics.fminbr(minfunc, [0.0, 1.0]);
        return [[1, curve.X(t0 + start), curve.Y(t0 + start)], t0];
    }
    /**
     * Calculates the coordinates of the projection of a given point on a given curve.
     * Uses {@link Geometry.projectCoordsToCurve}.
     *
     * @param {JXG.Point} point Point to project.
     * @param {JXG.Curve} curve Curve on that the point is projected.
     * @param {JXG.Board} [board=point.board] Reference to a board.
     * @see Geometry.projectCoordsToCurve
     * @returns {Array} [JXG.Coords, position] The coordinates of the projection of the given
     * point on the given graph and the relative position on the curve (real number).
     */
    static projectPointToCurve(point, curve, board) {
        if (!Type.exists(board)) {
            board = point.board;
        }
        var x = point.X(), y = point.Y(), t = point.position, result;
        if (!Type.exists(t)) {
            t = curve.evalVisProp('curvetype') === 'functiongraph' ? x : 0.0;
        }
        result = this.projectCoordsToCurve(x, y, t, curve, board);
        // point.position = result[1];
        return result;
    }
    /**
     * Calculates the coordinates of the projection of a coordinates pair on a given curve. In case of
     * function graphs this is the
     * intersection point of the curve and the parallel to y-axis through the given point.
     * @param {Number} x coordinate to project.
     * @param {Number} y coordinate to project.
     * @param {Number} t start value for newtons method
     * @param {JXG.Curve} curve Curve on that the point is projected.
     * @param {JXG.Board} [board=curve.board] Reference to a board.
     * @see Geometry.projectPointToCurve
     * @returns {JXG.Coords} Array containing the coordinates of the projection of the given point on the given curve and
     * the position on the curve.
     */
    static projectCoordsToCurve(x, y, t, curve, board) {
        var newCoords, newCoordsObj, i, j, mindist, dist, lbda, v, coords, d, p1, p2, res, minfunc, t_new, f_new, f_old, dy, delta, delta1, delta2, steps, minX, maxX, minX_glob, maxX_glob, infty = Number.POSITIVE_INFINITY;
        if (!Type.exists(board)) {
            board = curve.board;
        }
        if (curve.evalVisProp('curvetype') === "plot") {
            t = 0;
            mindist = infty;
            if (curve.numberPoints === 0) {
                newCoords = [0, 1, 1];
            }
            else {
                newCoords = [curve.Z(0), curve.X(0), curve.Y(0)];
            }
            if (curve.numberPoints > 1) {
                v = [1, x, y];
                if (curve.bezierDegree === 3) {
                    j = 0;
                }
                else {
                    p1 = [curve.Z(0), curve.X(0), curve.Y(0)];
                }
                for (i = 0; i < curve.numberPoints - 1; i++) {
                    if (curve.bezierDegree === 3) {
                        res = this.projectCoordsToBeziersegment(v, curve, j);
                    }
                    else {
                        p2 = [curve.Z(i + 1), curve.X(i + 1), curve.Y(i + 1)];
                        res = this.projectCoordsToSegment(v, p1, p2);
                    }
                    lbda = res[1];
                    coords = res[0];
                    if (0.0 <= lbda && lbda <= 1.0) {
                        dist = this.distance(coords, v);
                        d = i + lbda;
                    }
                    else if (lbda < 0.0) {
                        coords = p1;
                        dist = this.distance(p1, v);
                        d = i;
                    }
                    else if (lbda > 1.0 && i === curve.numberPoints - 2) {
                        coords = p2;
                        dist = this.distance(coords, v);
                        d = curve.numberPoints - 1;
                    }
                    if (dist < mindist) {
                        mindist = dist;
                        t = d;
                        newCoords = coords;
                    }
                    if (curve.bezierDegree === 3) {
                        j++;
                        i += 2;
                    }
                    else {
                        p1 = p2;
                    }
                }
            }
            newCoordsObj = new Coords(COORDS_BY.USER, newCoords, board);
        }
        else {
            // 'parameter', 'polar', 'functiongraph'
            minX_glob = curve.minX();
            maxX_glob = curve.maxX();
            minX = minX_glob;
            maxX = maxX_glob;
            if (curve.evalVisProp('curvetype') === 'functiongraph') {
                // Restrict the possible position of t
                // to the projection of a circle to the x-axis (= t-axis)
                dy = Math.abs(y - curve.Y(x));
                if (!isNaN(dy)) {
                    minX = x - dy;
                    maxX = x + dy;
                }
            }
            /**
             * @ignore
             * Find t such that the Euclidean distance between
             * [x, y] and [curve.X(t), curve.Y(t)]
             * is minimized.
             */
            minfunc = function (t) {
                var dx, dy;
                if (t < minX_glob || t > curve.maxX_glob) {
                    return Infinity;
                }
                dx = x - curve.X(t);
                dy = y - curve.Y(t);
                return dx * dx + dy * dy;
            };
            // Search t which minimizes minfunc(t)
            // in discrete steps
            f_old = minfunc(t);
            steps = 50;
            delta = (maxX - minX) / steps;
            t_new = minX;
            for (i = 0; i < steps; i++) {
                f_new = minfunc(t_new);
                if (f_new < f_old || f_old === Infinity || isNaN(f_old)) {
                    t = t_new;
                    f_old = f_new;
                }
                t_new += delta;
            }
            // t = Numerics.root(Numerics.D(minfunc), t);
            // Ensure that minfunc is defined on the
            // enclosing interval [t-delta1, t+delta2]
            delta1 = delta;
            for (i = 0; i < 20 && isNaN(minfunc(t - delta1)); i++, delta1 *= 0.5)
                ;
            if (isNaN(minfunc(t - delta1))) {
                delta1 = 0.0;
            }
            delta2 = delta;
            for (i = 0; i < 20 && isNaN(minfunc(t + delta2)); i++, delta2 *= 0.5)
                ;
            if (isNaN(minfunc(t + delta2))) {
                delta2 = 0.0;
            }
            // Finally, apply mathemetical optimization in the determined interval
            t = Numerics.fminbr(minfunc, [
                Math.max(t - delta1, minX),
                Math.min(t + delta2, maxX)
            ]);
            // Distinction between closed and open curves is not necessary.
            // If closed, the cyclic projection shift will work anyhow
            // if (Math.abs(curve.X(minX) - curve.X(maxX)) < JSXMath.eps &&
            //     Math.abs(curve.Y(minX) - curve.Y(maxX)) < JSXMath.eps) {
            //     // Cyclically
            //     if (t < minX) {console.log(t)
            //         t = maxX + t - minX;
            //     }
            //     if (t > maxX) {
            //         t = minX + t - maxX;
            //     }
            // } else {
            t = t < minX_glob ? minX_glob : t;
            t = t > maxX_glob ? maxX_glob : t;
            // }
            newCoordsObj = new Coords(COORDS_BY.USER, [curve.X(t), curve.Y(t)], board);
        }
        return [curve.updateTransform(newCoordsObj), t];
    }
    /**
     * Calculates the coordinates of the closest orthogonal projection of a given coordinate array onto the
     * border of a polygon.
     * @param {Array} p Point to project.
     * @param {JXG.Polygon} pol Polygon element
     * @returns {Array} The coordinates of the closest projection of the given point to the border of the polygon.
     */
    static projectCoordsToPolygon(p, pol) {
        var i, len = pol.vertices.length, d_best = Infinity, d, projection, proj, bestprojection;
        for (i = 0; i < len - 1; i++) {
            projection = Geometry.projectCoordsToSegment(p, pol.vertices[i].coords.usrCoords, pol.vertices[i + 1].coords.usrCoords);
            if (0 <= projection[1] && projection[1] <= 1) {
                d = Geometry.distance(projection[0], p, 3);
                proj = projection[0];
            }
            else if (projection[1] < 0) {
                d = Geometry.distance(pol.vertices[i].coords.usrCoords, p, 3);
                proj = pol.vertices[i].coords.usrCoords;
            }
            else {
                d = Geometry.distance(pol.vertices[i + 1].coords.usrCoords, p, 3);
                proj = pol.vertices[i + 1].coords.usrCoords;
            }
            if (d < d_best) {
                bestprojection = proj.slice(0);
                d_best = d;
            }
        }
        return bestprojection;
    }
    /**
     * Calculates the coordinates of the projection of a given point on a given turtle. A turtle consists of
     * one or more curves of curveType 'plot'. Uses {@link Geometry.projectPointToCurve}.
     * @param {JXG.Point} point Point to project.
     * @param {JXG.Turtle} turtle on that the point is projected.
     * @param {JXG.Board} [board=point.board] Reference to a board.
     * @returns {Array} [JXG.Coords, position] Array containing the coordinates of the projection of the given point on the turtle and
     * the position on the turtle.
     */
    static projectPointToTurtle(point, turtle, board) {
        var newCoords, t, x, y, i, dist, el, minEl, res, newPos, np = 0, npmin = 0, mindist = Number.POSITIVE_INFINITY, len = turtle.objects.length;
        if (!Type.exists(board)) {
            board = point.board;
        }
        // run through all curves of this turtle
        for (i = 0; i < len; i++) {
            el = turtle.objects[i];
            if (el.elementClass === OBJECT_CLASS.CURVE) {
                res = this.projectPointToCurve(point, el);
                newCoords = res[0];
                newPos = res[1];
                dist = this.distance(newCoords.usrCoords, point.coords.usrCoords);
                if (dist < mindist) {
                    x = newCoords.usrCoords[1];
                    y = newCoords.usrCoords[2];
                    t = newPos;
                    mindist = dist;
                    minEl = el;
                    npmin = np;
                }
                np += el.numberPoints;
            }
        }
        newCoords = new Coords(COORDS_BY.USER, [x, y], board);
        // point.position = t + npmin;
        // return minEl.updateTransform(newCoords);
        return [minEl.updateTransform(newCoords), t + npmin];
    }
    /**
     * Trivial projection of a point to another point.
     * @param {JXG.Point} point Point to project (not used).
     * @param {JXG.Point} dest Point on that the point is projected.
     * @returns {JXG.Coords} The coordinates of the projection of the given point on the given circle.
     */
    static projectPointToPoint(point, dest) {
        return dest.coords;
    }
    /**
     *
     * @param {JXG.Point|JXG.Coords} point
     * @param {JXG.Board} [board]
     */
    static projectPointToBoard(point, board) {
        var i, l, c, brd = board || point.board, 
        // comparison factor, point coord idx, bbox idx, 1st bbox corner x & y idx, 2nd bbox corner x & y idx
        config = [
            // left
            [1, 1, 0, 0, 3, 0, 1],
            // top
            [-1, 2, 1, 0, 1, 2, 1],
            // right
            [-1, 1, 2, 2, 1, 2, 3],
            // bottom
            [1, 2, 3, 0, 3, 2, 3]
        ], coords = point.coords || point, bbox = brd.getBoundingBox();
        for (i = 0; i < 4; i++) {
            c = config[i];
            if (c[0] * coords.usrCoords[c[1]] < c[0] * bbox[c[2]]) {
                // define border
                l = JSXMath.crossProduct([1, bbox[c[3]], bbox[c[4]]], [1, bbox[c[5]], bbox[c[6]]]);
                l[3] = 0;
                l = JSXMath.normalize(l);
                // project point
                coords = this.projectPointToLine({ coords: coords }, { stdform: l }, brd);
            }
        }
        return coords;
    }
    /**
     * Calculates the distance of a point to a line. The point and the line are given by homogeneous
     * coordinates. For lines this can be line.stdform.
     * @param {Array} point Homogeneous coordinates of a point.
     * @param {Array} line Homogeneous coordinates of a line ([C,A,B] where A*x+B*y+C*z=0).
     * @returns {Number} Distance of the point to the line.
     */
    static distPointLine(point, line) {
        var a = line[1], b = line[2], c = line[0], nom;
        if (Math.abs(a) + Math.abs(b) < JSXMath.eps) {
            return Number.POSITIVE_INFINITY;
        }
        nom = a * point[1] + b * point[2] + c;
        a *= a;
        b *= b;
        return Math.abs(nom) / Math.sqrt(a + b);
    }
    /**
     * Determine the (Euclidean) distance between a point q and a line segment
     * defined by two points p1 and p2. In case p1 equals p2, the distance to this
     * point is returned.
     *
     * @param {Array} q Homogeneous coordinates of q
     * @param {Array} p1 Homogeneous coordinates of p1
     * @param {Array} p2 Homogeneous coordinates of p2
     * @returns {Number} Distance of q to line segment [p1, p2]
     */
    static distPointSegment(q, p1, p2) {
        var x, y, dx, dy, den, lbda, eps = JSXMath.eps * JSXMath.eps, huge = 1000000;
        // Difference q - p1
        x = q[1] - p1[1];
        y = q[2] - p1[2];
        x = (x === Infinity) ? huge : (x === -Infinity) ? -huge : x;
        y = (y === Infinity) ? huge : (y === -Infinity) ? -huge : y;
        // Difference p2 - p1
        dx = p2[1] - p1[1];
        dy = p2[2] - p1[2];
        dx = (dx === Infinity) ? huge : (dx === -Infinity) ? -huge : dx;
        dy = (dy === Infinity) ? huge : (dy === -Infinity) ? -huge : dy;
        // If den==0 then p1 and p2 are identical
        // In this case the distance to p1 is returned
        den = dx * dx + dy * dy;
        if (den > eps) {
            lbda = (x * dx + y * dy) / den;
            if (lbda < 0.0) {
                lbda = 0.0;
            }
            else if (lbda > 1.0) {
                lbda = 1.0;
            }
            x -= lbda * dx;
            y -= lbda * dy;
        }
        return JSXMath.hypot(x, y);
    }
    /* ***************************************/
    /* *** 3D CALCULATIONS ****/
    /* ***************************************/
    /**
     * Generate the function which computes the data of the intersection between
     * <ul>
     * <li> plane3d, plane3d,
     * <li> plane3d, sphere3d,
     * <li> sphere3d, plane3d,
     * <li> sphere3d, sphere3d
     * </ul>
     *
     * @param {JXG.GeometryElement3D} el1 Plane or sphere element
     * @param {JXG.GeometryElement3D} el2 Plane or sphere element
     * @returns {Array} of functions needed as input to create the intersecting line or circle.
     *
     */
    static intersectionFunction3D(view, el1, el2) {
        var func, that = this;
        if (el1.type === OBJECT_TYPE.PLANE3D) {
            if (el2.type === OBJECT_TYPE.PLANE3D) {
                // func = () => view.intersectionPlanePlane(el1, el2)[i];
                func = view.intersectionPlanePlane(el1, el2);
            }
            else if (el2.type === OBJECT_TYPE.SPHERE3D) {
                func = that.meetPlaneSphere(el1, el2);
            }
        }
        else if (el1.type === OBJECT_TYPE.SPHERE3D) {
            if (el2.type === OBJECT_TYPE.PLANE3D) {
                func = that.meetPlaneSphere(el2, el1);
            }
            else if (el2.type === OBJECT_TYPE.SPHERE3D) {
                func = that.meetSphereSphere(el1, el2);
            }
        }
        return func;
    }
    /**
     * Intersecting point of three planes in 3D. The planes
     * are given in Hesse normal form.
     *
     * @param {Array} n1 Hesse normal form vector of plane 1
     * @param {Number} d1 Hesse normal form right hand side of plane 1
     * @param {Array} n2 Hesse normal form vector of plane 2
     * @param {Number} d2 Hesse normal form right hand side of plane 2
     * @param {Array} n3 Hesse normal form vector of plane 1
     * @param {Number} d3 Hesse normal form right hand side of plane 3
     * @returns {Array} Coordinates array of length 4 of the intersecting point
     */
    static meet3Planes(n1, d1, n2, d2, n3, d3) {
        var p = [1, 0, 0, 0], n31, n12, n23, denom, i;
        n31 = JSXMath.crossProduct(n3.slice(1), n1.slice(1));
        n12 = JSXMath.crossProduct(n1.slice(1), n2.slice(1));
        n23 = JSXMath.crossProduct(n2.slice(1), n3.slice(1));
        denom = JSXMath.innerProduct(n1.slice(1), n23, 3);
        for (i = 0; i < 3; i++) {
            p[i + 1] = (d1 * n23[i] + d2 * n31[i] + d3 * n12[i]) / denom;
        }
        return p;
    }
    /**
     * Direction of intersecting line of two planes in 3D.
     *
     * @param {Array} v11 First vector spanning plane 1 (homogeneous coordinates)
     * @param {Array} v12 Second vector spanning plane 1 (homogeneous coordinates)
     * @param {Array} v21 First vector spanning plane 2 (homogeneous coordinates)
     * @param {Array} v22 Second vector spanning plane 2 (homogeneous coordinates)
     * @returns {Array} Coordinates array of length 4 of the direction  (homogeneous coordinates)
     */
    static meetPlanePlane(v11, v12, v21, v22) {
        var no1, no2, v, w;
        v = v11.slice(1);
        w = v12.slice(1);
        no1 = JSXMath.crossProduct(v, w);
        v = v21.slice(1);
        w = v22.slice(1);
        no2 = JSXMath.crossProduct(v, w);
        w = JSXMath.crossProduct(no1, no2);
        w.unshift(0);
        return w;
    }
    static meetPlaneSphere(el1, el2) {
        var dis = function () {
            return JSXMath.innerProduct(el1.normal, el2.center.coords, 4) - el1.d;
        };
        return [
            // Center
            function () {
                return JSXMath.axpy(-dis(), el1.normal, el2.center.coords);
            },
            // Normal
            el1.normal,
            // Radius
            function () {
                // Radius (returns NaN if spheres don't touch)
                var r = el2.Radius(), s = dis();
                return Math.sqrt(r * r - s * s);
            },
        ];
    }
    static meetSphereSphere(el1, el2) {
        var skew = function () {
            var dist = el1.center.distance(el2.center), r1 = el1.Radius(), r2 = el2.Radius();
            return (r1 - r2) * (r1 + r2) / (dist * dist);
        };
        return [
            // Center
            function () {
                var s = skew();
                return [
                    1,
                    0.5 * ((1 - s) * el1.center.coords[1] + (1 + s) * el2.center.coords[1]),
                    0.5 * ((1 - s) * el1.center.coords[2] + (1 + s) * el2.center.coords[2]),
                    0.5 * ((1 - s) * el1.center.coords[3] + (1 + s) * el2.center.coords[3])
                ];
            },
            // Normal
            function () {
                return Statistics.subtract(el2.center.coords, el1.center.coords);
            },
            // Radius
            function () {
                // Radius (returns NaN if spheres don't touch)
                var dist = el1.center.distance(el2.center), r1 = el1.Radius(), r2 = el2.Radius(), s = skew(), rIxnSq = 0.5 * (r1 * r1 + r2 * r2 - 0.5 * dist * dist * (1 + s * s));
                return Math.sqrt(rIxnSq);
            },
        ];
    }
    /**
     * Test if parameters are inside of allowed ranges
     *
     * @param {Array} params Array of length 1 or 2
     * @param {Array} r_u First range
     * @param {Array} [r_v] Second range
     * @returns Boolean
     * @private
     */
    static _paramsOutOfRange(params, r_u, r_v) {
        return params[0] < r_u[0] || params[0] > r_u[1] ||
            (params.length > 1 && (params[1] < r_v[0] || params[1] > r_v[1]));
    }
    /**
     * Given the 2D screen coordinates of a point, finds the nearest point on the given
     * parametric curve or surface, and returns its view-space coordinates.
     * @param {Array} p 3D coordinates for which the closest point on the curve point is searched.
     * @param {JXG.Curve3D|JXG.Surface3D} target Parametric curve or surface to project to.
     * @param {Array} params New position of point on the target (i.e. it is a return value),
     * modified in place during the search, ending up at the nearest point.
     * Usually, point.position is supplied for params.
     *
     * @returns {Array} Array of length 4 containing the coordinates of the nearest point on the curve or surface.
     */
    static projectCoordsToParametric(p, target, n, params) {
        // The variables and parameters for the Cobyla constrained
        // minimization algorithm are explained in the Cobyla.js comments
        var rhobeg, // initial size of simplex (Cobyla)
        rhoend, // finial size of simplex (Cobyla)
        iprint = 0, // no console output (Cobyla)
        maxfun = 200, // call objective function at most 200 times (Cobyla)
        _minFunc, // Objective function for Cobyla
        f = Math.random() * 0.01 + 0.5, r_u, r_v, m = 2 * n;
        // adapt simplex size to parameter range
        if (n === 1) {
            r_u = [Type.evaluate(target.range[0]), Type.evaluate(target.range[1])];
            rhobeg = 0.1 * (r_u[1] - r_u[0]);
        }
        else if (n === 2) {
            r_u = [Type.evaluate(target.range_u[0]), Type.evaluate(target.range_u[1])];
            r_v = [Type.evaluate(target.range_v[0]), Type.evaluate(target.range_v[1])];
            rhobeg = 0.1 * Math.min(r_u[1] - r_u[0], r_v[1] - r_v[0]);
        }
        rhoend = rhobeg / 5e6;
        // Minimize distance of the new position to the original position
        _minFunc = function (n, m, w, con) {
            var p_new = [
                target.X.apply(target, w),
                target.Y.apply(target, w),
                target.Z.apply(target, w)
            ], xDiff = p[0] - p_new[0], yDiff = p[1] - p_new[1], zDiff = p[2] - p_new[2];
            if (m >= 2) {
                con[0] = w[0] - r_u[0];
                con[1] = -w[0] + r_u[1];
            }
            if (m >= 4) {
                con[2] = w[1] - r_v[0];
                con[3] = -w[1] + r_v[1];
            }
            return xDiff * xDiff + yDiff * yDiff + zDiff * zDiff;
        };
        // First optimization without range constraints to give a smooth draag experience on
        // cyclic structures.
        // Set the start values
        if (params.length === 0) {
            // If length > 0: take the previous position as start values for the optimization
            params[0] = f * (r_u[0] + r_u[1]);
            if (n === 2) {
                params[1] = f * (r_v[0] + r_v[1]);
            }
        }
        Nlp.FindMinimum(_minFunc, n, 0, params, rhobeg, rhoend, iprint, maxfun);
        // Update p which is used subsequently in _minFunc
        p = [target.X.apply(target, params),
            target.Y.apply(target, params),
            target.Z.apply(target, params)
        ];
        // If the optimal params are outside of the rang
        // Second optimization to obey the range constraints
        if (this._paramsOutOfRange(params, r_u, r_v)) {
            // Set the start values again
            params[0] = f * (r_u[0] + r_u[1]);
            if (n === 2) {
                params[1] = f * (r_v[0] + r_v[1]);
            }
            Nlp.FindMinimum(_minFunc, n, m, params, rhobeg, rhoend, iprint, maxfun);
        }
        return [1,
            target.X.apply(target, params),
            target.Y.apply(target, params),
            target.Z.apply(target, params)
        ];
    }
    // /**
    //  * Given a the screen coordinates of a point, finds the point on the
    //  * given parametric curve or surface which is nearest in screen space,
    //  * and returns its view-space coordinates.
    //  * @param {Array} pScr Screen coordinates to project.
    //  * @param {JXG.Curve3D|JXG.Surface3D} target Parametric curve or surface to project to.
    //  * @param {Array} params Parameters of point on the target, initially specifying the starting point of
    //  * the search. The parameters are modified in place during the search, ending up at the nearest point.
    //  * @returns {Array} Array of length 4 containing the coordinates of the nearest point on the curve or surface.
    //  */
    // projectScreenCoordsToParametric(pScr, target, params) {
    //     // The variables and parameters for the Cobyla constrained
    //     // minimization algorithm are explained in the Cobyla.js comments
    //     var rhobeg, // initial size of simplex (Cobyla)
    //         rhoend, // finial size of simplex (Cobyla)
    //         iprint = 0, // no console output (Cobyla)
    //         maxfun = 200, // call objective function at most 200 times (Cobyla)
    //         dim = params.length,
    //         _minFunc; // objective function (Cobyla)
    //     // adapt simplex size to parameter range
    //     if (dim === 1) {
    //         rhobeg = 0.1 * (target.range[1] - target.range[0]);
    //     } else if (dim === 2) {
    //         rhobeg = 0.1 * Math.min(
    //             target.range_u[1] - target.range_u[0],
    //             target.range_v[1] - target.range_v[0]
    //         );
    //     }
    //     rhoend = rhobeg / 5e6;
    //     // minimize screen distance to cursor
    //     _minFunc = function (n, m, w, con) {
    //         var c3d = [
    //             1,
    //             target.X.apply(target, w),
    //             target.Y.apply(target, w),
    //             target.Z.apply(target, w)
    //         ],
    //         c2d = target.view.project3DTo2D(c3d),
    //         xDiff = pScr[0] - c2d[1],
    //         yDiff = pScr[1] - c2d[2];
    //         if (n === 1) {
    //             con[0] = w[0] - target.range[0];
    //             con[1] = -w[0] + target.range[1];
    //         } else if (n === 2) {
    //             con[0] = w[0] - target.range_u[0];
    //             con[1] = -w[0] + target.range_u[1];
    //             con[2] = w[1] - target.range_v[0];
    //             con[3] = -w[1] + target.range_v[1];
    //         }
    //         return xDiff * xDiff + yDiff * yDiff;
    //     };
    //     Mat.Nlp.FindMinimum(_minFunc, dim, 2 * dim, params, rhobeg, rhoend, iprint, maxfun);
    //     return [1, target.X.apply(target, params), target.Y.apply(target, params), target.Z.apply(target, params)];
    // }
    static project3DTo3DPlane(point, normal, foot) {
        // TODO: homogeneous 3D coordinates
        var sol = [0, 0, 0], le, d1, d2, lbda;
        foot = foot || [0, 0, 0];
        le = JSXMath.norm(normal);
        d1 = JSXMath.innerProduct(point, normal, 3);
        d2 = JSXMath.innerProduct(foot, normal, 3);
        // (point - lbda * normal / le) * normal / le == foot * normal / le
        // => (point * normal - foot * normal) ==  lbda * le
        lbda = (d1 - d2) / le;
        sol = JSXMath.axpy(-lbda, normal, point);
        return sol;
    }
    static getPlaneBounds(v1, v2, q, s, e) {
        var s1, s2, e1, e2, mat, rhs, sol;
        if (v1[2] + v2[0] !== 0) {
            mat = [
                [v1[0], v2[0]],
                [v1[1], v2[1]]
            ];
            rhs = [s - q[0], s - q[1]];
            sol = Numerics.Gauss(mat, rhs);
            s1 = sol[0];
            s2 = sol[1];
            rhs = [e - q[0], e - q[1]];
            sol = Numerics.Gauss(mat, rhs);
            e1 = sol[0];
            e2 = sol[1];
            return [s1, e1, s2, e2];
        }
        return null;
    }
    /* ***************************************/
    /* *** Various ****/
    /* ***************************************/
    /**
     * Helper function to create curve which displays a Reuleaux polygons.
     * @param {Array} points Array of points which should be the vertices of the Reuleaux polygon. Typically,
     * these point list is the array vertices of a regular polygon.
     * @param {Number} nr Number of vertices
     * @returns {Array} An array containing the two functions defining the Reuleaux polygon and the two values
     * for the start and the end of the paramtric curve. array may be used as parent array of a
     * {@link JXG.Curve}.
     *
     * @example
     * var A = brd.create('point',[-2,-2]);
     * var B = brd.create('point',[0,1]);
     * var pol = brd.create('regularpolygon',[A,B,3], {withLines:false, fillColor:'none', highlightFillColor:'none', fillOpacity:0.0});
     * var reuleauxTriangle = brd.create('curve', Geometry.reuleauxPolygon(pol.vertices, 3),
     *                          {strokeWidth:6, strokeColor:'#d66d55', fillColor:'#ad5544', highlightFillColor:'#ad5544'});
     *
     * </pre><div class="jxgbox" id="JXG2543a843-46a9-4372-abc1-94d9ad2db7ac" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     * var brd = JXG.JSXGraph.initBoard('JXG2543a843-46a9-4372-abc1-94d9ad2db7ac', {boundingbox: [-5, 5, 5, -5], axis: true, showcopyright:false, shownavigation: false});
     * var A = brd.create('point',[-2,-2]);
     * var B = brd.create('point',[0,1]);
     * var pol = brd.create('regularpolygon',[A,B,3], {withLines:false, fillColor:'none', highlightFillColor:'none', fillOpacity:0.0});
     * var reuleauxTriangle = brd.create('curve', Geometry.reuleauxPolygon(pol.vertices, 3),
     *                          {strokeWidth:6, strokeColor:'#d66d55', fillColor:'#ad5544', highlightFillColor:'#ad5544'});
     * </script><pre>
     */
    static reuleauxPolygon(points, nr) {
        var beta, pi2 = Math.PI * 2, pi2_n = pi2 / nr, diag = (nr - 1) / 2, d = 0, makeFct = function (which, trig) {
            return function (t, suspendUpdate) {
                var t1 = ((t % pi2) + pi2) % pi2, j = Math.floor(t1 / pi2_n) % nr;
                if (!suspendUpdate) {
                    d = points[0].Dist(points[diag]);
                    beta = Geometry.rad([points[0].X() + 1, points[0].Y()], points[0], points[diag % nr]);
                }
                if (isNaN(j)) {
                    return j;
                }
                t1 = t1 * 0.5 + j * pi2_n * 0.5 + beta;
                return points[j][which]() + d * Math[trig](t1);
            };
        };
        return [makeFct("X", "cos"), makeFct("Y", "sin"), 0, pi2];
    }
}

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */
/**
 * Event namespace
 * @namespace
 */
class Events {
    constructor() {
        /**  Holds the registered event handlers.  */
        this.eventHandlers = {};
        /**  Events can be suspended to prevent endless loops. */
        this.suspended = {};
        /** initially this.trigger() */
        this.triggerEventHandlers = this.trigger;
    }
    /**
     * Triggers all event handlers of this element for a given event.
     * Not called directly, serves as default function for triggerEventHandlers
     * @param {
     * @param {Array} args The arguments passed onto the event handler
     * @returns Reference to the object.
     */
    trigger(event, args) {
        console.log();
        let len1 = event.length;
        for (let j = 0; j < len1; j++) {
            let evt = this.eventHandlers[event[j]];
            if (!this.suspended[event[j]]) {
                this.suspended[event[j]] = true;
                if (evt) {
                    for (let i = 0; i < evt.length; i++) {
                        let h = evt[i];
                        h.handler.apply(h.context, args);
                    }
                }
                this.suspended[event[j]] = false;
            }
        }
        return this;
    }
    /**
     * Register a new event handler. For a list of possible events see documentation
     * of the elements and objects implementing
     * the {@link EventEmitter} interface.
     *
     * As of version 1.5.0, it is only possible to access the element via "this" if the event listener
     * is supplied as regular JavaScript function and not as arrow function.
     *
     * @param {String} event
     * @param {Function} handler
     * @param {Object} [context] The context the handler will be called in, default is the element itself.
     * @returns Reference to the object.
     */
    on(event, handler, context = this) {
        // have we initialized this event yet?
        if (!Array.isArray(this.eventHandlers[event])) {
            this.eventHandlers[event] = [];
        }
        context = Type.def(context, this);
        this.eventHandlers[event].push({
            handler: handler,
            context: context
        });
        return this;
    }
    /** Unregister an event handler.
     * @returns Reference to the context object.
     */
    off(event, handler) {
        // if eventhandler not initialized we can quick-exit
        if (!event || !Array.isArray(this.eventHandlers[event])) {
            return this;
        }
        if (handler) {
            let i = Type.indexOf(this.eventHandlers[event], handler, "handler");
            if (i > -1) {
                // found it
                this.eventHandlers[event].splice(i, 1);
            }
            if (this.eventHandlers[event].length === 0) {
                delete this.eventHandlers[event];
            }
        }
        else {
            delete this.eventHandlers[event];
        }
        return this;
    }
}

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */
class GeometryElement extends Events {
    /**
     * Constructs a new GeometryElement object.
     * @class This is the parent class for all geometry elements like points, circles, lines, curves...
     * @constructor
     * @param  board Reference to the board the element is constructed on.
     * @param {Object} attributes Hash of attributes and their values.
     * @param {Number} otype Element type (a <tt>JXG.OBJECT_TYPE_</tt> value).
     * @param {Number} oclass The element's class (a <tt>JXG.OBJECT_CLASS_</tt> value).
     * @borrows JXG.EventEmitter#on as this.on
     * @borrows JXG.EventEmitter#off as this.off
     * @borrows JXG.EventEmitter#triggerEventHandlers as this.triggerEventHandlers
     * @borrows JXG.EventEmitter#eventHandlers as this.eventHandlers
     */
    constructor(board, attributes) {
        super();
        this.borders = []; //  renderers want this
        // public updateSize:Function
        /**
         * Controls if updates are necessaryclass
         * @type Boolean
         * @default true
         */
        this.needsUpdate = true;
        /**
         * Controls if this element can be dragged. In GEONExT only
         * free points and gliders can be dragged.
         * @type Boolean
         * @default false
         */
        this.isDraggable = false;
        // /**
        //  * If element is in two dimensional real space this is true, else false.
        //  * @type Boolean
        //  * @default true
        //  */
        this.isReal = true;
        /**
         * Stores all dependent objects to be updated when this point is moved.
         * @type Object
         */
        this.childElements = {};
        /**
         * If element has a label subelement then this property will be set to true.
         * @type Boolean
         * @default false
         */
        this.hasLabel = false;
        /**
         * True, if the element is currently highlighted.
         * @type Boolean
         * @default false
         */
        this.highlighted = false;
        /**
         * Stores all Intersection Objects which in this moment are not real and
         * so hide this element.
         * @type Object
         */
        this.notExistingParents = {};
        /**
         * Keeps track of all objects drawn as part of the trace of the element.
         * @see JXG.GeometryElement#clearTrace
         * @see JXG.GeometryElement#numTraces
         * @type Object
         */
        this.traces = {};
        /**
         * Counts the number of objects drawn as part of the trace of the element.
         * @see JXG.GeometryElement#clearTrace
         * @see JXG.GeometryElement#traces
         * @type Number
         */
        this.numTraces = 0;
        /**
         * Stores the  transformations which are applied during update in an array
         * @type Array
         * @see JXG.Transformation
         */
        this.transformations = [];
        /**
         * @type JXG.GeometryElement
         * @default null
         * @private
         */
        this.baseElement = null;
        /**
         * Elements depending on this element are stored here.
         * @type Object
         */
        this.descendants = {};
        /**
         * Elements on which this element depends on are stored here.
         * @type Object
         */
        this.ancestors = {};
        /**
         * Ids of elements on which this element depends directly are stored here.
         * @type Object
         */
        this.parents = [];
        /**
         * Stores variables for symbolic computations
         * @type Object
         */
        this.symbolic = {};
        /**  Type of the element.   */
        this.type = OBJECT_TYPE.NOTYETASSIGNED;
        /**  Class of the element.   */
        this.class = OBJECT_CLASS.OTHER;
        /**
         * Storage for HTMLElements for arrows
         */
        this.rendNodeTriangleStart = null;
        /**
         * Storage for HTMLElements for arrows
         */
        this.rendNodeTriangleEnd = null;
        /**
         * The string used with {@link JXG.Board#create}
         * @type String
         */
        this.elType = "";
        /**
         * The element is saved with an explicit entry in the file (<tt>true</tt>) or implicitly
         * via a composition.
         * @type Boolean
         * @default true
         */
        this.dump = true;
        /**
         * Subs contains the subelements, created during the create method.
         * @type Object
         */
        this.subs = {};
        /**
         * Inherits contains the subelements, which may have an attribute
         * (in particular the attribute "visible") having value 'inherit'.
         * @type Object
         */
        this.inherits = [];
        /**
         * The position of this element inside the {@link JXG.Board#objectsList}.
         * @type Number
         * @default -1
         * @private
         */
        this._pos = -1;
        /**
         * [c, b0, b1, a, k, r, q0, q1]
         *
         * See
         * A.E. Middleditch, T.W. Stacey, and S.B. Tor:
         * "Intersection Algorithms for Lines and Circles",
         * ACM Transactions on Graphics, Vol. 8, 1, 1989, pp 25-40.
         *
         * The meaning of the parameters is:
         * Circle: points p=[p0, p1] on the circle fulfill
         *  a&lt;p, p&gt; + &lt;b, p&gt; + c = 0
         * For convenience we also store
         *  r: radius
         *  k: discriminant = sqrt(&lt;b,b&gt;-4ac)
         *  q=[q0, q1] center
         *
         * Points have radius = 0.
         * Lines have radius = infinity.
         * b: normalized vector, representing the direction of the line.
         *
         * Should be put into Coords, when all elements possess Coords.
         */
        this.stdform = [1, 0, 0, 0, 1, 1, 0, 0];
        /**
         * The methodMap determines which methods can be called from within JessieCode and under which name it
         * can be used. The map is saved in an object, the name of a property is the name of the method used in JessieCode,
         * the value of a property is the name of the method in JavaScript.
         * @type Object
         */
        this.methodMap = {
            setLabel: "setLabel",
            label: "label",
            setName: "setName",
            getName: "getName",
            Name: "getName",
            addTransform: "addTransform",
            setProperty: "setAttribute",
            setAttribute: "setAttribute",
            addChild: "addChild",
            animate: "animate",
            on: "on",
            off: "off",
            trigger: "trigger",
            addTicks: "addTicks",
            removeTicks: "removeTicks",
            removeAllTicks: "removeAllTicks",
            Bounds: "bounds"
        };
        /**
         * Quadratic form representation of circles (and conics)
         * @type Array
         * @default [[1,0,0],[0,1,0],[0,0,1]]
         */
        this.quadraticform = [
            [1, 0, 0],
            [0, 1, 0],
            [0, 0, 1]
        ];
        /**
         * An associative array containing all visual properties.
         * @type Object
         * @default empty object
         */
        this.visProp = {};
        /**
         * An associative array containing visual properties which are calculated from
         * the attribute values (i.e. visProp) and from other constraints.
         * An example: if an intersection point does not have real coordinates,
         * visPropCalc.visible is set to false.
         * Additionally, the user can control visibility with the attribute "visible",
         * even by supplying a functions as value.
         *
         * @type Object
         * @default empty object
         */
        this.visPropCalc = {
            visible: false
        };
        /**
         * Is the mouse over this element?
         * @type Boolean
         * @default false
        */
        this.mouseover = false;
        /**
         * Time stamp containing the last time this element has been dragged.
         * @type Date
         * @default creation time
        */
        this.lastDragTime = new Date();
        this.view = null;
        this.usrCoords = [];
        this.scrCoords = [];
        // TODO does this belong here?
        this.point1 = null; // used by line
        this.point2 = null;
        this.points = []; // used by curve
        this.center = null; // used by circle
        this.radius = 1;
        this.vertices = []; // used by polygon
        this.visPropOld = {};
        this.ticks = [];
        this.animationCallback = () => { };
        this.animationData = {};
        var name, key, attr;
        if (board == undefined) {
            throw new Error('who did not send Board??');
        }
        this.visProp = Type.merge(this.visProp, Options.elements);
        this.board = board;
        if (arguments.length > 0) {
            // this.board = board;
            // /**
            //  * Unique identifier for the element. Equivalent to id-attribute of renderer element.
            //  * @type String
            // */
            // this.id = attributes.id;
            if (attributes.hasOwnProperty('name')) {
                name = attributes['name'];
            }
            else {
                /* If name is not set or null or even undefined, generate an unique name for this object */
                name = this.board.generateName(this);
            }
            if (name !== "") {
                this.board.elementsByName[name] = this;
            }
            /**
             * Not necessarily unique name for the element.
             * @type String
             * @default Name generated by {@link JXG.Board#generateName}.
             * @see JXG.Board#generateName
            */
            this.name = name;
            // TODO - needsRegularUpdates is a GeometryElement value
            // this.needsRegularUpdate = attributes.needsRegularUpdate;
            // create this.visPropOld and set default values
            Type.clearVisPropOld(this);
            attr = this.resolveShortcuts(attributes);
            for (key in attr) {
                if (attr.hasOwnProperty(key)) {
                    this._set(key, attr[key]);
                }
            }
            this.visProp.draft = attr.draft && attr.draft.draft;
            //this.visProp.gradientangle = '270';
            // this.visProp.gradientsecondopacity = this.evalVisProp('fillopacity');
            //this.visProp.gradientpositionx = 0.5;
            //this.visProp.gradientpositiony = 0.5;
        }
        // EventEmitter.eventify(this);  // tb now handled by class hierarchy
    }
    /**
     * Add an element as a child to the current element. Can be used to model dependencies between geometry elements.
     * @param {JXG.GeometryElement} obj The dependent object.
     */
    addChild(obj) {
        var el, el2;
        this.childElements[obj.id] = obj;
        this.addDescendants(obj); // TODO TomBerend removed this. Check if it is possible.
        obj.ancestors[this.id] = this;
        for (el in this.descendants) {
            if (this.descendants.hasOwnProperty(el)) {
                this.descendants[el].ancestors[this.id] = this;
                for (el2 in this.ancestors) {
                    if (this.ancestors.hasOwnProperty(el2)) {
                        this.descendants[el].ancestors[this.ancestors[el2].id] =
                            this.ancestors[el2];
                    }
                }
            }
        }
        for (el in this.ancestors) {
            if (this.ancestors.hasOwnProperty(el)) {
                for (el2 in this.descendants) {
                    if (this.descendants.hasOwnProperty(el2)) {
                        this.ancestors[el].descendants[this.descendants[el2].id] =
                            this.descendants[el2];
                    }
                }
            }
        }
        return this;
    }
    /**
     * @param {JXG.GeometryElement} obj The element that is to be added to the descendants list.
     * @private
     * @return this
    */
    // Adds the given object to the descendants list of this object and all its child objects.
    addDescendants(obj) {
        var el;
        this.descendants[obj.id] = obj;
        for (el in obj.childElements) {
            if (obj.childElements.hasOwnProperty(el)) {
                this.addDescendants(obj.childElements[el]);
            }
        }
        return this;
    }
    /**
     * Adds ids of elements to the array this.parents. This method needs to be called if some dependencies
     * can not be detected automatically by JSXGraph. For example if a function graph is given by a function
     * which refers to coordinates of a point, calling addParents() is necessary.
     *
     * @param {Array} parents Array of elements or ids of elements.
     * Alternatively, one can give a list of objects as parameters.
     * @returns {JXG.Object} reference to the object itself.
     *
     * @example
     * // Movable function graph
     * var A = board.create('point', [1, 0], {name:'A'}),
     *     B = board.create('point', [3, 1], {name:'B'}),
     *     f = board.create('functiongraph', function(x) {
     *          var ax = A.X(),
     *              ay = A.Y(),
     *              bx = B.X(),
     *              by = B.Y(),
     *              a = (by - ay) / ( (bx - ax) * (bx - ax) );
     *           return a * (x - ax) * (x - ax) + ay;
     *      } {fixed: false});
     * f.addParents([A, B]);
     * </pre><div class="jxgbox" id="JXG7c91d4d2-986c-4378-8135-24505027f251" style="width: 400px; height: 400px;"></div>
     * <script type="text/javascript">
     * (function() {
     *   var board = JXG.JSXGraph.initBoard('JXG7c91d4d2-986c-4378-8135-24505027f251', {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});
     *   var A = board.create('point', [1, 0], {name:'A'}),
     *       B = board.create('point', [3, 1], {name:'B'}),
     *       f = board.create('functiongraph', function(x) {
     *            var ax = A.X(),
     *                ay = A.Y(),
     *                bx = B.X(),
     *                by = B.Y(),
     *                a = (by - ay) / ( (bx - ax) * (bx - ax) );
     *             return a * (x - ax) * (x - ax) + ay;
     *        } {fixed: false});
     *   f.addParents([A, B]);
     * })();
     * </script><pre>
     *
     **/
    addParents(parents) {
        var i, len, par;
        if (Array.isArray(parents)) {
            par = parents;
        }
        else {
            throw new Error('parents should be an array');
        }
        len = par.length;
        for (i = 0; i < len; ++i) {
            if (!Type.exists(par[i])) {
                continue;
            }
            if (Type.isId(this.board, par[i])) {
                this.parents.push(par[i]);
            }
            else if (Type.exists(par[i].id)) {
                this.parents.push(par[i].id);
            }
        }
        this.parents = Type.uniqueArray(this.parents);
    }
    /**
     * Sets ids of elements to the array this.parents.
     * First, this.parents is cleared. See {@link JXG.GeometryElement#addParents}.
     * @param {Array} parents Array of elements or ids of elements.
     * Alternatively, one can give a list of objects as parameters.
     * @returns {JXG.Object} reference to the object itself.
     **/
    setParents(parents) {
        this.parents = [];
        this.addParents(parents);
    }
    /**
     * Add dependence on elements in JessieCode functions.
     * @param {Array} function_array Array of functions containing potential properties "deps" with
     * elements the function depends on.
     * @returns {JXG.Object} reference to the object itself
     * @private
     */
    addParentsFromJCFunctions(function_array) {
        var i, e, obj;
        for (i = 0; i < function_array.length; i++) {
            for (e in function_array[i].deps) {
                obj = function_array[i].deps[e];
                this.addParents(obj);
                obj.addChild(this);
            }
        }
        return this;
    }
    /**
     * Remove an element as a child from the current element.
     * @param {JXG.GeometryElement} obj The dependent object.
     * @returns {JXG.Object} reference to the object itself
     */
    removeChild(obj) {
        //var el, el2;
        delete this.childElements[obj.id];
        this.removeDescendants(obj);
        delete obj.ancestors[this.id];
        /*
         // I do not know if these addDescendants stuff has to be adapted to removeChild. A.W.
        for (el in this.descendants) {
            if (this.descendants.hasOwnProperty(el)) {
                delete this.descendants[el].ancestors[this.id];

                for (el2 in this.ancestors) {
                    if (this.ancestors.hasOwnProperty(el2)) {
                        this.descendants[el].ancestors[this.ancestors[el2].id] = this.ancestors[el2];
                    }
                }
            }
        }

        for (el in this.ancestors) {
            if (this.ancestors.hasOwnProperty(el)) {
                for (el2 in this.descendants) {
                    if (this.descendants.hasOwnProperty(el2)) {
                        this.ancestors[el].descendants[this.descendants[el2].id] = this.descendants[el2];
                    }
                }
            }
        }
        */
        return this;
    }
    /**
     * Removes the given object from the descendants list of this object and all its child objects.
     * @param {JXG.GeometryElement} obj The element that is to be removed from the descendants list.
     * @private
     * @returns {JXG.Object} reference to the object itself
     */
    removeDescendants(obj) {
        var el;
        delete this.descendants[obj.id];
        for (el in obj.childElements) {
            if (obj.childElements.hasOwnProperty(el)) {
                this.removeDescendants(obj.childElements[el]);
            }
        }
        return this;
    }
    /**
     * Counts the direct children of an object without counting labels.
     * @private
     * @returns {number} Number of children
     */
    countChildren() {
        var prop, d, s = 0;
        d = this.childElements;
        for (prop in d) {
            if (d.hasOwnProperty(prop) && prop.indexOf("Label") < 0) {
                s++;
            }
        }
        return s;
    }
    /**
     * Returns the elements name. Used in JessieCode.
     * @returns {String}
     */
    getName() {
        return this.name;
    }
    /**
     * Add transformations to this element.
     * @param {JXG.Transformation|Array} transform Either one {@link JXG.Transformation}
     * or an array of {@link JXG.Transformation}s.
     * @returns {JXG.GeometryElement} Reference to the element.
     */
    addTransform(el, transform) {
        console.error('addTransform abstract method');
        return this;
    }
    /**
     * Decides whether an element can be dragged. This is used in
     * {@link JXG.GeometryElement#setPositionDirectly} methods
     * where all parent elements are checked if they may be dragged, too.
     * @private
     * @returns {boolean}
     */
    draggable() {
        return (this.isDraggable &&
            !this.evalVisProp('fixed') &&
            // !this.visProp.frozen &&
            this.type !== OBJECT_TYPE.GLIDER);
    }
    /**
     * Translates the object by <tt>(x, y)</tt>. In case the element is defined by points, the defining points are
     * translated, e.g. a circle constructed by a center point and a point on the circle line.
     * @param {Number} method The type of coordinates used here.
     * Possible values are {@link COORDS_BY.USER} and {@link COORDS_BY.SCREEN}.
     * @param {Array} coords array of translation vector.
     * @returns {JXG.GeometryElement} Reference to the element object.
     *
     * @see JXG.GeometryElement3D#setPosition2D
     */
    setPosition(method, coords) {
        var parents = [], el, i, len, t;
        if (!Type.exists(this.parents)) {
            return this;
        }
        len = this.parents.length;
        for (i = 0; i < len; ++i) {
            el = this.board.select(this.parents[i]);
            if (Type.isPoint(el)) {
                if (!el.draggable()) {
                    return this;
                }
                parents.push(el);
            }
        }
        if (coords.length === 3) {
            coords = coords.slice(1);
        }
        t = this.board.create("transform", coords, { type: "translate" });
        // We distinguish two cases:
        // 1) elements which depend on free elements, i.e. arcs and sectors
        // 2) other elements
        //
        // In the first case we simply transform the parents elements
        // In the second case we add a transform to the element.
        //
        len = parents.length;
        if (len > 0) {
            t.applyOnce(parents);
            // TODO: defer 3D
            // // Handle dragging of a 3D element
            // if (this.view !== null && this.view.elType === 'view3d') {
            //     for (i = 0; i < this.parents.length; ++i) {
            //         // Search for the parent 3D element
            //         el = this.view.select(this.parents[i]);
            //         if (Type.exists(el.setPosition2D)) {
            //             el.setPosition2D(t);
            //         }
            //     }
            // }
        }
        else {
            if (this.transformations.length > 0 &&
                this.transformations[this.transformations.length - 1].isNumericMatrix) {
                this.transformations[this.transformations.length - 1].melt(t);
            }
            else {
                this.addTransform(el, t);
            }
        }
        /*
         * If - against the default configuration - defining gliders are marked as
         * draggable, then their position has to be updated now.
         */
        for (i = 0; i < len; ++i) {
            if (parents[i].type === OBJECT_TYPE.GLIDER) {
                parents[i].updateGlider();
            }
        }
        return this;
    }
    /**
     * Moves an element by the difference of two coordinates.
     * @param {Number} method The type of coordinates used here.
     * Possible values are {@link COORDS_BY.USER} and {@link COORDS_BY.SCREEN}.
     * @param {Array} coords coordinates in screen/user units
     * @param {Array} oldcoords previous coordinates in screen/user units
     * @returns {JXG.GeometryElement} this element
     */
    setPositionDirectly(method, coords, oldcoords) {
        var c = new Coords$1(method, coords, this.board, false), oldc = new Coords$1(method, oldcoords, this.board, false), dc = Statistics.subtract(c.usrCoords, oldc.usrCoords);
        this.setPosition(COORDS_BY.USER, dc);
        return this;
    }
    /**
     * Array of strings containing the polynomials defining the element.
     * Used for determining geometric loci the groebner way.
     * @returns {Array} An array containing polynomials describing the locus of the current object.
     * @public
     */
    generatePolynomial() {
        console.error('what does this expect?');
        return [1, 2, 3];
    }
    /**
     * Animates properties for that object like stroke or fill color, opacity and maybe
     * even more later.
     * @param {Object} hash Object containing properties with target values for the animation.
     * @param {number} time Number of milliseconds to complete the animation.
     * @param {Object} [options] Optional settings for the animation:<ul><li>callback: A function that is called as soon as the animation is finished.</li></ul>
     * @returns {JXG.GeometryElement} A reference to the object
     */
    animate(hash, time, options) {
        options = options || {};
        var r, p, i, delay = this.board.attr.animationdelay, steps = Math.ceil(time / delay), self = this;
        let animateColor = function (startRGB, endRGB, property) {
            var hsv1, hsv2, sh, ss, sv;
            hsv1 = Color.rgb2hsv(startRGB);
            hsv2 = Color.rgb2hsv(endRGB);
            sh = (hsv2[0] - hsv1[0]) / steps;
            ss = (hsv2[1] - hsv1[1]) / steps;
            sv = (hsv2[2] - hsv1[2]) / steps;
            self.animationData[property] = [];
            for (i = 0; i < steps; i++) {
                self.animationData[property][steps - i - 1] = Color.hsv2rgb(hsv1[0] + (i + 1) * sh, hsv1[1] + (i + 1) * ss, hsv1[2] + (i + 1) * sv);
            }
        };
        let animateFloat = function (start, end, property, round) {
            var tmp, s;
            start = parseFloat(start);
            end = parseFloat(end);
            // we can't animate without having valid numbers.
            // And parseFloat returns NaN if the given string doesn't contain
            // a valid float number.
            if (isNaN(start) || isNaN(end)) {
                return;
            }
            s = (end - start) / steps;
            self.animationData[property] = [];
            for (i = 0; i < steps; i++) {
                tmp = start + (i + 1) * s;
                self.animationData[property][steps - i - 1] = round
                    ? Math.floor(tmp)
                    : tmp;
            }
        };
        this.animationData = {};
        for (r in hash) {
            if (hash.hasOwnProperty(r)) {
                p = r.toLowerCase();
                switch (p) {
                    case "strokecolor":
                    case "fillcolor":
                        animateColor(this.visProp[p], hash[r], p);
                        break;
                    case "size":
                        if (!Type.isPoint(this)) {
                            break;
                        }
                        animateFloat(this.visProp[p], hash[r], p, true);
                        break;
                    case "strokeopacity":
                    case "strokewidth":
                    case "fillopacity":
                        animateFloat(this.visProp[p], hash[r], p, false);
                        break;
                }
            }
        }
        this.animationCallback = options.callback;
        this.board.addAnimation(this);
        return this;
    }
    /**
     * General update method. Should be overwritten by the element itself.
     * Can be used sometimes to commit changes to the object.
     * @return {JXG.GeometryElement} Reference to the element
     */
    update(fromParent = true) {
        if (this.evalVisProp('trace')) {
            this.cloneToBackground();
        }
        return this;
    }
    // TODO:  require all classes to have 'implements CoordsInterface' with methods like 'update'
    /**
     * Provide updateRenderer method.
     * @return {JXG.GeometryElement} Reference to the element
     * @private
     */
    updateRenderer() {
        return this;
    }
    /**
     * Run through the full update chain of an element.
     * @param  {Boolean} visible Set visibility in case the elements attribute value is 'inherit'. null is allowed.
     * @return {JXG.GeometryElement} Reference to the element
     * @private
     */
    fullUpdate(visible = 'inherit') {
        return this.prepareUpdate().update(true).updateVisibility(visible).updateRenderer();
    }
    /**
     * Show the element or hide it. If hidden, it will still exist but not be
     * visible on the board.
     * <p>
     * Sets also the display of the inherits elements. These can be
     * JSXGraph elements or arrays of JSXGraph elements.
     * However, deeper nesting than this is not supported.
     *
     * @param  {Boolean} val true: show the element, false: hide the element
     * @return {JXG.GeometryElement} Reference to the element
     * @private
     */
    setDisplayRendNode(val) {
        var i, len, s, len_s, obj;
        if (val === undefined) {
            val = this.visPropCalc.visible;
        }
        if (val === this.visProp.visible) {
            return this;
        }
        // Set display of the element itself
        this.board.renderer.display(this, val);
        // Set the visibility of elements which inherit the attribute 'visible'
        len = this.inherits.length;
        for (s = 0; s < len; s++) {
            obj = this.inherits[s];
            if (Array.isArray(obj)) {
                len_s = obj.length;
                for (i = 0; i < len_s; i++) {
                    if (Type.exists(obj[i]) &&
                        Type.exists(obj[i].rendNode) &&
                        obj[i].evalVisProp('visible') === 'inherit') {
                        obj[i].setDisplayRendNode(val);
                    }
                }
            }
            else {
                if (Type.exists(obj) &&
                    Type.exists(obj.rendNode) &&
                    obj.evalVisProp('visible') === 'inherit') {
                    obj.setDisplayRendNode(val);
                }
            }
        }
        // Set the visibility of the label if it inherits the attribute 'visible'
        if (this.hasLabel && Type.exists(this.label) && Type.exists(this.label.rendNode)) {
            if (this.label.evalVisProp('visible') === "inherit") {
                this.label.setDisplayRendNode(val);
            }
        }
        return this;
    }
    /**
     * Hide the element. It will still exist but not be visible on the board.
     * Alias for "element.setAttribute({visible: false});"
     * @return {JXG.GeometryElement} Reference to the element
     */
    hide() {
        this.setAttribute({ visible: false });
        return this;
    }
    /**
     * Hide the element. It will still exist but not be visible on the board.
     * Alias for {@link JXG.GeometryElement#hide}
     * @returns {JXG.GeometryElement} Reference to the element
     */
    hideElement() {
        this.hide();
        return this;
    }
    /**
     * Make the element visible.
     * Alias for "element.setAttribute({visible: true});"
     * @return {JXG.GeometryElement} Reference to the element
     */
    show() {
        this.setAttribute({ visible: true });
        return this;
    }
    /**
     * Make the element visible.
     * Alias for {@link JXG.GeometryElement#show}
     * @returns {JXG.GeometryElement} Reference to the element
     */
    showElement() {
        this.show();
        return this;
    }
    /**
     * Set the visibility of an element. The visibility is influenced by
     * (listed in ascending priority):
     * <ol>
     * <li> The value of the element's attribute 'visible'
     * <li> The visibility of a parent element. (Example: label)
     * This overrules the value of the element's attribute value only if
     * this attribute value of the element is 'inherit'.
     * <li> being inside of the canvas
     * </ol>
     * <p>
     * This method is called three times for most elements:
     * <ol>
     * <li> between {@link JXG.GeometryElement#update}
     * and {@link JXG.GeometryElement#updateRenderer}. In case the value is 'inherit', nothing is done.
     * <li> Recursively, called by itself for child elements. Here, 'inherit' is overruled by the parent's value.
     * <li> In {@link JXG.GeometryElement#updateRenderer} if the element is outside of the canvas.
     * </ol>
     *
     * @param  {Boolean} parent_val Visibility of the parent element.
     * @return {JXG.GeometryElement} Reference to the element.
     * @private
     */
    updateVisibility(parent_val = true) {
        var i, len, s, len_s, obj, val;
        if (this.needsUpdate) {
            if (this.view !== null && this.view.evalVisProp('visible') === false) {
                // Handle hiding of view3d
                this.visPropCalc.visible = false;
            }
            else {
                // Handle the element
                if (parent_val !== undefined) {
                    this.visPropCalc.visible = Boolean(parent_val); // TODO test this
                }
                else {
                    val = this.evalVisProp('visible');
                    // infobox uses hiddenByParent
                    if (Type.exists(this.hiddenByParent) && this.hiddenByParent) {
                        val = false;
                    }
                    if (val !== "inherit") {
                        this.visPropCalc.visible = val;
                    }
                }
                // Handle elements which inherit the visibility
                len = this.inherits.length;
                for (s = 0; s < len; s++) {
                    obj = this.inherits[s];
                    if (Array.isArray(obj)) {
                        len_s = obj.length;
                        for (i = 0; i < len_s; i++) {
                            if (Type.exists(obj[i]) /*&& Type.exists(obj[i].rendNode)*/ &&
                                obj[i].evalVisProp('visible') === "inherit") {
                                obj[i]
                                    .prepareUpdate()
                                    .updateVisibility(this.visPropCalc.visible);
                            }
                        }
                    }
                    else {
                        if (Type.exists(obj) /*&& Type.exists(obj.rendNode)*/ &&
                            obj.evalVisProp('visible') === "inherit") {
                            obj.prepareUpdate().updateVisibility(this.visPropCalc.visible);
                        }
                    }
                }
            }
            // Handle the label if it inherits the visibility
            if (Type.exists(this.label) &&
                Type.exists(this.label.visProp) &&
                this.label.evalVisProp('visible')) {
                this.label.prepareUpdate().updateVisibility(this.visPropCalc.visible);
            }
        }
        return this;
    }
    /**
     * Sets the value of attribute <tt>key</tt> to <tt>value</tt>.
     * Here, mainly hex strings for rga(a) colors are parsed and values of type object get a special treatment.
     * Other values are just set to the key.
     *
     * @param {String} key The attribute's name.
     * @param value The new value
     * @private
     */
    _set(key, value) {
        var el;
        key = key.toLocaleLowerCase();
        // Search for entries in visProp with "color" as part of the key name
        // and containing a RGBA string
        if (this.visProp.hasOwnProperty(key) &&
            key.indexOf("color") >= 0 &&
            Type.isString(value) &&
            value.length === 9 &&
            value.charAt(0) === "#") {
            value = Color.rgba2rgbo(value);
            this.visProp[key] = value[0];
            // Previously: *=. But then, we can only decrease opacity.
            this.visProp[key.replace("color", "opacity")] = value[1];
        }
        else {
            if (value !== null &&
                Type.isObject(value) &&
                !Type.exists(value.id) &&
                !Type.exists(value.name)) {
                // value is of type {prop: val, prop: val,...}
                // Convert these attributes to lowercase, too
                this.visProp[key] = {};
                for (el in value) {
                    if (value.hasOwnProperty(el)) {
                        this.visProp[key][el.toLocaleLowerCase()] = value[el];
                    }
                }
            }
            else {
                this.visProp[key] = value;
            }
        }
    }
    /**
     * Resolves attribute shortcuts like <tt>color</tt> and expands them, e.g. <tt>strokeColor</tt> and <tt>fillColor</tt>.
     * Writes the expanded attributes back to the given <tt>attributes</tt>.
     * @param {Object} attributes object
     * @returns {Object} The given attributes object with shortcuts expanded.
     * @private
     */
    resolveShortcuts(attributes) {
        var key, i, j, subattr = ["traceattributes", "traceAttributes"];
        for (key in Options.shortcuts) {
            if (Options.shortcuts.hasOwnProperty(key)) {
                if (Type.exists(attributes[key])) {
                    for (i = 0; i < Options.shortcuts[key].length; i++) {
                        if (!Type.exists(attributes[Options.shortcuts[key][i]])) {
                            attributes[Options.shortcuts[key][i]] = attributes[key];
                        }
                    }
                }
                for (j = 0; j < subattr.length; j++) {
                    if (Type.isObject(attributes[subattr[j]])) {
                        attributes[subattr[j]] = this.resolveShortcuts(attributes[subattr[j]]);
                    }
                }
            }
        }
        return attributes;
    }
    /**
     * Sets a label and its text
     * If label doesn't exist, it creates one
     * @param {String} str
     */
    setLabel(str) {
        if (!this.hasLabel) {
            this.setAttribute({ withlabel: true });
        }
        this.setLabelText(str);
    }
    /**
     * Updates the element's label text, strips all html.
     * @param {String} str
     */
    setLabelText(str) {
        if (Type.exists(this.label)) {
            str = str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
            this.label.setText(str);
        }
        return this;
    }
    /**
     * Updates the element's label text and the element's attribute "name", strips all html.
     * @param {String} str
     */
    setName(str) {
        str = str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
        if (this.elType !== "slider") {
            this.setLabelText(str);
        }
        this.setAttribute({ name: str });
    }
    // /**
    //  * Deprecated alias for {@link JXG.GeometryElement#setAttribute}.
    //  * @deprecated Use {@link JXG.GeometryElement#setAttribute}.
    //  */
    // setProperty() {
    //     JXG.deprecated("setProperty()", "setAttribute()");
    //     this.setAttribute.apply(this, arguments);
    // }
    /**
     * Sets an arbitrary number of attributes. This method has one or more
     * parameters of the following types:
     * <ul>
     * <li> object: {key1:value1,key2:value2,...}
     * <li> string: 'key:value'
     * <li> array: ['key', value]
     * </ul>
     * @param {Object} attributes An object with attributes.
     * @returns {JXG.GeometryElement} A reference to the element.
     *
     * @function
     * @example
     * // Set attribute directly on creation of an element using the attributes object parameter
     * var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-1, 5, 5, 1]};
     * var p = board.create('point', [2, 2], {visible: false});
     *
     * // Now make this point visible and fixed:
     * p.setAttribute({
     *     fixed: true,
     *     visible: true
     * });
     */
    setAttribute(attr) {
        var i, j, le, key, value, arg, opacity, pair, oldvalue, attributes = {};
        // Normalize the user input
        for (i = 0; i < arguments.length; i++) {
            arg = arguments[i];
            if (Type.isString(arg)) {
                // pairRaw is string of the form 'key:value'
                pair = arg.split(":");
                attributes[Type.trim(pair[0])] = Type.trim(pair[1]);
            }
            else if (!Array.isArray(arg)) ;
            else {
                // pairRaw consists of array [key,value]
                attributes[arg[0]] = arg[1];
            }
        }
        // Handle shortcuts
        attributes = this.resolveShortcuts(attributes);
        for (i in attributes) {
            if (attributes.hasOwnProperty(i)) {
                key = i.replace(/\s+/g, "").toLowerCase();
                value = attributes[i];
                // This handles the subobjects, if the key:value pairs are contained in an object.
                // Example:
                // ticks.setAttribute({
                //      strokeColor: 'blue',
                //      label: {
                //          visible: false
                //      }
                // })
                // Now, only the supplied label attributes are overwritten.
                // Otherwise, the value of label would be {visible:false} only.
                if (Type.isObject(value) && Type.exists(this.visProp[key])) {
                    // this.visProp[key] = Type.merge(this.visProp[key], value);
                    if (!Type.isObject(this.visProp[key]) && value !== null && Type.isObject(value)) {
                        // Handle cases like key=firstarrow and
                        // firstarrow==false and value = { type:1 }.
                        // That is a primitive type is replaced by an object.
                        this.visProp[key] = {};
                    }
                    this.visProp[key] = Type.mergeAttrHelper(this.visProp[key], value);
                    // First, handle the special case
                    // ticks.setAttribute({label: {anchorX: "right", ..., visible: true});
                    if (this.type === OBJECT_TYPE.TICKS && Type.exists(this.labels)) {
                        le = this.labels.length;
                        for (j = 0; j < le; j++) {
                            this.labels[j].setAttribute(value);
                        }
                    }
                    else if (Type.exists(this[key])) {
                        // Attribute looks like: point1: {...}
                        // Handle this in the sub-element: this.point1.setAttribute({...})
                        if (Array.isArray(this[key])) {
                            for (j = 0; j < this[key].length; j++) {
                                this[key][j].setAttribute(value);
                            }
                        }
                        else {
                            this[key].setAttribute(value);
                        }
                    }
                    else {
                        // Cases like firstarrow: {...}
                        oldvalue = null;
                        this.triggerEventHandlers(["attribute:" + key], [oldvalue, value, this]);
                    }
                    continue;
                }
                oldvalue = this.visProp[key];
                switch (key) {
                    case "checked":
                        // checkbox Is not available on initial call.
                        if (Type.exists(this.rendNode)) {
                            this.rendNodeCheckbox.checked = !!value;
                        }
                        break;
                    case "disabled":
                        // button, checkbox, input. Is not available on initial call.
                        if (Type.exists(this.rendNode)) {
                            this.rendNode.disabled = !!value;
                        }
                        break;
                    case "face":
                        if (Type.isPoint(this)) {
                            this.visProp.face = value;
                            this.board.renderer.changePointStyle(this);
                        }
                        break;
                    case "generatelabelvalue":
                        if (this.type === OBJECT_TYPE.TICKS &&
                            Type.isFunction(value)) {
                            this.visProp.generatelabelvalue = value; // tbtb was this.generateLabelValue = value;
                        }
                        break;
                    case "gradient":
                        this.visProp.gradient = value;
                        this.board.renderer.setGradient(this);
                        break;
                    case "gradientsecondcolor":
                        value = Color.rgba2rgbo(value);
                        this.visProp.gradientsecondcolor = value[0];
                        this.visProp.gradientsecondopacity = value[1];
                        this.board.renderer.updateGradient(this);
                        break;
                    case "gradientsecondopacity":
                        this.visProp.gradientsecondopacity = value;
                        this.board.renderer.updateGradient(this);
                        break;
                    case "infoboxtext":
                        if (Type.isString(value)) {
                            this.infoboxText = value;
                        }
                        else {
                            this.infoboxText = false;
                        }
                        break;
                    case "labelcolor":
                        value = Color.rgba2rgbo(value);
                        opacity = value[1];
                        value = value[0];
                        if (opacity === 0) {
                            if (Type.exists(this.label) && this.hasLabel) {
                                this.label.hideElement();
                            }
                        }
                        if (Type.exists(this.label) && this.hasLabel) {
                            this.label.visProp.strokecolor = value;
                            this.board.renderer.setObjectStrokeColor(this.label, value, opacity);
                        }
                        if (this.elementClass === OBJECT_CLASS.TEXT) {
                            this.visProp.strokecolor = value;
                            this.visProp.strokeopacity = opacity;
                            this.board.renderer.setObjectStrokeColor(this, value, opacity);
                        }
                        break;
                    case "layer":
                        this.board.renderer.setLayer(this, this.eval(value));
                        this._set(key, value);
                        break;
                    // TODO: only a few HTMLElements support this
                    // case "maxlength":
                    //     // input. Is not available on initial call.
                    //     if (Type.exists(this.rendNode)) {
                    //         this.rendNode.maxlength = !!value;
                    //     }
                    //     break;
                    case "name":
                        oldvalue = this.name;
                        delete this.board.elementsByName[this.name];
                        this.name = value;
                        this.board.elementsByName[this.name] = this;
                        break;
                    case "needsregularupdate":
                        this.needsRegularUpdate = !(value === "false" || value === false);
                        this.board.renderer.setBuffering(this, this.needsRegularUpdate ? "auto" : "static");
                        break;
                    case "onpolygon":
                        if (this.type === OBJECT_TYPE.GLIDER) {
                            this.onPolygon = !!value;
                        }
                        break;
                    case "radius":
                        if (this.type === OBJECT_TYPE.ANGLE ||
                            this.type === OBJECT_TYPE.SECTOR) {
                            this.setRadius(value);
                        }
                        break;
                    case "rotate":
                        if ((this.elementClass === OBJECT_CLASS.TEXT &&
                            this.evalVisProp('display') === "internal") ||
                            this.type === OBJECT_TYPE.IMAGE) {
                            this.addRotation(value);
                        }
                        break;
                    case "tabindex":
                        if (Type.exists(this.rendNode)) {
                            this.rendNode.setAttribute("tabindex", value);
                            this._set(key, value);
                        }
                        break;
                    // case "ticksdistance":
                    //     if (this.type === OBJECT_TYPE.TICKS && Type.isNumber(value)) {
                    //         this.ticksFunction = this.makeTicksFunction(value);
                    //     }
                    //     break;
                    case "trace":
                        if (value === "false" || value === false) {
                            this.clearTrace();
                            this.visProp.trace = false;
                        }
                        else if (value === "pause") {
                            this.visProp.trace = false;
                        }
                        else {
                            this.visProp.trace = true;
                        }
                        break;
                    case "visible":
                        if (value === "false") {
                            this.visProp.visible = false;
                        }
                        else if (value === "true") {
                            this.visProp.visible = true;
                        }
                        else {
                            this.visProp.visible = value;
                        }
                        this.setDisplayRendNode(this.evalVisProp('visible'));
                        // if (
                        //     this.evalVisProp('visible') &&
                        //     Type.exists(this.updateSize)
                        // ) {
                        // TODO: this is a Text function
                        // if (this.elementClass === OBJECT_CLASS.TEXT) {
                        //     this.updateSize();
                        // }
                        // }
                        break;
                    case "withlabel":
                        this.visProp.withlabel = value;
                        if (!this.evalVisProp('withlabel')) {
                            if (this.label && this.hasLabel) {
                                //this.label.hideElement();
                                this.label.setAttribute({ visible: false });
                            }
                        }
                        else {
                            if (!this.label) {
                                this.createLabel();
                            }
                            //this.label.showElement();
                            this.label.setAttribute({ visible: "inherit" });
                            //this.label.setDisplayRendNode(this.evalVisProp('visible'));
                        }
                        this.hasLabel = value;
                        break;
                    case "straightfirst":
                    case "straightlast":
                        this._set(key, value);
                        for (j in this.childElements) {
                            if (this.childElements.hasOwnProperty(j) && this.childElements[j].elType === 'glider') {
                                this.childElements[j].fullUpdate();
                            }
                        }
                        break;
                    default:
                        if (Type.exists(this.visProp[key]) &&
                            (!Options.Validator[key] || // No validator for this key => OK
                                (Options.Validator[key] && Options.Validator[key](value)) || // Value passes the validator => OK
                                (Options.Validator[key] && // Value is function, function value passes the validator => OK
                                    Type.isFunction(value) && Options.Validator[key](value(this))))) {
                            value = (value.toLowerCase && value.toLowerCase() === "false")
                                ? false
                                : value;
                            this._set(key, value);
                        }
                        else {
                            if (!(key in Options.shortcuts)) {
                                JXG.warn("attribute '" + key + "' does not accept type '" + (typeof value) + "' of value " + value + ".");
                            }
                        }
                        break;
                }
                this.triggerEventHandlers(["attribute:" + key], [oldvalue, value, this]);
            }
        }
        this.triggerEventHandlers(["attribute"], [attributes, this]);
        if (!this.evalVisProp('needsregularupdate')) {
            this.board.fullUpdate();
        }
        else {
            this.board.update();
        }
        // TODO: this is a Text function
        // if (this.elementClass === OBJECT_CLASS.TEXT) {
        //     this.updateSize();
        // }
        return this;
    }
    // /**
    //  * Deprecated alias for {@link JXG.GeometryElement#getAttribute}.
    //  * @deprecated Use {@link JXG.GeometryElement#getAttribute}.
    //  */
    // getProperty() {
    //     JXG.deprecated("getProperty()", "getAttribute()");
    //     this.getProperty.apply(this, arguments);
    // }
    /**
     * Get the value of the property <tt>key</tt>.
     * @param {String} key The name of the property you are looking for
     * @returns The value of the property
     */
    getAttribute(key) {
        var result;
        key = key.toLowerCase();
        switch (key) {
            case "needsregularupdate":
                result = this.needsRegularUpdate;
                break;
            case "labelcolor":
                result = this.label.visProp.strokecolor;
                break;
            case "infoboxtext":
                result = this.infoboxText;
                break;
            case "withlabel":
                result = this.hasLabel;
                break;
            default:
                result = this.visProp[key];
                break;
        }
        return result;
    }
    /**
     * Get value of an attribute. If the value that attribute is a function, call the function and return its value.
     * In that case, the function is called with the GeometryElement as (only) parameter. For label elements (i.e.
     * if the attribute "islabel" is true), the anchor element is supplied. The label element can be accessed as
     * sub-object "label".
     * If the attribute does not exist, undefined will be returned.
     *
     * @param {String} key Attribute key
     * @returns {String|Number|Boolean} value of attribute "key" (evaluated in case of a function) or undefined
     *
     * @see GeometryElement#eval
     * @see JXG#evaluate
     */
    evalVisProp(key) {
        var val, arr, i, le, e, o, found;
        key = key.toLowerCase();
        if (key.indexOf('.') === -1) {
            // e.g. 'visible'
            val = this.visProp[key];
        }
        else {
            // e.g. label.visible
            arr = key.split('.');
            le = arr.length;
            val = this.visProp;
            for (i = 0; i < le; i++) {
                if (Type.exists(val)) {
                    val = val[arr[i]];
                }
            }
        }
        if (Type.isFunction(val)) {
            // For labels supply the anchor element as parameter.
            if (this.visProp.islabel === true && Type.exists(this.visProp.anchor)) {
                // 3D: supply the 3D element
                if (this.visProp.anchor.visProp.element3d !== null) {
                    return val(this.visProp.anchor.visProp.element3d);
                }
                // 2D: supply the 2D element
                return val(this.visProp.anchor);
            }
            // For 2D elements representing 3D elements, return the 3D element.
            if (Type.exists(this.visProp.element3d)) {
                return val(this.visProp.element3d);
            }
            // In all other cases, return the element itself
            return val(this);
        }
        // val is not of type function
        if (val === 'inherit') {
            for (e in this.descendants) {
                if (this.descendants.hasOwnProperty(e)) {
                    o = this.descendants[e];
                    // Check if this is in inherits of one of its descendant
                    found = false;
                    le = o.inherits.length;
                    for (i = 0; i < le; i++) {
                        if (this.id === o.inherits[i].id) {
                            found = true;
                            break;
                        }
                    }
                    if (found) {
                        val = o.evalVisProp(key);
                        break;
                    }
                }
            }
        }
        return val;
    }
    /**
     * Get value of a parameter. If the parameter is a function, call the function and return its value.
     * In that case, the function is called with the GeometryElement as (only) parameter. For label elements (i.e.
     * if the attribute "islabel" is true), the anchor element is supplied. The label of an element can be accessed as
     * sub-object "label" then.
     *
     * @param {String|Number|Function|Object} val If not a function, it will be returned as is. If function it will be evaluated, where the GeometryElement is
     * supplied as the (only) parameter of that function.
     * @returns {String|Number|Object}
     *
     * @see GeometryElement#evalVisProp
     * @see JXG#evaluate
     */
    eval(val) {
        if (Type.isFunction(val)) {
            // For labels supply the anchor element as parameter.
            if (this.visProp.islabel === true && Type.exists(this.visProp.anchor)) {
                // 3D: supply the 3D element
                if (this.visProp.anchor.visProp.element3d !== null) {
                    return val(this.visProp.anchor.visProp.element3d);
                }
                // 2D: supply the 2D element
                return val(this.visProp.anchor);
            }
            // For 2D elements representing 3D elements, return the 3D element.
            if (this.visProp.element3d !== null) {
                return val(this.visProp.element3d);
            }
            // In all other cases, return the element itself
            return val(this);
        }
        // val is not of type function
        return val;
    }
    /**
     * Set the dash style of an object. See {@link JXG.GeometryElement#dash}
     * for a list of available dash styles.
     * You should use {@link JXG.GeometryElement#setAttribute} instead of this method.
     *
     * @param {number} dash Indicates the new dash style
     * @private
     */
    setDash(dash) {
        this.setAttribute({ dash: dash });
        return this;
    }
    /**
     * Notify all child elements for updates.
     * @private
     */
    prepareUpdate() {
        this.needsUpdate = true;
        return this;
    }
    /**
     * Removes the element from the construction.  This only removes the SVG or VML node of the element and its label (if available) from
     * the renderer, to remove the element completely you should use {@link JXG.Board#removeObject}.
     */
    remove() {
        // this.board.renderer.remove(this.board.renderer.getElementById(this.id));
        this.board.renderer.remove(this.rendNode);
        if (this.hasLabel) {
            this.board.renderer.remove(this.board.renderer.getElementById(this.label.id));
        }
        return this;
    }
    /**
     * Returns the coords object where a text that is bound to the element shall be drawn.
     * Differs in some cases from the values that getLabelAnchor returns.
     * @returns {JXG.Coords} JXG.Coords Place where the text shall be drawn.
     * @see JXG.GeometryElement#getLabelAnchor
     */
    getTextAnchor() {
        return new Coords$1(COORDS_BY.USER, [0, 0], this.board);
    }
    /**
     * Returns the coords object where the label of the element shall be drawn.
     * Differs in some cases from the values that getTextAnchor returns.
     * @returns {JXG.Coords} JXG.Coords Place where the text shall be drawn.
     * @see JXG.GeometryElement#getTextAnchor
     */
    getLabelAnchor() {
        return new Coords$1(COORDS_BY.USER, [0, 0], this.board);
    }
    /**
     * Determines whether the element has arrows at start or end of the arc.
     * If it is set to be a "typical" vector, ie lastArrow == true,
     * then the element.type is set to VECTOR.
     * @param {Boolean} firstArrow True if there is an arrow at the start of the arc, false otherwise.
     * @param {Boolean} lastArrow True if there is an arrow at the end of the arc, false otherwise.
     */
    setArrow(firstArrow, lastArrow) {
        this.visProp.firstarrow = firstArrow;
        this.visProp.lastarrow = lastArrow;
        if (lastArrow) {
            this.type = OBJECT_TYPE.VECTOR;
            this.elType = "arrow";
        }
        this.prepareUpdate().update(true).updateVisibility().updateRenderer();
        return this;
    }
    /**
     * Creates a gradient nodes in the renderer.
     * @see JXG.SVGRenderer#setGradient
     * @private
     */
    createGradient() {
        var ev_g = this.evalVisProp('gradient');
        if (ev_g === "linear" || ev_g === "radial") {
            this.board.renderer.setGradient(this);
        }
    }
    /**
     * Creates a label element for this geometry element.
     * @see JXG.GeometryElement#addLabelToElement
     */
    createLabel() {
        var attr, that = this;
        // this is a dirty hack to resolve the text-dependency. If there is no text element available,
        // just don't create a label. This method is usually not called by a user, so we won't throw
        // an exception here and simply output a warning via JXG.debug.
        // if (JXG_elements['text']) { //tbtb
        attr = Type.deepCopy(Options.label, {});
        attr.id = this.id + "Label";
        attr.isLabel = true;
        attr.anchor = this;
        attr.priv = this.visProp.priv;
        if (this.visProp.withlabel) {
            this.label = new Text(this.board, [
                0,
                0,
            ], attr, () => {
                if (Type.isFunction(that.name)) {
                    return that.name(that);
                }
                return that.name;
            });
            this.label.needsUpdate = true;
            this.label.dump = false;
            this.label.fullUpdate();
            this.hasLabel = true;
        }
        // } else {
        //     JXG.debug(
        //         "JSXGraph: Can't create label: text element is not available. Make sure you include base/text"
        //     );
        // }
        return this;
    }
    /**
     * Highlights the element.
     * @private
     * @param {Boolean} [force=false] Force the highlighting
     * @returns {JXG.Board}
     */
    highlight(force) {
        force = Type.def(force, false);
        // I know, we have the JXG.Board.highlightedObjects AND JXG.GeometryElement.highlighted and YES we need both.
        // Board.highlightedObjects is for the internal highlighting and GeometryElement.highlighted is for user highlighting
        // initiated by the user, e.g. through custom DOM events. We can't just pick one because this would break user
        // defined highlighting in many ways:
        //  * if overriding the highlight() methods the user had to handle the highlightedObjects stuff, otherwise he'd break
        //    everything (e.g. the pie chart example https://jsxgraph.org/wiki/index.php/Pie_chart (not exactly
        //    user defined but for this type of chart the highlight method was overridden and not adjusted to the changes in here)
        //    where it just kept highlighting until the radius of the pie was far beyond infinity...
        //  * user defined highlighting would get pointless, everytime the user highlights something using .highlight(), it would get
        //    dehighlighted immediately, because highlight puts the element into highlightedObjects and from there it gets dehighlighted
        //    through dehighlightAll.
        // highlight only if not highlighted
        if (this.evalVisProp('highlight') && (!this.highlighted || force)) {
            this.highlighted = true;
            this.board.highlightedObjects[this.id] = this;
            this.board.renderer.highlight(this);
        }
        return this;
    }
    /**
     * Uses the "normal" properties of the element.
     * @returns {JXG.Board}
     */
    noHighlight() {
        // see comment in JXG.GeometryElement.highlight()
        // dehighlight only if not highlighted
        if (this.highlighted) {
            this.highlighted = false;
            delete this.board.highlightedObjects[this.id];
            this.board.renderer.noHighlight(this);
        }
        return this;
    }
    /**
     * Removes all objects generated by the trace function.
     */
    clearTrace() {
        var obj;
        for (obj in this.traces) {
            if (this.traces.hasOwnProperty(obj)) {
                this.board.renderer.remove(this.traces[obj]);
            }
        }
        this.numTraces = 0;
        return this;
    }
    /**
     * Copy the element to background. This is used for tracing elements.
     * @returns {JXG.GeometryElement} A reference to the element
     */
    cloneToBackground() {
        return this;
    }
    /**
     * Dimensions of the smallest rectangle enclosing the element.
     * @returns {Array} The coordinates of the enclosing rectangle in a format
     * like the bounding box in {@link JXG.Board#setBoundingBox}.
     *
     * @returns {Array} similar to {@link JXG.Board#setBoundingBox}.
     */
    bounds() {
        return [0, 0, 0, 0];
    }
    /**
     * Normalize the element's standard form.
     * @private
     */
    normalize() {
        this.stdform = JSXMath.normalize(this.stdform);
        return this;
    }
    /**
     * EXPERIMENTAL. Generate JSON object code of visProp and other properties.
     * @type String
     * @private
     * @ignore
     * @deprecated
     * @returns JSON string containing element's properties.
     */
    toJSON() {
        var vis, key, json = ['{"name":', this.name];
        json.push(", " + '"id":' + this.id);
        vis = [];
        for (key in this.visProp) {
            if (this.visProp.hasOwnProperty(key)) {
                if (Type.exists(this.visProp[key])) {
                    vis.push('"' + key + '":' + this.visProp[key]);
                }
            }
        }
        json.push(', "visProp":{' + vis.toString() + "}");
        json.push("}");
        return json.join("");
    }
    /**
     * Rotate texts or images by a given degree.
     * @param {number} angle The degree of the rotation (90 means vertical text).
     * @see JXG.GeometryElement#rotate
     */
    addRotation(angle) {
        var tOffInv, tOff, tS, tSInv, tRot, that = this;
        if ((this.elementClass === OBJECT_CLASS.TEXT ||
            this.type === OBJECT_TYPE.IMAGE) &&
            angle !== 0) {
            tOffInv = this.board.create("transform", [
                function () {
                    return -that.X();
                },
                function () {
                    return -that.Y();
                }
            ], { type: "translate" });
            tOff = this.board.create("transform", [
                function () {
                    return that.X();
                },
                function () {
                    return that.Y();
                }
            ], { type: "translate" });
            tS = this.board.create("transform", [
                function () {
                    return that.board.unitX / that.board.unitY;
                },
                function () {
                    return 1;
                }
            ], { type: "scale" });
            tSInv = this.board.create("transform", [
                function () {
                    return that.board.unitY / that.board.unitX;
                },
                function () {
                    return 1;
                }
            ], { type: "scale" });
            tRot = this.board.create("transform", [
                function () {
                    return (that.eval(angle) * Math.PI) / 180;
                }
                //TODO something missing here....
            ], { type: "rotate" });
            tOffInv.bindTo(this);
            tS.bindTo(this);
            tRot.bindTo(this);
            tSInv.bindTo(this);
            tOff.bindTo(this);
        }
        return this;
    }
    /**
     * Set the highlightStrokeColor of an element
     * @ignore
     * @name JXG.GeometryElement#highlightStrokeColorMethod
     * @param {String} sColor String which determines the stroke color of an object when its highlighted.
     * @see JXG.GeometryElement#highlightStrokeColor
     * @deprecated Use {@link JXG.GeometryElement#setAttribute}
     */
    highlightStrokeColor(sColor) {
        JXG.deprecated("highlightStrokeColor()", "setAttribute()");
        this.setAttribute({ highlightStrokeColor: sColor });
        return this;
    }
    /**
     * Set the strokeColor of an element
     * @ignore
     * @name JXG.GeometryElement#strokeColorMethod
     * @param {String} sColor String which determines the stroke color of an object.
     * @see JXG.GeometryElement#strokeColor
     * @deprecated Use {@link JXG.GeometryElement#setAttribute}
     */
    strokeColor(sColor) {
        JXG.deprecated("strokeColor()", "setAttribute()");
        this.setAttribute({ strokeColor: sColor });
        return this;
    }
    /**
     * Set the strokeWidth of an element
     * @ignore
     * @name JXG.GeometryElement#strokeWidthMethod
     * @param {Number} width Integer which determines the stroke width of an outline.
     * @see JXG.GeometryElement#strokeWidth
     * @deprecated Use {@link JXG.GeometryElement#setAttribute}
     */
    strokeWidth(width) {
        JXG.deprecated("strokeWidth()", "setAttribute()");
        this.setAttribute({ strokeWidth: width });
        return this;
    }
    /**
     * Set the fillColor of an element
     * @ignore
     * @name JXG.GeometryElement#fillColorMethod
     * @param {String} fColor String which determines the fill color of an object.
     * @see JXG.GeometryElement#fillColor
     * @deprecated Use {@link JXG.GeometryElement#setAttribute}
     */
    fillColor(fColor) {
        JXG.deprecated("fillColor()", "setAttribute()");
        this.setAttribute({ fillColor: fColor });
        return this;
    }
    /**
     * Set the highlightFillColor of an element
     * @ignore
     * @name JXG.GeometryElement#highlightFillColorMethod
     * @param {String} fColor String which determines the fill color of an object when its highlighted.
     * @see JXG.GeometryElement#highlightFillColor
     * @deprecated Use {@link JXG.GeometryElement#setAttribute}
     */
    highlightFillColor(fColor) {
        JXG.deprecated("highlightFillColor()", "setAttribute()");
        this.setAttribute({ highlightFillColor: fColor });
        return this;
    }
    /**
     * Set the labelColor of an element
     * @ignore
     * @param {String} lColor String which determines the text color of an object's label.
     * @see JXG.GeometryElement#labelColor
     * @deprecated Use {@link JXG.GeometryElement#setAttribute}
     */
    labelColor(lColor) {
        JXG.deprecated("labelColor()", "setAttribute()");
        this.setAttribute({ labelColor: lColor });
        return this;
    }
    /**
     * Set the dash type of an element
     * @ignore
     * @name JXG.GeometryElement#dashMethod
     * @param {Number} d Integer which determines the way of dashing an element's outline.
     * @see JXG.GeometryElement#dash
     * @deprecated Use {@link JXG.GeometryElement#setAttribute}
     */
    dash(d) {
        JXG.deprecated("dash()", "setAttribute()");
        this.setAttribute({ dash: d });
        return this;
    }
    /**
     * Set the visibility of an element
     * @ignore
     * @name JXG.GeometryElement#visibleMethod
     * @param {Boolean} v Boolean which determines whether the element is drawn.
     * @see JXG.GeometryElement#visible
     * @deprecated Use {@link JXG.GeometryElement#setAttribute}
     */
    visible(v) {
        JXG.deprecated("visible()", "setAttribute()");
        this.setAttribute({ visible: v });
        return this;
    }
    /**
     * Set the shadow of an element
     * @ignore
     * @name JXG.GeometryElement#shadowMethod
     * @param {Boolean} s Boolean which determines whether the element has a shadow or not.
     * @see JXG.GeometryElement#shadow
     * @deprecated Use {@link JXG.GeometryElement#setAttribute}
     */
    shadow(s) {
        JXG.deprecated("shadow()", "setAttribute()");
        this.setAttribute({ shadow: s });
        return this;
    }
    /**
     * The type of the element as used in {@link JXG.Board#create}.
     * @returns {String}
     */
    getType() {
        return this.elType;
    }
    /**
     * List of the element ids resp. values used as parents in {@link JXG.Board#create}.
     * @returns {Array}
     */
    getParents() {
        return Array.isArray(this.parents) ? this.parents : [];
    }
    /**
     * @ignore
     * Snaps the element to the grid. Only works for points, lines and circles. Points will snap to the grid
     * as defined in their properties {@link JXG.Point#snapSizeX} and {@link JXG.Point#snapSizeY}. Lines and circles
     * will snap their parent points to the grid, if they have {@link JXG.Point#snapToGrid} set to true.
     * @private
     * @returns {JXG.GeometryElement} Reference to the element.
     */
    snapToGrid(force) {
        return this;
    }
    /**
     * Snaps the element to points. Only works for points. Points will snap to the next point
     * as defined in their properties {@link JXG.Point#attractorDistance} and {@link JXG.Point#attractorUnit}.
     * Lines and circles
     * will snap their parent points to points.
     * @private
     * @returns {JXG.GeometryElement} Reference to the element.
     */
    snapToPoints(force) {
        return this;
    }
    /**
     * Retrieve a copy of the current visProp.
     * @returns {Object}
     */
    getAttributes() {
        var attributes = Type.deepCopy(this.visProp), 
        /*
        cleanThis = ['attractors', 'snatchdistance', 'traceattributes', 'frozen',
            'shadow', 'gradientangle', 'gradientsecondopacity', 'gradientpositionx', 'gradientpositiony',
            'needsregularupdate', 'zoom', 'layer', 'offset'],
        */
        cleanThis = [], i, len = cleanThis.length;
        attributes.id = this.id;
        attributes.name = this.name;
        for (i = 0; i < len; i++) {
            delete attributes[cleanThis[i]];
        }
        return attributes;
    }
    /**
     * Checks whether (x,y) is near the element.
     * @param {Number} x Coordinate in x direction, screen coordinates.
     * @param {Number} y Coordinate in y direction, screen coordinates.
     * @returns {Boolean} True if (x,y) is near the element, False otherwise.
     */
    hasPoint(x, y) {
        return false;
    }
    /**
     * Adds ticks to this line or curve. Ticks can be added to a curve or any kind of line: line, arrow, and axis.
     * @param {JXG.Ticks} ticks Reference to a ticks object which is describing the ticks (color, distance, how many, etc.).
     * @returns {String} Id of the ticks object.
     */
    addTicks(ticks) {
        if (ticks.id === "" || !Type.exists(ticks.id)) {
            ticks.id = this.id + "_ticks_" + (this.ticks.length + 1);
        }
        this.board.renderer.drawTicks(ticks);
        this.ticks.push(ticks);
        return ticks.id;
    }
    /**
     * Removes all ticks from a line or curve.
     */
    removeAllTicks() {
        var t;
        if (Type.exists(this.ticks)) {
            for (t = this.ticks.length - 1; t >= 0; t--) {
                this.removeTicks(this.ticks[t]);
            }
            this.ticks = [];
            this.board.update();
        }
    }
    /**
     * Removes ticks identified by parameter named tick from this line or curve.
     * @param {JXG.Ticks} tick Reference to tick object to remove.
     */
    removeTicks(tick) {
        var t, j;
        if (Type.exists(this.defaultTicks) && this.defaultTicks === tick) {
            this.defaultTicks = null;
        }
        if (Type.exists(this.ticks)) {
            for (t = this.ticks.length - 1; t >= 0; t--) {
                if (this.ticks[t] === tick) {
                    this.board.removeObject(this.ticks[t]);
                    if (this.ticks[t].ticks) {
                        for (j = 0; j < this.ticks[t].ticks.length; j++) {
                            if (Type.exists(this.ticks[t].labels[j])) {
                                this.board.removeObject(this.ticks[t].labels[j]);
                            }
                        }
                    }
                    delete this.ticks[t];
                    break;
                }
            }
        }
    }
    /**
     * Determine values of snapSizeX and snapSizeY. If the attributes
     * snapSizex and snapSizeY are greater than zero, these values are taken.
     * Otherwise, determine the distance between major ticks of the
     * default axes.
     * @returns {Array} containing the snap sizes for x and y direction.
     * @private
     */
    getSnapSizes() {
        var sX, sY, ticks;
        sX = this.evalVisProp('snapsizex');
        sY = this.evalVisProp('snapsizey');
        if (sX <= 0 && this.board.defaultAxes && this.board.defaultAxes.x.defaultTicks) {
            ticks = this.board.defaultAxes.x.defaultTicks;
            sX = ticks.ticksDelta * (ticks.evalVisProp('minorticks') + 1);
        }
        if (sY <= 0 && this.board.defaultAxes && this.board.defaultAxes.y.defaultTicks) {
            ticks = this.board.defaultAxes.y.defaultTicks;
            sY = ticks.ticksDelta * (ticks.evalVisProp('minorticks') + 1);
        }
        return [sX, sY];
    }
    /**
     * Move an element to its nearest grid point.
     * The function uses the coords object of the element as
     * its actual position. If there is no coords object or if the object is fixed, nothing is done.
     * @param {Boolean} force force snapping independent from what the snaptogrid attribute says
     * @param {Boolean} fromParent True if the drag comes from a child element. This is the case if a line
     *    through two points is dragged. In this case we do not try to force the points to stay inside of
     *    the visible board, but the distance between the two points stays constant.
     * @returns {JXG.GeometryElement} Reference to this element
     */
    handleSnapToGrid(force = false, fromParent = false) {
        var x, y, rx, ry, rcoords, mi, ma, boardBB, res, sX, sY, needsSnapToGrid = false, attractToGrid = this.evalVisProp('attracttogrid'), ev_au = this.evalVisProp('attractorunit'), ev_ad = this.evalVisProp('attractordistance');
        if (!Type.exists(this.coords) || this.evalVisProp('fixed')) {
            return this;
        }
        needsSnapToGrid =
            this.evalVisProp('snaptogrid') || attractToGrid || force === true;
        if (needsSnapToGrid) {
            x = this.coords.usrCoords[1];
            y = this.coords.usrCoords[2];
            res = this.getSnapSizes();
            sX = res[0];
            sY = res[1];
            // If no valid snap sizes are available, don't change the coords.
            if (sX > 0 && sY > 0) {
                boardBB = this.board.getBoundingBox();
                rx = Math.round(x / sX) * sX;
                ry = Math.round(y / sY) * sY;
                rcoords = new Coords$1(COORDS_BY.USER, [rx, ry], this.board);
                if (!attractToGrid ||
                    rcoords.distance(ev_au === "screen" ? COORDS_BY.SCREEN : COORDS_BY.USER, this.coords) < ev_ad) {
                    x = rx;
                    y = ry;
                    // Checking whether x and y are still within boundingBox.
                    // If not, adjust them to remain within the board.
                    // Otherwise a point may become invisible.
                    if (!fromParent) {
                        mi = Math.min(boardBB[0], boardBB[2]);
                        ma = Math.max(boardBB[0], boardBB[2]);
                        if (x < mi && x > mi - sX) {
                            x += sX;
                        }
                        else if (x > ma && x < ma + sX) {
                            x -= sX;
                        }
                        mi = Math.min(boardBB[1], boardBB[3]);
                        ma = Math.max(boardBB[1], boardBB[3]);
                        if (y < mi && y > mi - sY) {
                            y += sY;
                        }
                        else if (y > ma && y < ma + sY) {
                            y -= sY;
                        }
                    }
                    this.coords.setCoordinates(COORDS_BY.USER, [x, y]);
                }
            }
        }
        return this;
    }
    getBoundingBox() {
        // TODO: this has stuff that needs to get moved up the tree
        // var i, le, v,
        //     x, y, r,
        let bb = [Infinity, Infinity, -Infinity, -Infinity];
        // if (this.type === OBJECT_TYPE.POLYGON) {
        //     le = this.vertices.length - 1;
        //     if (le <= 0) {
        //         return bb;
        //     }
        //     for (i = 0; i < le; i++) {
        //         v = this.vertices[i].X();
        //         bb[0] = v < bb[0] ? v : bb[0];
        //         bb[2] = v > bb[2] ? v : bb[2];
        //         v = this.vertices[i].Y();
        //         bb[1] = v < bb[1] ? v : bb[1];
        //         bb[3] = v > bb[3] ? v : bb[3];
        //     }
        // } else if (this.elementClass === OBJECT_CLASS.CIRCLE) {
        //     x = this.center.X();
        //     y = this.center.Y();
        //     bb = [x - this.radius, y + this.radius, x + this.radius, y - this.radius];
        // } else if (this.elementClass === OBJECT_CLASS.CURVE) {
        //     le = this.points.length;
        //     if (le === 0) {
        //         return bb;
        //     }
        //     for (i = 0; i < le; i++) {
        //         v = this.points[i].usrCoords[1];
        //         bb[0] = v < bb[0] ? v : bb[0];
        //         bb[2] = v > bb[2] ? v : bb[2];
        //         v = this.points[i].usrCoords[2];
        //         bb[1] = v < bb[1] ? v : bb[1];
        //         bb[3] = v > bb[3] ? v : bb[3];
        //     }
        // } else if (this.elementClass === OBJECT_CLASS.POINT) {
        //     x = this.X();
        //     y = this.Y();
        //     r = this.evalVisProp('size');
        //     bb = [x - r / this.board.unitX, y - r / this.board.unitY, x + r / this.board.unitX, y + r / this.board.unitY];
        // } else if (this.elementClass === OBJECT_CLASS.LINE) {
        //     v = this.point1.coords.usrCoords[1];
        //     bb[0] = v < bb[0] ? v : bb[0];
        //     bb[2] = v > bb[2] ? v : bb[2];
        //     v = this.point1.coords.usrCoords[2];
        //     bb[1] = v < bb[1] ? v : bb[1];
        //     bb[3] = v > bb[3] ? v : bb[3];
        //     v = this.point2.coords.usrCoords[1];
        //     bb[0] = v < bb[0] ? v : bb[0];
        //     bb[2] = v > bb[2] ? v : bb[2];
        //     v = this.point2.coords.usrCoords[2];
        //     bb[1] = v < bb[1] ? v : bb[1];
        //     bb[3] = v > bb[3] ? v : bb[3];
        // }
        return bb;
    }
    // /**
    //  * Alias of {@link JXG.EventEmitter.on}.
    //  *
    //  * @name addEvent
    //  * @memberof JXG.GeometryElement
    //  * @function
    //  */
    // addEvent(){
    //     return JXG.shortcut(JXG.GeometryElement.prototype, 'on'),
    // }
    // /**
    //  * Alias of {@link JXG.EventEmitter.off}.
    //  *
    //  * @name removeEvent
    //  * @memberof JXG.GeometryElement
    //  * @function
    //  */
    // removeEvent(){
    //     return JXG.shortcut(JXG.GeometryElement.prototype, 'off'),
    // }
    /**
     * Format a number according to the locale set in the attribute "intl".
     * If in the options of the intl-attribute "maximumFractionDigits" is not set,
     * the optional parameter digits is used instead.
     * See <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat</a>
     * for more  information about internationalization.
     *
     * @param {Number} value Number to be formatted
     * @param {Number} [digits=undefined] Optional number of digits
     * @returns {String|Number} string containing the formatted number according to the locale
     * or the number itself of the formatting is not possible.
     */
    formatNumberLocale(value, digits) {
        var loc, opt, key, optCalc = {};
        // These options are case sensitive:
        let translate = {
            maximumfractiondigits: 'maximumFractionDigits',
            minimumfractiondigits: 'minimumFractionDigits',
            compactdisplay: 'compactDisplay',
            currencydisplay: 'currencyDisplay',
            currencysign: 'currencySign',
            localematcher: 'localeMatcher',
            numberingsystem: 'numberingSystem',
            signdisplay: 'signDisplay',
            unitdisplay: 'unitDisplay',
            usegrouping: 'useGrouping',
            roundingmode: 'roundingMode',
            roundingpriority: 'roundingPriority',
            roundingincrement: 'roundingIncrement',
            trailingzerodisplay: 'trailingZeroDisplay',
            minimumintegerdigits: 'minimumIntegerDigits',
            minimumsignificantdigits: 'minimumSignificantDigits',
            maximumsignificantdigits: 'maximumSignificantDigits'
        };
        if (Type.exists(Intl) &&
            this.useLocale()) {
            loc = this.evalVisProp('intl.locale') ||
                this.eval(this.board.attr.intl.locale);
            opt = this.evalVisProp('intl.options') || {};
            // Transfer back to camel case if necessary and evaluate
            for (key in opt) {
                if (opt.hasOwnProperty(key)) {
                    if (translate.hasOwnProperty(key)) {
                        optCalc[translate[key]] = this.eval(opt[key]);
                    }
                    else {
                        optCalc[key] = this.eval(opt[key]);
                    }
                }
            }
            // If maximumfractiondigits is not set,
            // the value of the attribute "digits" is taken instead.
            key = 'maximumfractiondigits';
            if (!Type.exists(opt[key])) {
                optCalc[translate[key]] = digits;
                // key = 'minimumfractiondigits';
                // if (!this.eval(opt[key]) || this.eval(opt[key]) > digits) {
                //     optCalc[translate[key]] = digits;
                // }
            }
            return Intl.NumberFormat(loc, optCalc).format(value);
        }
        return value;
    }
    /**
     * Checks if locale is enabled in the attribute. This may be in the attributes of the board,
     * or in the attributes of the text. The latter has higher priority. The board attribute is taken if
     * attribute "intl.enabled" of the text element is set to 'inherit'.
     *
     * @returns {Boolean} if locale can be used for number formatting.
     */
    useLocale() {
        var val;
        // Check if element supports intl
        if (!Type.exists(this.visProp.intl) ||
            !Type.exists(this.visProp.intl.enabled)) {
            return false;
        }
        // Check if intl is supported explicitly enabled for this element
        val = this.evalVisProp('intl.enabled');
        if (val === true) {
            return true;
        }
        // Check intl attribute of the board
        if (val === 'inherit') {
            if (this.eval(this.board.attr.intl.enabled) === true) {
                return true;
            }
        }
        return false;
    }
    // /* **************************
    //  *     EVENT DEFINITION
    //  * for documentation purposes
    //  * ************************** */
    // //region Event handler documentation
    // /**
    //  * @event
    //  * @description This event is fired whenever the user is hovering over an element.
    //  * @name JXG.GeometryElement#over
    //  * @param {Event} e The browser's event object.
    //  */
    // __evt__over(e) { }
    // /**
    //  * @event
    //  * @description This event is fired whenever the user puts the mouse over an element.
    //  * @name JXG.GeometryElement#mouseover
    //  * @param {Event} e The browser's event object.
    //  */
    // __evt__mouseover(e) { }
    // /**
    //  * @event
    //  * @description This event is fired whenever the user is leaving an element.
    //  * @name JXG.GeometryElement#out
    //  * @param {Event} e The browser's event object.
    //  */
    // __evt__out(e) { }
    // /**
    //  * @event
    //  * @description This event is fired whenever the user puts the mouse away from an element.
    //  * @name JXG.GeometryElement#mouseout
    //  * @param {Event} e The browser's event object.
    //  */
    // __evt__mouseout(e) { }
    // /**
    //  * @event
    //  * @description This event is fired whenever the user is moving over an element.
    //  * @name JXG.GeometryElement#move
    //  * @param {Event} e The browser's event object.
    //  */
    // __evt__move(e) { }
    // /**
    //  * @event
    //  * @description This event is fired whenever the user is moving the mouse over an element.
    //  * @name JXG.GeometryElement#mousemove
    //  * @param {Event} e The browser's event object.
    //  */
    // __evt__mousemove(e) { }
    // /**
    //  * @event
    //  * @description This event is fired whenever the user drags an element.
    //  * @name JXG.GeometryElement#drag
    //  * @param {Event} e The browser's event object.
    //  */
    // __evt__drag(e) { }
    // /**
    //  * @event
    //  * @description This event is fired whenever the user drags the element with a mouse.
    //  * @name JXG.GeometryElement#mousedrag
    //  * @param {Event} e The browser's event object.
    //  */
    // __evt__mousedrag(e) { }
    // /**
    //  * @event
    //  * @description This event is fired whenever the user drags the element with a pen.
    //  * @name JXG.GeometryElement#pendrag
    //  * @param {Event} e The browser's event object.
    //  */
    // __evt__pendrag(e) { }
    // /**
    //  * @event
    //  * @description This event is fired whenever the user drags the element on a touch device.
    //  * @name JXG.GeometryElement#touchdrag
    //  * @param {Event} e The browser's event object.
    //  */
    // __evt__touchdrag(e) { }
    // /**
    //  * @event
    //  * @description This event is fired whenever the user drags the element by pressing arrow keys
    //  * on the keyboard.
    //  * @name JXG.GeometryElement#keydrag
    //  * @param {Event} e The browser's event object.
    //  */
    // __evt__keydrag(e) { }
    // /**
    //  * @event
    //  * @description Whenever the user starts to touch or click an element.
    //  * @name JXG.GeometryElement#down
    //  * @param {Event} e The browser's event object.
    //  */
    // __evt__down(e) { }
    // /**
    //  * @event
    //  * @description Whenever the user starts to click an element.
    //  * @name JXG.GeometryElement#mousedown
    //  * @param {Event} e The browser's event object.
    //  */
    // __evt__mousedown(e) { }
    // /**
    //  * @event
    //  * @description Whenever the user taps an element with the pen.
    //  * @name JXG.GeometryElement#pendown
    //  * @param {Event} e The browser's event object.
    //  */
    // __evt__pendown(e) { }
    // /**
    //  * @event
    //  * @description Whenever the user starts to touch an element.
    //  * @name JXG.GeometryElement#touchdown
    //  * @param {Event} e The browser's event object.
    //  */
    // __evt__touchdown(e) { }
    // /**
    //  * @event
    //  * @description Whenever the user clicks on an element.
    //  * @name JXG.Board#click
    //  * @param {Event} e The browser's event object.
    //  */
    // __evt__click(e) { }
    // /**
    //  * @event
    //  * @description Whenever the user double clicks on an element.
    //  * This event works on desktop browser, but is undefined
    //  * on mobile browsers.
    //  * @name JXG.Board#dblclick
    //  * @param {Event} e The browser's event object.
    //  * @see JXG.Board#clickDelay
    //  * @see JXG.Board#dblClickSuppressClick
    //  */
    // __evt__dblclick(e) { }
    // /**
    //  * @event
    //  * @description Whenever the user clicks on an element with a mouse device.
    //  * @name JXG.Board#mouseclick
    //  * @param {Event} e The browser's event object.
    //  */
    // __evt__mouseclick(e) { }
    // /**
    //  * @event
    //  * @description Whenever the user double clicks on an element with a mouse device.
    //  * @name JXG.Board#mousedblclick
    //  * @param {Event} e The browser's event object.
    //  */
    // __evt__mousedblclick(e) { }
    // /**
    //  * @event
    //  * @description Whenever the user clicks on an element with a pointer device.
    //  * @name JXG.Board#pointerclick
    //  * @param {Event} e The browser's event object.
    //  */
    // __evt__pointerclick(e) { }
    // /**
    //  * @event
    //  * @description Whenever the user double clicks on an element with a pointer device.
    //  * This event works on desktop browser, but is undefined
    //  * on mobile browsers.
    //  * @name JXG.Board#pointerdblclick
    //  * @param {Event} e The browser's event object.
    //  */
    // __evt__pointerdblclick(e) { }
    // /**
    //  * @event
    //  * @description Whenever the user stops to touch or click an element.
    //  * @name JXG.GeometryElement#up
    //  * @param {Event} e The browser's event object.
    //  */
    // __evt__up(e) { }
    // /**
    //  * @event
    //  * @description Whenever the user releases the mousebutton over an element.
    //  * @name JXG.GeometryElement#mouseup
    //  * @param {Event} e The browser's event object.
    //  */
    // __evt__mouseup(e) { }
    // /**
    //  * @event
    //  * @description Whenever the user lifts the pen over an element.
    //  * @name JXG.GeometryElement#penup
    //  * @param {Event} e The browser's event object.
    //  */
    // __evt__penup(e) { }
    // /**
    //  * @event
    //  * @description Whenever the user stops touching an element.
    //  * @name JXG.GeometryElement#touchup
    //  * @param {Event} e The browser's event object.
    //  */
    // __evt__touchup(e) { }
    // /**
    //  * @event
    //  * @description Notify every time an attribute is changed.
    //  * @name JXG.GeometryElement#attribute
    //  * @param {Object} o A list of changed attributes and their new value.
    //  * @param {Object} el Reference to the element
    //  */
    // __evt__attribute(o, el) { }
    // /**
    //  * @event
    //  * @description This is a generic event handler. It exists for every possible attribute that can be set for
    //  * any element, e.g. if you want to be notified everytime an element's strokecolor is changed, is the event
    //  * <tt>attribute:strokecolor</tt>.
    //  * @name JXG.GeometryElement#attribute:key
    //  * @param val The old value.
    //  * @param nval The new value
    //  * @param {Object} el Reference to the element
    //  */
    // __evt__attribute_(val, nval, el) { }
    X(any) { if (any) {
        console.warn('what is?', any);
    } return this.usrCoords[0]; }
    Y(any) { if (any) {
        console.warn('what is?', any);
    } return this.usrCoords[1]; }
    Z(any) { if (any) {
        console.warn('what is?', any);
    } return this.usrCoords[2]; }
    setRadius(value) {
        this.radius = value;
    }
}

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Alfred Wassermann

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */
class CoordsElement extends GeometryElement {
    /**
     * An element containing coords is a basic geometric element.
     * This is a parent class for points, images and texts.
     * It holds common methods for
     * all kind of coordinate elements like points, texts and images.
     * It can not be used directly.
     * @class Creates a new coords element object. It is a parent class for points, images and texts.
     * Do not use this constructor to create an element.
     *
     * @private
     * @augments JXG.GeometryElement
     * @param {Array} coordinates An array with the affine user coordinates of the point.
     * {@link JXG.Options#elements} and - optionally - a name and an id.
     */
    // constructor(board: Board, coordinates: number[] | Object | Function = [1, 0, 0], attributes: Object, JSX_type: OBJECT_TYPE, JSX_class: OBJECT_CLASS, method: COORDS_BY) {
    constructor(board, method, coordinates = [1, 0, 0], attributes /*, JSX_type: OBJECT_TYPE, JSX_class: OBJECT_CLASS*/) {
        super(board, attributes);
        this.usrCoords = [];
        this.scrCoords = [];
        this.needsUpdateFromParent = false;
        /** used by animation */
        this._roundsCount = 0;
        this._intervalCode = 0;
        this._intervalCount = 0;
        this.isConstrained = false;
        // for (let i = 0; i < coordinates.length; ++i) {
        //     coordinates[i] = parseFloat(coordinates[i]);
        // }
        // TODO - phase 2just set up object
        this.usrCoords = new Coords$1(COORDS_BY.USER, coordinates, board).usrCoords;
        this.scrCoords = new Coords$1(COORDS_BY.SCREEN, coordinates, board).scrCoords;
        /**
         * Coordinates of the element.
         * @type JXG.Coords
         * @private
         */
        this.coords = new Coords$1(COORDS_BY.USER, coordinates, this.board);
        // initialCoords and actualCoords are needed to handle transformations
        // and dragging of objects simultaneously.
        // actualCoords are needed for non-points since the visible objects
        // is transformed in the renderer.
        // For labels and other relative texts, actualCoords is ignored, see
        // board.initMoveObject
        this.initialCoords = new Coords$1(COORDS_BY.USER, coordinates, this.board);
        this.actualCoords = new Coords$1(COORDS_BY.USER, coordinates, this.board);
        /**
         * Relative position on a slide element (line, circle, curve) if element is a glider on this element.
         * @type Number
         * @private
         */
        //TODO: slide must move higher //this.position = null;
        /**
         * True if there the method this.updateConstraint() has been set. It is
         * probably different from the prototype function() {return this;}.
         * Used in updateCoords fo glider elements.
         *
         * @see JXG.CoordsElement#updateCoords
         * @type Boolean
         * @private
         */
        this.isConstrained = false;
        /**
         * Determines whether the element slides on a polygon if point is a glider.
         * @type Boolean
         * @default false
         * @private
         */
        this.onPolygon = false;
        /**
         * When used as a glider this member stores the object, where to glide on.
         * To set the object to glide on use the method
         * {@link JXG.Point#makeGlider} and DO NOT set this property directly
         * as it will break the dependency tree.
         * @type JXG.GeometryElement
         */
        this.slideObject = null;
        /**
         * List of elements the element is bound to, i.e. the element glides on.
         * Only the last entry is active.
         * Use {@link JXG.Point#popSlideObject} to remove the currently active slideObject.
         */
        //TODO: slide must move higher //     this.slideObjects = [];
        /**
         * A {@link JXG.CoordsElement#updateGlider} call is usually followed
         * by a general {@link JXG.Board#update} which calls
         * {@link JXG.CoordsElement#updateGliderFromParent}.
         * To prevent double updates, {@link JXG.CoordsElement#needsUpdateFromParent}
         * is set to false in updateGlider() and reset to true in the following call to
         * {@link JXG.CoordsElement#updateGliderFromParent}
         * @type Boolean
         */
        this.needsUpdateFromParent = true;
        /**
         * Stores the groups of this element in an array of Group.
         * @type Array
         * @see JXG.Group
         * @private
         */
        //TODO: groups must move higher // this.groups = [];
        /*
         * Do we need this?
        // TODO          */
        // this.Xjc = null;
        // this.Yjc = null;
        // documented in GeometryElement
        this.methodMap = Type.deepCopy(this.methodMap, {
            move: "moveTo",
            moveTo: "moveTo",
            moveAlong: "moveAlong",
            visit: "visit",
            glide: "makeGlider",
            makeGlider: "makeGlider",
            intersect: "makeIntersection",
            makeIntersection: "makeIntersection",
            X: "X",
            Y: "Y",
            Coords: "Coords",
            free: "free",
            setPosition: "setGliderPosition",
            setGliderPosition: "setGliderPosition",
            addConstraint: "addConstraint",
            dist: "Dist",
            Dist: "Dist",
            onPolygon: "onPolygon",
            startAnimation: "startAnimation",
            stopAnimation: "stopAnimation"
        });
        /*
         * this.element may have been set by the object constructor.
         */
        // TODO: what is isLable??  not defined
        let isLabel = false;
        if (Type.exists(this.element)) {
            this.addAnchor(coordinates, isLabel);
        }
        this.isDraggable = true;
    }
    ;
    /**
     * Dummy function for unconstrained points or gliders.
     * @private
     */
    updateConstraint() {
        return this;
    }
    /**
     * Updates the coordinates of the element.
     * @private
     */
    updateCoords(fromParent) {
        if (!this.needsUpdate) {
            return this;
        }
        if (!Type.exists(fromParent)) {
            fromParent = false;
        }
        // if (!this.evalVisProp('frozen')) {
        if (!Type.exists(this._initialized) || this.evalVisProp('frozen') !== true) {
            this.updateConstraint();
        }
        /*
         * We need to calculate the new coordinates no matter of the elements visibility because
         * a child could be visible and depend on the coordinates of the element/point (e.g. perpendicular).
         *
         * Check if the element is a glider and calculate new coords in dependency of this.slideObject.
         * This function is called with fromParent==true in case it is a glider element for example if
         * the defining elements of the line or circle have been changed.
         */
        if (this.type === OBJECT_TYPE.GLIDER) {
            if (this.isConstrained) {
                fromParent = false;
            }
            if (fromParent) {
                this.updateGliderFromParent();
            }
            else {
                this.updateGlider();
            }
        }
        this.updateTransform(fromParent);
        if (!Type.exists(this._initialized)) {
            this._initialized = true;
        }
        return this;
    }
    /**
     * Update of glider in case of dragging the glider or setting the postion of the glider.
     * The relative position of the glider has to be updated.
     *
     * In case of a glider on a line:
     * If the second point is an ideal point, then -1 < this.position < 1,
     * this.position==+/-1 equals point2, this.position==0 equals point1
     *
     * If the first point is an ideal point, then 0 < this.position < 2
     * this.position==0  or 2 equals point1, this.position==1 equals point2
     *
     * @private
     */
    // TODO: this should be moved to Glider (above line, curve, circle, etc)
    // updateGlider() {
    //     var i, d, v,
    //         p1c, p2c, poly, cc, pos,
    //         angle, sgn, alpha, beta,
    //         delta = 2.0 * Math.PI,
    //         cp, c, invMat,
    //         newCoords, newPos,
    //         doRound = false,
    //         ev_sw,
    //         snappedTo, snapValues,
    //         slide = this.slideObject,
    //         res, cu,
    //         slides = [],
    //         isTransformed;
    //     this.needsUpdateFromParent = false;
    //     if (slide.elementClass === OBJECT_CLASS.CIRCLE) {
    //         if (this.evalVisProp('isgeonext')) {
    //             delta = 1.0;
    //         }
    //         newCoords = Geometry.projectPointToCircle(this, slide, this.board);
    //         newPos =
    //             Geometry.rad(
    //                 [slide.center.X() + 1.0, slide.center.Y()],
    //                 slide.center,
    //                 this
    //             ) / delta;
    //     } else if (slide.elementClass === OBJECT_CLASS.LINE) {
    //         /*
    //          * onPolygon==true: the point is a slider on a segment and this segment is one of the
    //          * "borders" of a polygon.
    //          * This is a GEONExT feature.
    //          */
    //         if (this.onPolygon) {
    //             p1c = slide.point1.coords.usrCoords;
    //             p2c = slide.point2.coords.usrCoords;
    //             i = 1;
    //             d = p2c[i] - p1c[i];
    //             if (Math.abs(d) < JSXMath.eps) {
    //                 i = 2;
    //                 d = p2c[i] - p1c[i];
    //             }
    //             cc = Geometry.projectPointToLine(this, slide, this.board);
    //             pos = (cc.usrCoords[i] - p1c[i]) / d;
    //             poly = slide.parentPolygon;
    //             if (pos < 0) {
    //                 for (i = 0; i < poly.borders.length; i++) {
    //                     if (slide === poly.borders[i]) {
    //                         slide =
    //                             poly.borders[
    //                             (i - 1 + poly.borders.length) % poly.borders.length
    //                             ];
    //                         break;
    //                     }
    //                 }
    //             } else if (pos > 1.0) {
    //                 for (i = 0; i < poly.borders.length; i++) {
    //                     if (slide === poly.borders[i]) {
    //                         slide =
    //                             poly.borders[
    //                             (i + 1 + poly.borders.length) % poly.borders.length
    //                             ];
    //                         break;
    //                     }
    //                 }
    //             }
    //             // If the slide object has changed, save the change to the glider.
    //             if (slide.id !== this.slideObject.id) {
    //                 this.slideObject = slide;
    //             }
    //         }
    //         p1c = slide.point1.coords;
    //         p2c = slide.point2.coords;
    //         // Distance between the two defining points
    //         d = p1c.distance(COORDS_BY.USER, p2c);
    //         // The defining points are identical
    //         if (d < JSXMath.eps) {
    //             //this.coords.setCoordinates(COORDS_BY.USER, p1c);
    //             newCoords = p1c;
    //             doRound = true;
    //             newPos = 0.0;
    //         } else {
    //             newCoords = Geometry.projectPointToLine(this, slide, this.board);
    //             p1c = p1c.usrCoords.slice(0);
    //             p2c = p2c.usrCoords.slice(0);
    //             // The second point is an ideal point
    //             if (Math.abs(p2c[0]) < JSXMath.eps) {
    //                 i = 1;
    //                 d = p2c[i];
    //                 if (Math.abs(d) < JSXMath.eps) {
    //                     i = 2;
    //                     d = p2c[i];
    //                 }
    //                 d = (newCoords.usrCoords[i] - p1c[i]) / d;
    //                 sgn = d >= 0 ? 1 : -1;
    //                 d = Math.abs(d);
    //                 newPos = (sgn * d) / (d + 1);
    //                 // The first point is an ideal point
    //             } else if (Math.abs(p1c[0]) < JSXMath.eps) {
    //                 i = 1;
    //                 d = p1c[i];
    //                 if (Math.abs(d) < JSXMath.eps) {
    //                     i = 2;
    //                     d = p1c[i];
    //                 }
    //                 d = (newCoords.usrCoords[i] - p2c[i]) / d;
    //                 // 1.0 - d/(1-d);
    //                 if (d < 0.0) {
    //                     newPos = (1 - 2.0 * d) / (1.0 - d);
    //                 } else {
    //                     newPos = 1 / (d + 1);
    //                 }
    //             } else {
    //                 i = 1;
    //                 d = p2c[i] - p1c[i];
    //                 if (Math.abs(d) < JSXMath.eps) {
    //                     i = 2;
    //                     d = p2c[i] - p1c[i];
    //                 }
    //                 newPos = (newCoords.usrCoords[i] - p1c[i]) / d;
    //             }
    //         }
    //         // Snap the glider to snap values.
    //         snappedTo = this.findClosestSnapValue(newPos);
    //         if (snappedTo !== null) {
    //             snapValues = this.evalVisProp('snapvalues');
    //             newPos = (snapValues[snappedTo] - this._smin) / (this._smax - this._smin);
    //             this.update(true);
    //         } else {
    //             // Snap the glider point of the slider into its appropriate position
    //             // First, recalculate the new value of this.position
    //             // Second, call update(fromParent==true) to make the positioning snappier.
    //             ev_sw = this.evalVisProp('snapwidth');
    //             if (
    //                 ev_sw > 0.0 && Math.abs(this._smax - this._smin) >= JSXMath.eps
    //             ) {
    //                 newPos = Math.max(Math.min(newPos, 1), 0);
    //                 // v = newPos * (this._smax - this._smin) + this._smin;
    //                 // v = Math.round(v / ev_sw) * ev_sw;
    //                 v = newPos * (this._smax - this._smin);
    //                 v = Math.round(v / ev_sw) * ev_sw + this._smin;
    //                 newPos = (v - this._smin) / (this._smax - this._smin);
    //                 this.update(true);
    //             }
    //         }
    //         p1c = slide.point1.coords;
    //         if (
    //             !slide.evalVisProp('straightfirst') &&
    //             Math.abs(p1c.usrCoords[0]) > JSXMath.eps &&
    //             newPos < 0
    //         ) {
    //             newCoords = p1c;
    //             doRound = true;
    //             newPos = 0;
    //         }
    //         p2c = slide.point2.coords;
    //         if (
    //             !slide.evalVisProp('straightlast') &&
    //             Math.abs(p2c.usrCoords[0]) > JSXMath.eps &&
    //             newPos > 1
    //         ) {
    //             newCoords = p2c;
    //             doRound = true;
    //             newPos = 1;
    //         }
    //     } else if (slide.type === OBJECT_TYPE.TURTLE) {
    //         // In case, the point is a constrained glider.
    //         this.updateConstraint();
    //         res = Geometry.projectPointToTurtle(this, slide, this.board);
    //         newCoords = res[0];
    //         newPos = res[1]; // save position for the overwriting below
    //     } else if (slide.elementClass === OBJECT_CLASS.CURVE) {
    //         if (
    //             slide.type === OBJECT_TYPE.ARC ||
    //             slide.type === OBJECT_TYPE.SECTOR
    //         ) {
    //             newCoords = Geometry.projectPointToCircle(this, slide, this.board);
    //             angle = Geometry.rad(slide.radiuspoint, slide.center, this);
    //             alpha = 0.0;
    //             beta = Geometry.rad(slide.radiuspoint, slide.center, slide.anglepoint);
    //             newPos = angle;
    //             ev_sw = slide.evalVisProp('selection');
    //             if (
    //                 (ev_sw === "minor" && beta > Math.PI) ||
    //                 (ev_sw === "major" && beta < Math.PI)
    //             ) {
    //                 alpha = beta;
    //                 beta = 2 * Math.PI;
    //             }
    //             // Correct the position if we are outside of the sector/arc
    //             if (angle < alpha || angle > beta) {
    //                 newPos = beta;
    //                 if (
    //                     (angle < alpha && angle > alpha * 0.5) ||
    //                     (angle > beta && angle > beta * 0.5 + Math.PI)
    //                 ) {
    //                     newPos = alpha;
    //                 }
    //                 this.needsUpdateFromParent = true;
    //                 this.updateGliderFromParent();
    //             }
    //             delta = beta - alpha;
    //             if (this.visProp.isgeonext) {
    //                 delta = 1.0;
    //             }
    //             if (Math.abs(delta) > JSXMath.eps) {
    //                 newPos /= delta;
    //             }
    //         } else {
    //             // In case, the point is a constrained glider.
    //             this.updateConstraint();
    //             // Handle the case if the curve comes from a transformation of a continuous curve.
    //             if (slide.transformations.length > 0) {
    //                 isTransformed = false;
    //                 // TODO this might buggy, see the recursion
    //                 // in line.js getCurveTangentDir
    //                 res = slide.getTransformationSource();
    //                 if (res[0]) {
    //                     isTransformed = res[0];
    //                     slides.push(slide);
    //                     slides.push(res[1]);
    //                 }
    //                 // Recurse
    //                 while (res[0] && Type.exists(res[1]._transformationSource)) {
    //                     res = res[1].getTransformationSource();
    //                     slides.push(res[1]);
    //                 }
    //                 cu = this.coords.usrCoords;
    //                 if (isTransformed) {
    //                     for (i = 0; i < slides.length; i++) {
    //                         slides[i].updateTransformMatrix();
    //                         invMat = Mat.inverse(slides[i].transformMat);
    //                         cu = Mat.matVecMult(invMat, cu);
    //                     }
    //                     cp = new Coords(COORDS_BY.USER, cu, this.board).usrCoords;
    //                     c = Geometry.projectCoordsToCurve(
    //                         cp[1],
    //                         cp[2],
    //                         this.position || 0,
    //                         slides[slides.length - 1],
    //                         this.board
    //                     );
    //                     // projectPointCurve() already would apply the transformation.
    //                     // Since we are projecting on the original curve, we have to do
    //                     // the transformations "by hand".
    //                     cu = c[0].usrCoords;
    //                     for (i = slides.length - 2; i >= 0; i--) {
    //                         cu = Mat.matVecMult(slides[i].transformMat, cu);
    //                     }
    //                     c[0] = new Coords(COORDS_BY.USER, cu, this.board);
    //                 } else {
    //                     slide.updateTransformMatrix();
    //                     invMat = Mat.inverse(slide.transformMat);
    //                     cu = Mat.matVecMult(invMat, cu);
    //                     cp = new Coords(COORDS_BY.USER, cu, this.board).usrCoords;
    //                     c = Geometry.projectCoordsToCurve(
    //                         cp[1],
    //                         cp[2],
    //                         this.position || 0,
    //                         slide,
    //                         this.board
    //                     );
    //                 }
    //                 newCoords = c[0];
    //                 newPos = c[1];
    //             } else {
    //                 res = Geometry.projectPointToCurve(this, slide, this.board);
    //                 newCoords = res[0];
    //                 newPos = res[1]; // save position for the overwriting below
    //             }
    //         }
    //     } else if (Type.isPoint(slide)) {
    //         //this.coords.setCoordinates(COORDS_BY.USER, Geometry.projectPointToPoint(this, slide, this.board).usrCoords, false);
    //         newCoords = Geometry.projectPointToPoint(this, slide, this.board);
    //         newPos = this.position; // save position for the overwriting below
    //     }
    //     this.coords.setCoordinates(COORDS_BY.USER, newCoords.usrCoords, doRound);
    //     this.position = newPos;
    // }
    /**
     * Find the closest entry in snapValues that is within snapValueDistance of pos.
     *
     * @param {Number} pos Value for which snapping is calculated.
     * @returns {Number} Index of the value to snap to, or null.
     * @private
     */
    findClosestSnapValue(pos) {
        var i, d, snapValues, snapValueDistance, snappedTo = null;
        // Snap the glider to snap values.
        snapValues = this.evalVisProp('snapvalues');
        snapValueDistance = this.evalVisProp('snapvaluedistance');
        if (Array.isArray(snapValues) &&
            Math.abs(this._smax - this._smin) >= JSXMath.eps &&
            snapValueDistance > 0.0) {
            for (i = 0; i < snapValues.length; i++) {
                d = Math.abs(pos * (this._smax - this._smin) + this._smin - snapValues[i]);
                if (d < snapValueDistance) {
                    snapValueDistance = d;
                    snappedTo = i;
                }
            }
        }
        return snappedTo;
    }
    // /**
    //  * Update of a glider in case a parent element has been updated. That means the
    //  * relative position of the glider stays the same.
    //  * @private
    //  */
    // TODO: this should be moved to Glider (above line, curve, circle, etc)
    // updateGliderFromParent() {
    //     var p1c, p2c, r, lbda, c,
    //         slide = this.slideObject,
    //         slides:GeometryElement[] = [],
    //         res, i, isTransformed,
    //         baseangle, alpha, angle, beta,
    //         delta = 2.0 * Math.PI;
    //     if (!this.needsUpdateFromParent) {
    //         this.needsUpdateFromParent = true;
    //         return;
    //     }
    //     if (slide.elementClass === OBJECT_CLASS.CIRCLE) {
    //         r = slide.Radius();
    //         if (this.evalVisProp('isgeonext')) {
    //             delta = 1.0;
    //         }
    //         c = [
    //             slide.center.X() + r * Math.cos(this.position * delta),
    //             slide.center.Y() + r * Math.sin(this.position * delta)
    //         ];
    //     } else if (slide.elementClass === OBJECT_CLASS.LINE) {
    //         p1c = slide.point1.coords.usrCoords;
    //         p2c = slide.point2.coords.usrCoords;
    //         // If one of the defining points of the line does not exist,
    //         // the glider should disappear
    //         if (
    //             (p1c[0] === 0 && p1c[1] === 0 && p1c[2] === 0) ||
    //             (p2c[0] === 0 && p2c[1] === 0 && p2c[2] === 0)
    //         ) {
    //             c = [0, 0, 0];
    //             // The second point is an ideal point
    //         } else if (Math.abs(p2c[0]) < JSXMath.eps) {
    //             lbda = Math.min(Math.abs(this.position), 1 - JSXMath.eps);
    //             lbda /= 1.0 - lbda;
    //             if (this.position < 0) {
    //                 lbda = -lbda;
    //             }
    //             c = [
    //                 p1c[0] + lbda * p2c[0],
    //                 p1c[1] + lbda * p2c[1],
    //                 p1c[2] + lbda * p2c[2]
    //             ];
    //             // The first point is an ideal point
    //         } else if (Math.abs(p1c[0]) < JSXMath.eps) {
    //             lbda = Math.max(this.position, JSXMath.eps);
    //             lbda = Math.min(lbda, 2 - JSXMath.eps);
    //             if (lbda > 1) {
    //                 lbda = (lbda - 1) / (lbda - 2);
    //             } else {
    //                 lbda = (1 - lbda) / lbda;
    //             }
    //             c = [
    //                 p2c[0] + lbda * p1c[0],
    //                 p2c[1] + lbda * p1c[1],
    //                 p2c[2] + lbda * p1c[2]
    //             ];
    //         } else {
    //             lbda = this.position;
    //             c = [
    //                 p1c[0] + lbda * (p2c[0] - p1c[0]),
    //                 p1c[1] + lbda * (p2c[1] - p1c[1]),
    //                 p1c[2] + lbda * (p2c[2] - p1c[2])
    //             ];
    //         }
    //     } else if (slide.type === OBJECT_TYPE.TURTLE) {
    //         this.coords.setCoordinates(COORDS_BY.USER, [
    //             slide.Z(this.position),
    //             slide.X(this.position),
    //             slide.Y(this.position)
    //         ]);
    //         // In case, the point is a constrained glider.
    //         this.updateConstraint();
    //         c = Geometry.projectPointToTurtle(this, slide, this.board)[0].usrCoords;
    //     } else if (slide.elementClass === OBJECT_CLASS.CURVE) {
    //         // Handle the case if the curve comes from a transformation of a continuous curve.
    //         isTransformed = false;
    //         res = slide.getTransformationSource();
    //         if (res[0]) {
    //             isTransformed = res[0];
    //             slides.push(slide);
    //             slides.push(res[1]);
    //         }
    //         // Recurse
    //         while (res[0] && Type.exists(res[1]._transformationSource)) {
    //             res = res[1].getTransformationSource();
    //             slides.push(res[1]);
    //         }
    //         if (isTransformed) {
    //             this.coords.setCoordinates(COORDS_BY.USER, [
    //                 slides[slides.length - 1].Z(this.position),
    //                 slides[slides.length - 1].X(this.position),
    //                 slides[slides.length - 1].Y(this.position)
    //             ]);
    //         } else {
    //             this.coords.setCoordinates(COORDS_BY.USER, [
    //                 slide.Z(this.position),
    //                 slide.X(this.position),
    //                 slide.Y(this.position)
    //             ]);
    //         }
    //         if (
    //             slide.type === OBJECT_TYPE.ARC ||
    //             slide.type === OBJECT_TYPE.SECTOR
    //         ) {
    //             baseangle = Geometry.rad(
    //                 [slide.center.X() + 1, slide.center.Y()],
    //                 slide.center,
    //                 slide.radiuspoint
    //             );
    //             alpha = 0.0;
    //             beta = Geometry.rad(slide.radiuspoint, slide.center, slide.anglepoint);
    //             if (
    //                 (slide.visProp.selection === "minor" && beta > Math.PI) ||
    //                 (slide.visProp.selection === "major" && beta < Math.PI)
    //             ) {
    //                 alpha = beta;
    //                 beta = 2 * Math.PI;
    //             }
    //             delta = beta - alpha;
    //             if (this.evalVisProp('isgeonext')) {
    //                 delta = 1.0;
    //             }
    //             angle = this.position * delta;
    //             // Correct the position if we are outside of the sector/arc
    //             if (angle < alpha || angle > beta) {
    //                 angle = beta;
    //                 if (
    //                     (angle < alpha && angle > alpha * 0.5) ||
    //                     (angle > beta && angle > beta * 0.5 + Math.PI)
    //                 ) {
    //                     angle = alpha;
    //                 }
    //                 this.position = angle;
    //                 if (Math.abs(delta) > JSXMath.eps) {
    //                     this.position /= delta;
    //                 }
    //             }
    //             r = slide.Radius();
    //             c = [
    //                 slide.center.X() + r * Math.cos(this.position * delta + baseangle),
    //                 slide.center.Y() + r * Math.sin(this.position * delta + baseangle)
    //             ];
    //         } else {
    //             // In case, the point is a constrained glider.
    //             this.updateConstraint();
    //             if (isTransformed) {
    //                 c = Geometry.projectPointToCurve(
    //                     this,
    //                     slides[slides.length - 1],
    //                     this.board
    //                 )[0].usrCoords;
    //                 // projectPointCurve() already would do the transformation.
    //                 // But since we are projecting on the original curve, we have to do
    //                 // the transformation "by hand".
    //                 for (i = slides.length - 2; i >= 0; i--) {
    //                     c = new Coords(
    //                         COORDS_BY.USER,
    //                         Mat.matVecMult(slides[i].transformMat, c),
    //                         this.board
    //                     ).usrCoords;
    //                 }
    //             } else {
    //                 c = Geometry.projectPointToCurve(this, slide, this.board)[0].usrCoords;
    //             }
    //         }
    //     } else if (Type.isPoint(slide)) {
    //         c = Geometry.projectPointToPoint(this, slide, this.board).usrCoords;
    //     }
    //     this.coords.setCoordinates(COORDS_BY.USER, c, false);
    // }
    updateRendererGeneric(rendererMethod) {
        //var wasReal;
        if (!this.needsUpdate || !this.board.renderer) {
            return this;
        }
        if (this.visPropCalc.visible) {
            //wasReal = this.isReal;
            this.isReal = !isNaN(this.coords.usrCoords[1] + this.coords.usrCoords[2]);
            //Homogeneous coords: ideal point
            this.isReal =
                Math.abs(this.coords.usrCoords[0]) > JSXMath.eps ? this.isReal : false;
            if (
            // wasReal &&
            !this.isReal) {
                this.updateVisibility(false);
            }
        }
        // Call the renderer only if element is visible.
        // Update the position
        if (this.visPropCalc.visible) {
            this.board.renderer[rendererMethod](this);
        }
        // Update the label if visible.
        if (this.hasLabel &&
            this.visPropCalc.visible &&
            this.label &&
            this.label.visPropCalc.visible &&
            this.isReal) {
            this.label.update();
            this.board.renderer.updateText(this.label);
        }
        // Update rendNode display
        this.setDisplayRendNode();
        // if (this.visPropCalc.visible !== this.visPropOld.visible) {
        //     this.board.renderer.display(this, this.visPropCalc.visible);
        //     this.visPropOld.visible = this.visPropCalc.visible;
        //
        //     if (this.hasLabel) {
        //         this.board.renderer.display(this.label, this.label.visPropCalc.visible);
        //     }
        // }
        this.needsUpdate = false;
        return this;
    }
    /**
     * Getter method for x, this is used by for CAS-points to access point coordinates.
     * @returns {Number} User coordinate of point in x direction.
     */
    X() {
        return this.coords.usrCoords[1];
    }
    /**
     * Getter method for y, this is used by CAS-points to access point coordinates.
     * @returns {Number} User coordinate of point in y direction.
     */
    Y() {
        return this.coords.usrCoords[2];
    }
    /**
     * Getter method for z, this is used by CAS-points to access point coordinates.
     * @returns {Number} User coordinate of point in z direction.
     */
    Z() {
        return this.coords.usrCoords[0];
    }
    /**
     * Getter method for coordinates x, y and (optional) z.
     * @param {Number|String} [digits='auto'] Truncating rule for the digits in the infobox.
     * <ul>
     * <li>'auto': done automatically by JXG.autoDigits()
     * <li>'none': no truncation
     * <li>number: truncate after "number digits" with JXG.toFixed()
     * </ul>
     * @param {Boolean} [withZ=false] If set to true the return value will be <tt>(x | y | z)</tt> instead of <tt>(x, y)</tt>.
     * @returns {String} User coordinates of point.
     */
    Coords(withZ) {
        if (withZ) {
            return this.coords.usrCoords.slice();
        }
        return this.coords.usrCoords.slice(1);
    }
    // Coords(digits, withZ) {
    //     var arr, sep;
    //     digits = digits || 'auto';
    //     if (withZ) {
    //         sep = ' | ';
    //     } else {
    //         sep = ', ';
    //     }
    //     if (digits === 'none') {
    //         arr = [this.X(), sep, this.Y()];
    //         if (withZ) {
    //             arr.push(sep, this.Z());
    //         }
    //     } else if (digits === 'auto') {
    //         if (this.useLocale()) {
    //             arr = [this.formatNumberLocale(this.X()), sep, this.formatNumberLocale(this.Y())];
    //             if (withZ) {
    //                 arr.push(sep, this.formatNumberLocale(this.Z()));
    //             }
    //         } else {
    //             arr = [Type.autoDigits(this.X()), sep, Type.autoDigits(this.Y())];
    //             if (withZ) {
    //                 arr.push(sep, Type.autoDigits(this.Z()));
    //             }
    //         }
    //     } else {
    //         if (this.useLocale()) {
    //             arr = [this.formatNumberLocale(this.X(), digits), sep, this.formatNumberLocale(this.Y(), digits)];
    //             if (withZ) {
    //                 arr.push(sep, this.formatNumberLocale(this.Z(), digits));
    //             }
    //         } else {
    //             arr = [Type.toFixed(this.X(), digits), sep, Type.toFixed(this.Y(), digits)];
    //             if (withZ) {
    //                 arr.push(sep, Type.toFixed(this.Z(), digits));
    //             }
    //         }
    //     }
    //     return '(' + arr.join('') + ')';
    // }
    /**
     * New evaluation of the function term.
     * This is required for CAS-points: Their XTerm() method is
     * overwritten in {@link JXG.CoordsElement#addConstraint}.
     *
     * @returns {Number} User coordinate of point in x direction.
     * @private
     */
    XEval() {
        return this.coords.usrCoords[1];
    }
    /**
     * New evaluation of the function term.
     * This is required for CAS-points: Their YTerm() method is overwritten
     * in {@link JXG.CoordsElement#addConstraint}.
     *
     * @returns {Number} User coordinate of point in y direction.
     * @private
     */
    YEval() {
        return this.coords.usrCoords[2];
    }
    /**
     * New evaluation of the function term.
     * This is required for CAS-points: Their ZTerm() method is overwritten in
     * {@link JXG.CoordsElement#addConstraint}.
     *
     * @returns {Number} User coordinate of point in z direction.
     * @private
     */
    ZEval() {
        return this.coords.usrCoords[0];
    }
    /**
     * Getter method for the distance to a second point, this is required for CAS-elements.
     * Here, function inlining seems to be worthwile (for plotting).
     * @param {JXG.Point} point2 The point to which the distance shall be calculated.
     * @returns {Number} Distance in user coordinate to the given point
     */
    Dist(point2) {
        if (this.isReal && point2.isReal) {
            return this.coords.distance(COORDS_BY.USER, point2.coords);
        }
        return NaN;
    }
    /**
     * Alias for {@link JXG.Element#handleSnapToGrid}
     * @param {Boolean} force force snapping independent of what the snaptogrid attribute says
     * @returns {JXG.CoordsElement} Reference to this element
     */
    snapToGrid(force) {
        return this.handleSnapToGrid(force);
    }
    /**
     * Let a point snap to the nearest point in distance of
     * {@link JXG.Point#attractorDistance}.
     * The function uses the coords object of the point as
     * its actual position.
     * @param {Boolean} force force snapping independent of what the snaptogrid attribute says
     * @returns {JXG.CoordsElement} Reference to this element
     */
    handleSnapToPoints(force) {
        var i, pEl, pCoords, d = 0, len, dMax = Infinity, c = null, ev_au, ev_ad, ev_is2p = this.evalVisProp('ignoredsnaptopoints'), len2, j, ignore = false;
        len = this.board.objectsList.length;
        if (ev_is2p) {
            len2 = ev_is2p.length;
        }
        if (this.evalVisProp('snaptopoints') || force) {
            ev_au = this.evalVisProp('attractorunit');
            ev_ad = this.evalVisProp('attractordistance');
            for (i = 0; i < len; i++) {
                pEl = this.board.objectsList[i];
                if (ev_is2p) {
                    ignore = false;
                    for (j = 0; j < len2; j++) {
                        if (pEl === this.board.select(ev_is2p[j])) {
                            ignore = true;
                            break;
                        }
                    }
                    if (ignore) {
                        continue;
                    }
                }
                if (Type.isPoint(pEl) && pEl !== this && pEl.visPropCalc.visible) {
                    pCoords = Geometry.projectPointToPoint(this, pEl);
                    if (ev_au === "screen") {
                        d = pCoords.distance(COORDS_BY.SCREEN, this.coords);
                    }
                    else {
                        d = pCoords.distance(COORDS_BY.USER, this.coords);
                    }
                    if (d < ev_ad && d < dMax) {
                        dMax = d;
                        c = pCoords;
                    }
                }
            }
            if (c !== null) {
                this.coords.setCoordinates(COORDS_BY.USER, c.usrCoords);
            }
        }
        return this;
    }
    /**
     * Alias for {@link JXG.CoordsElement#handleSnapToPoints}.
     *
     * @param {Boolean} force force snapping independent of what the snaptogrid attribute says
     * @returns {JXG.CoordsElement} Reference to this element
     */
    snapToPoints(force) {
        return this.handleSnapToPoints(force);
    }
    /**
     * A point can change its type from free point to glider
     * and vice versa. If it is given an array of attractor elements
     * (attribute attractors) and the attribute attractorDistance
     * then the point will be made a glider if it less than attractorDistance
     * apart from one of its attractor elements.
     * If attractorDistance is equal to zero, the point stays in its
     * current form.
     * @returns {JXG.CoordsElement} Reference to this element
     */
    handleAttractors() {
        var i, el, projCoords, projection, ev_au = this.evalVisProp('attractorunit'), ev_ad = this.evalVisProp('attractordistance'); this.evalVisProp('snatchdistance'); var ev_a = this.evalVisProp('attractors'), len = ev_a.length;
        if (ev_ad === 0.0) {
            return;
        }
        for (i = 0; i < len; i++) {
            el = this.board.select(ev_a[i]);
            if (Type.exists(el) && el !== this) {
                if (Type.isPoint(el)) {
                    projCoords = Geometry.projectPointToPoint(this, el);
                }
                else if (el.elementClass === OBJECT_CLASS.LINE) {
                    projection = Geometry.projectCoordsToSegment(this.coords.usrCoords, el.point1.coords.usrCoords, el.point2.coords.usrCoords);
                    if (!el.evalVisProp('straightfirst') && projection[1] < 0.0) {
                        projCoords = el.point1.coords;
                    }
                    else if (!el.evalVisProp('straightlast') &&
                        projection[1] > 1.0) {
                        projCoords = el.point2.coords;
                    }
                    else {
                        projCoords = new Coords$1(COORDS_BY.USER, projection[0], this.board);
                    }
                }
                else if (el.elementClass === OBJECT_CLASS.CIRCLE) {
                    projCoords = Geometry.projectPointToCircle(this, el, this.board);
                }
                else if (el.elementClass === OBJECT_CLASS.CURVE) {
                    projCoords = Geometry.projectPointToCurve(this, el, this.board)[0];
                }
                else if (el.type === OBJECT_TYPE.TURTLE) {
                    projCoords = Geometry.projectPointToTurtle(this, el, this.board)[0];
                }
                else if (el.type === OBJECT_TYPE.POLYGON) {
                    projCoords = new Coords$1(COORDS_BY.USER, Geometry.projectCoordsToPolygon(this.coords.usrCoords, el), this.board);
                }
                if (ev_au === "screen") {
                    projCoords.distance(COORDS_BY.SCREEN, this.coords);
                }
                else {
                    projCoords.distance(COORDS_BY.USER, this.coords);
                }
                // TODO: move to Glider
                // if (d < ev_ad) {
                //     if (
                //         !(
                //             this.type === OBJECT_TYPE.GLIDER &&
                //             (el === this.slideObject ||
                //                 (this.slideObject &&
                //                     this.onPolygon &&
                //                     this.slideObject.parentPolygon === el))
                //         )
                //     ) {
                //         this.makeGlider(el);
                //     }
                //     break; // bind the point to the first attractor in its list.
                // }
                // if (
                //     d >= ev_sd &&
                //     (el === this.slideObject ||
                //         (this.slideObject &&
                //             this.onPolygon &&
                //             this.slideObject.parentPolygon === el))
                // ) {
                //     this.popSlideObject();
                // }
            }
        }
        return this;
    }
    /**
     * Sets coordinates and calls the elements's update() method.
     * @param {Number} method The type of coordinates used here.
     * Possible values are {@link COORDS_BY.USER} and {@link COORDS_BY.SCREEN}.
     * @param {Array} coords coordinates <tt>([z], x, y)</tt> in screen/user units
     * @returns {JXG.CoordsElement} this element
     */
    setPositionDirectly(method, coords) {
        var i, c, dc, m, oldCoords = this.coords, newCoords;
        if (this.relativeCoords) {
            c = new Coords$1(method, coords, this.board);
            if (this.evalVisProp('islabel')) {
                dc = Statistics.subtract(c.scrCoords, oldCoords.scrCoords);
                this.relativeCoords.scrCoords[1] += dc[1];
                this.relativeCoords.scrCoords[2] += dc[2];
            }
            else {
                dc = Statistics.subtract(c.usrCoords, oldCoords.usrCoords);
                this.relativeCoords.usrCoords[1] += dc[1];
                this.relativeCoords.usrCoords[2] += dc[2];
            }
            return this;
        }
        this.coords.setCoordinates(method, coords);
        this.handleSnapToGrid();
        this.handleSnapToPoints();
        this.handleAttractors();
        // Here, we set the object's "actualCoords", because
        // coords and initialCoords coincide since transformations
        // for these elements are handled in the renderers.
        this.actualCoords.setCoordinates(COORDS_BY.USER, this.coords.usrCoords);
        // The element's coords have been set above to the new position `coords`.
        // Now, determine the preimage of `coords`, prior to all transformations.
        // This is needed for free elements that have a transformation bound to it.
        if (this.transformations.length > 0) {
            if (method === COORDS_BY.SCREEN) {
                newCoords = new Coords$1(method, coords, this.board).usrCoords;
            }
            else {
                if (coords.length === 2) {
                    coords = [1].concat(coords);
                }
                newCoords = coords;
            }
            m = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
            for (i = 0; i < this.transformations.length; i++) {
                m = JSXMath.matMatMult(this.transformations[i].matrix, m);
            }
            newCoords = JSXMath.matVecMult(JSXMath.inverse(m), newCoords);
            this.initialCoords.setCoordinates(COORDS_BY.USER, newCoords);
            if (this.elementClass !== OBJECT_CLASS.POINT) {
                // This is necessary for images and texts.
                this.coords.setCoordinates(COORDS_BY.USER, newCoords);
            }
        }
        this.prepareUpdate().update();
        // TODO: move to glider
        // // If the user suspends the board updates we need to recalculate the relative position of
        // // the point on the slide object. This is done in updateGlider() which is NOT called during the
        // // update process triggered by unsuspendUpdate.
        // if (this.board.isSuspendedUpdate && this.type === OBJECT_TYPE.GLIDER) {
        //     this.updateGlider();
        // }
        return this;
    }
    /**
     * Translates the point by <tt>tv = (x, y)</tt>.
     * @param {Number} method The type of coordinates used here.
     * Possible values are {@link COORDS_BY.USER} and {@link COORDS_BY.SCREEN}.
     * @param {Array} tv (x, y)
     * @returns {JXG.CoordsElement}
     */
    setPositionByTransform(method, tv) {
        var t;
        let tvCoords = new Coords$1(method, tv, this.board);
        t = this.board.create("transform", tvCoords.usrCoords.slice(1), {
            type: "translate"
        });
        if (this.transformations.length > 0 &&
            this.transformations[this.transformations.length - 1].isNumericMatrix) {
            this.transformations[this.transformations.length - 1].melt(t);
        }
        else {
            this.addTransform(this.element, t);
        }
        this.prepareUpdate().update(true);
        return this;
    }
    /**
     * Sets coordinates and calls the element's update() method.
     * @param {Number} method The type of coordinates used here.
     * Possible values are {@link COORDS_BY.USER} and {@link COORDS_BY.SCREEN}.
     * @param {Array} coords coordinates in screen/user units
     * @returns {JXG.CoordsElement}
     */
    setPosition(method, coords) {
        return this.setPositionDirectly(method, coords);
    }
    /**
     * Sets the position of a glider relative to the defining elements
     * of the {@link JXG.Point#slideObject}.
     * @param {Number} x
     * @returns {JXG.Point} Reference to the point element.
     */
    // TODO: move to Glider
    // setGliderPosition(x) {
    //     if (this.type === OBJECT_TYPE.GLIDER) {
    //         this.position = x;
    //         this.board.update(true);
    //     }
    //     return this;
    // }
    // TODO: move to Glider
    // /**
    //  * Convert the point to glider and update the construction.
    //  * To move the point visual onto the glider, a call of board update is necessary.
    //  * @param {String|Object} slide The object the point will be bound to.
    //  */
    makeGlider(slide) {
        //     var slideobj = this.board.select(slide),
        //         onPolygon = false,
        //         min, i, dist;
        //     if (slideobj.type === OBJECT_TYPE.POLYGON) {
        //         // Search for the closest edge of the polygon.
        //         min = Number.MAX_VALUE;
        //         for (i = 0; i < slideobj.borders.length; i++) {
        //             dist = Geometry.distPointLine(
        //                 this.coords.usrCoords,
        //                 slideobj.borders[i].stdform
        //             );
        //             if (dist < min) {
        //                 min = dist;
        //                 slide = slideobj.borders[i];
        //             }
        //         }
        //         slideobj = this.board.select(slide);
        //         onPolygon = true;
        //     }
        // TODO: move to glider
        // /* Gliders on Ticks are forbidden */
        // if (!Type.exists(slideobj)) {
        //     throw new Error("JSXGraph: slide object undefined.");
        // } else if (slideobj.type === OBJECT_TYPE.TICKS) {
        //     throw new Error("JSXGraph: gliders on ticks are not possible.");
        // }
        // this.slideObject = this.board.select(slide);
        // this.slideObjects.push(this.slideObject);
        // this.addParents(slide);
        this.type = OBJECT_TYPE.GLIDER;
        this.elType = 'glider';
        this.visProp.snapwidth = -1; // By default, deactivate snapWidth
        this.slideObject.addChild(this);
        this.isDraggable = true;
        this.onPolygon = this.onPolygon;
        this.generatePolynomial = function () {
            return this.slideObject.generatePolynomial(this);
        };
        // TODO: move to glider
        // // Determine the initial value of this.position
        // this.updateGlider();
        // this.needsUpdateFromParent = true;
        // this.updateGliderFromParent();
        return this;
    }
    /**
     * Remove the last slideObject. If there are more than one elements the point is bound to,
     * the second last element is the new active slideObject.
     */
    popSlideObject() {
        if (this.slideObjects.length > 0) {
            this.slideObjects.pop();
            // It may not be sufficient to remove the point from
            // the list of childElement. For complex dependencies
            // one may have to go to the list of ancestor and descendants.  A.W.
            // Yes indeed, see #51 on github bug tracker
            //   delete this.slideObject.childElements[this.id];
            this.slideObject.removeChild(this);
            if (this.slideObjects.length === 0) {
                this.type = this._org_type;
                if (this.type === OBJECT_TYPE.POINT) {
                    this.elType = "point";
                }
                else if (this.elementClass === OBJECT_CLASS.TEXT) {
                    this.elType = "text";
                }
                else if (this.type === OBJECT_TYPE.IMAGE) {
                    this.elType = "image";
                }
                else if (this.type === OBJECT_TYPE.FOREIGNOBJECT) {
                    this.elType = "foreignobject";
                }
                this.slideObject = null;
            }
            else {
                this.slideObject = this.slideObjects[this.slideObjects.length - 1];
            }
        }
    }
    /**
     * Converts a calculated element into a free element,
     * i.e. it will delete all ancestors and transformations and,
     * if the element is currently a glider, will remove the slideObject reference.
     */
    free() {
        var ancestorId, ancestor;
        // child;
        if (this.type !== OBJECT_TYPE.GLIDER) {
            // remove all transformations
            this.transformations.length = 0;
            delete this.updateConstraint;
            this.isConstrained = false;
            // this.updateConstraint = function () {
            //     return this;
            // };
            if (!this.isDraggable) {
                this.isDraggable = true;
                if (this.elementClass === OBJECT_CLASS.POINT) {
                    this.type = OBJECT_TYPE.POINT;
                    this.elType = "point";
                }
                this.XEval = function () {
                    return this.coords.usrCoords[1];
                };
                this.YEval = function () {
                    return this.coords.usrCoords[2];
                };
                this.ZEval = function () {
                    return this.coords.usrCoords[0];
                };
                this.Xjc = null;
                this.Yjc = null;
            }
            else {
                return;
            }
        }
        // a free point does not depend on anything. And instead of running through tons of descendants and ancestor
        // structures, where we eventually are going to visit a lot of objects twice or thrice with hard to read and
        // comprehend code, just run once through all objects and delete all references to this point and its label.
        for (ancestorId in this.board.objects) {
            if (this.board.objects.hasOwnProperty(ancestorId)) {
                ancestor = this.board.objects[ancestorId];
                if (ancestor.descendants) {
                    delete ancestor.descendants[this.id];
                    delete ancestor.childElements[this.id];
                    if (this.hasLabel) {
                        delete ancestor.descendants[this.label.id];
                        delete ancestor.childElements[this.label.id];
                    }
                }
            }
        }
        // A free point does not depend on anything. Remove all ancestors.
        this.ancestors = {}; // only remove the reference
        this.parents = [];
        // Completely remove all slideObjects of the element
        this.slideObject = null;
        this.slideObjects = [];
        if (this.elementClass === OBJECT_CLASS.POINT) {
            this.type = OBJECT_TYPE.POINT;
            this.elType = "point";
        }
        else if (this.elementClass === OBJECT_CLASS.TEXT) {
            this.type = this._org_type;
            this.elType = "text";
        }
        else if (this.elementClass === OBJECT_CLASS.OTHER) {
            this.type = this._org_type;
            this.elType = "image";
        }
    }
    /**
     * Convert the point to CAS point and call update().
     * @param {Array} terms [[zterm], xterm, yterm] defining terms for the z, x and y coordinate.
     * The z-coordinate is optional and it is used for homogeneous coordinates.
     * The coordinates may be either <ul>
     *   <li>a JavaScript function,</li>
     *   <li>a string containing GEONExT syntax. This string will be converted into a JavaScript
     *     function here,</li>
     *   <li>a Number</li>
     *   <li>a pointer to a slider object. This will be converted into a call of the Value()-method
     *     of this slider.</li>
     *   </ul>
     * @see JXG.GeonextParser#geonext2JS
     */
    addConstraint(terms) {
        var i, v;
        let newfuncs;
        let makeConstFunction = (z) => { };
        let makeSliderFunction = (a) => { };
        if (this.elementClass === OBJECT_CLASS.POINT) {
            this.type = OBJECT_TYPE.CAS;
        }
        this.isDraggable = false;
        for (i = 0; i < terms.length; i++) {
            v = terms[i];
            if (Type.isString(v)) ;
            else if (Type.isFunction(v)) {
                newfuncs[i] = v;
            }
            else if (Type.isNumber(v)) {
                newfuncs[i] = makeConstFunction();
            }
            else if (Type.isObject(v) && Type.isFunction(v.Value)) {
                // Slider
                newfuncs[i] = makeSliderFunction();
            }
            newfuncs[i].origin = v;
        }
        if (terms.length === 1) {
            // Intersection function
            this.updateConstraint = function () {
                var c = newfuncs[0]();
                // Array
                if (Array.isArray(c)) {
                    this.coords.setCoordinates(COORDS_BY.USER, c);
                    // Coords object
                }
                else {
                    this.coords = c;
                }
                return this;
            };
        }
        else if (terms.length === 2) {
            // Euclidean coordinates
            this.XEval = newfuncs[0];
            this.YEval = newfuncs[1];
            this.addParents([newfuncs[0].origin, newfuncs[1].origin]);
            this.updateConstraint = function () {
                this.coords.setCoordinates(COORDS_BY.USER, [
                    this.XEval(),
                    this.YEval()
                ]);
                return this;
            };
        }
        else {
            // Homogeneous coordinates
            this.ZEval = newfuncs[0];
            this.XEval = newfuncs[1];
            this.YEval = newfuncs[2];
            this.addParents([newfuncs[0].origin, newfuncs[1].origin, newfuncs[2].origin]);
            this.updateConstraint = function () {
                this.coords.setCoordinates(COORDS_BY.USER, [
                    this.ZEval(),
                    this.XEval(),
                    this.YEval()
                ]);
                return this;
            };
        }
        this.isConstrained = true;
        /**
         * We have to do an update. Otherwise, elements relying on this point will receive NaN.
         */
        this.prepareUpdate().update(true);
        if (!this.board.isSuspendedUpdate) {
            this.updateVisibility().updateRenderer();
            if (this.hasLabel) {
                this.label.fullUpdate();
            }
        }
        return this;
    }
    /**
     * In case there is an attribute "anchor", the element is bound to
     * this anchor element.
     * This is handled with this.relativeCoords. If the element is a label
     * relativeCoords are given in scrCoords, otherwise in usrCoords.
     * @param{Array} coordinates Offset from the anchor element. These are the values for this.relativeCoords.
     * In case of a label, coordinates are screen coordinates. Otherwise, coordinates are user coordinates.
     * @param{Boolean} isLabel Yes/no
     * @private
     */
    addAnchor(coordinates, isLabel) {
        if (isLabel) {
            this.relativeCoords = new Coords$1(COORDS_BY.SCREEN, coordinates.slice(0, 2), this.board);
        }
        else {
            this.relativeCoords = new Coords$1(COORDS_BY.USER, coordinates, this.board);
        }
        this.addChild(this);
        if (isLabel) {
            this.addParents([this]);
        }
        this.XEval = function () {
            var sx, coords, anchor, ev_o;
            if (this.evalVisProp('islabel')) {
                ev_o = this.evalVisProp('offset');
                sx = parseFloat(ev_o[0]);
                anchor = this.element.getLabelAnchor();
                coords = new Coords$1(COORDS_BY.SCREEN, [sx + this.relativeCoords.scrCoords[1] + anchor.scrCoords[1], 0], this.board);
                return coords.usrCoords[1];
            }
            anchor = this.element.getTextAnchor();
            return this.relativeCoords.usrCoords[1] + anchor.usrCoords[1];
        };
        this.YEval = function () {
            var sy, coords, anchor, ev_o;
            if (this.evalVisProp('islabel')) {
                ev_o = this.evalVisProp('offset');
                sy = -parseFloat(ev_o[1]);
                anchor = this.element.getLabelAnchor();
                coords = new Coords$1(COORDS_BY.SCREEN, [0, sy + this.relativeCoords.scrCoords[2] + anchor.scrCoords[2]], this.board);
                return coords.usrCoords[2];
            }
            anchor = this.element.getTextAnchor();
            return this.relativeCoords.usrCoords[2] + anchor.usrCoords[2];
        };
        // TODO:  ??         this.ZEval = Type.createFunction(1, this.board, "");
        this.updateConstraint = () => {
            this.coords.setCoordinates(COORDS_BY.USER, [
                this.ZEval(),
                this.XEval(),
                this.YEval()
            ]);
            return this;
        };
        this.isConstrained = true;
        this.updateConstraint();
    }
    /**
     * Applies the transformations of the element.
     * This method applies to text and images. Point transformations are handled differently.
     * @param {Boolean} fromParent True if the drag comes from a child element. Unused.
     * @returns {JXG.CoordsElement} Reference to itself.
     */
    updateTransform(fromParent) {
        var c, i;
        if (this.transformations.length === 0 || this.baseElement === null) {
            return this;
        }
        // This method is called for non-points only.
        // Here, we set the object's "actualCoords", because
        // coords and initialCoords coincide since transformations
        // for these elements are handled in the renderers.
        this.transformations[0].update();
        if (this === this.baseElement) {
            // Case of bindTo
            c = this.transformations[0].apply(this, "self");
        }
        else {
            c = this.transformations[0].apply(this.baseElement);
        }
        for (i = 1; i < this.transformations.length; i++) {
            this.transformations[i].update();
            c = JSXMath.matVecMult(this.transformations[i].matrix, c);
        }
        this.actualCoords.setCoordinates(COORDS_BY.USER, c);
        return this;
    }
    /**
     * Add transformations to this element.
     * @param {JXG.GeometryElement} el
     * @param {JXG.Transformation|Array} transform Either one {@link JXG.Transformation}
     * or an array of {@link JXG.Transformation}s.
     * @returns {JXG.CoordsElement} Reference to itself.
     */
    addTransform(el, transform) {
        var i, list = Array.isArray(transform) ? transform : [transform], len = list.length;
        // There is only one baseElement possible
        if (this.transformations.length === 0) {
            this.baseElement = el;
        }
        for (i = 0; i < len; i++) {
            this.transformations.push(list[i]);
        }
        return this;
    }
    /**
     * Animate a point.
     * @param {Number|Function} direction The direction the glider is animated. Can be +1 or -1.
     * @param {Number|Function} stepCount The number of steps in which the parent element is divided.
     * Must be at least 1.
     * @param {Number|Function} delay Time in msec between two animation steps. Default is 250.
     * @param {Number} [maxRounds=-1] The number of rounds the glider will be animated. The glider will run infinitely if
     * maxRounds is negative or equal to Infinity.
     * @returns {JXG.CoordsElement} Reference to itself.
     *
     * @name Glider#startAnimation
     * @see Glider#stopAnimation
     * @function
     * @example
     * // Divide the circle line into 6 steps and
     * // visit every step 330 msec counterclockwise.
     * var ci = board.create('circle', [[-1,2], [2,1]]);
     * var gl = board.create('glider', [0,2, ci]);
     * gl.startAnimation(-1, 6, 330);
     *
     * </pre><div id="JXG0f35a50e-e99d-11e8-a1ca-04d3b0c2aad3" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG0f35a50e-e99d-11e8-a1ca-04d3b0c2aad3',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     // Divide the circle line into 6 steps and
     *     // visit every step 330 msec counterclockwise.
     *     var ci = board.create('circle', [[-1,2], [2,1]]);
     *     var gl = board.create('glider', [0,2, ci]);
     *     gl.startAnimation(-1, 6, 330);
     *
     *     })();
     *
     * </script><pre>
     * @example
     * //animate example closed curve
     * var c1 = board.create('curve',[(u)=>4*Math.cos(u),(u)=>2*Math.sin(u)+2,0,2*Math.PI]);
     * var p2 = board.create('glider', [c1]);
     * var button1 = board.create('button', [1, 7, 'start animation',function(){p2.startAnimation(1,8)}]);
     * var button2 = board.create('button', [1, 5, 'stop animation',function(){p2.stopAnimation()}]);
     * </pre><div class="jxgbox" id="JXG10e885ea-b05d-4e7d-a473-bac2554bce68" style="width: 200px; height: 200px;"></div>
     * <script type="text/javascript">
     *   var gpex4_board = JXG.JSXGraph.initBoard('JXG10e885ea-b05d-4e7d-a473-bac2554bce68', {boundingbox: [-1, 10, 10, -1], axis: true, showcopyright: false, shownavigation: false});
     *   var gpex4_c1 = gpex4_board.create('curve',[(u)=>4*Math.cos(u)+4,(u)=>2*Math.sin(u)+2,0,2*Math.PI]);
     *   var gpex4_p2 = gpex4_board.create('glider', [gpex4_c1]);
     *   gpex4_board.create('button', [1, 7, 'start animation',function(){gpex4_p2.startAnimation(1,8)}]);
     *   gpex4_board.create('button', [1, 5, 'stop animation',function(){gpex4_p2.stopAnimation()}]);
     * </script><pre>
     *
     * @example
     * // Divide the slider area into 20 steps and
     * // visit every step 30 msec. Stop after 2 rounds.
     * var n = board.create('slider',[[-2,4],[2,4],[1,5,100]],{name:'n'});
     * n.startAnimation(1, 20, 30, 2);
     *
     * </pre><div id="JXG40ce04b8-e99c-11e8-a1ca-04d3b0c2aad3" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG40ce04b8-e99c-11e8-a1ca-04d3b0c2aad3',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     // Divide the slider area into 20 steps and
     *     // visit every step 30 msec.
     *     var n = board.create('slider',[[-2,4],[2,4],[1,5,100]],{name:'n'});
     *     n.startAnimation(1, 20, 30, 2);
     *
     *     })();
     * </script><pre>
     *
     */
    startAnimation(direction, stepCount, delay, maxRounds) {
        var dir = Type.evaluate(direction), sc = Type.evaluate(stepCount), that = this;
        delay = Type.evaluate(delay) || 250;
        maxRounds = Type.evaluate(maxRounds);
        maxRounds = (maxRounds !== 'undefined') ? maxRounds : -1;
        if (this.type === OBJECT_TYPE.GLIDER && !Type.exists(this._intervalCode) && maxRounds !== 0) {
            this._roundsCount = 0;
            this._intervalCode = window.setInterval(function () {
                that._anim(dir, sc, maxRounds);
            }, delay);
            if (!Type.exists(this._intervalCount)) {
                this._intervalCount = 0;
            }
        }
        return this;
    }
    /**
     * Stop animation.
     * @name Glider#stopAnimation
     * @see Glider#startAnimation
     * @function
     * @returns {JXG.CoordsElement} Reference to itself.
     */
    stopAnimation() {
        if (Type.exists(this._intervalCode)) {
            window.clearInterval(this._intervalCode);
            delete this._intervalCode;
        }
        return this;
    }
    /**
     * Starts an animation which moves the point along a given path in given time.
     * @param {Array|function} path The path the point is moved on.
     * This can be either an array of arrays or containing x and y values of the points of
     * the path, or an array of points, or a function taking the amount of elapsed time since the animation
     * has started and returns an array containing a x and a y value or NaN.
     * In case of NaN the animation stops.
     * @param {Number} time The time in milliseconds in which to finish the animation
     * @param {Object} [options] Optional settings for the animation.
     * @param {function} [options.callback] A function that is called as soon as the animation is finished.
     * @param {Boolean} [options.interpolate=true] If <tt>path</tt> is an array moveAlong()
     * will interpolate the path
     * using {@link JXG.Math.Numerics.Neville}. Set this flag to false if you don't want to use interpolation.
     * @returns {JXG.CoordsElement} Reference to itself.
     * @see JXG.CoordsElement#moveTo
     * @see JXG.CoordsElement#visit
     * @see JXG.CoordsElement#moveAlongES6
     * @see JXG.GeometryElement#animate
     */
    moveAlong(path, time, options) {
        options = options || {};
        var i, neville, interpath = [], p = [], delay = this.board.attr.animationdelay, steps = time / delay, len, pos, part, makeFakeFunction = function (i, j) {
            return function () {
                return path[i][j];
            };
        };
        if (Array.isArray(path)) {
            len = path.length;
            for (i = 0; i < len; i++) {
                if (Type.isPoint(path[i])) {
                    p[i] = path[i];
                }
                else {
                    p[i] = {
                        elementClass: OBJECT_CLASS.POINT,
                        X: makeFakeFunction(i, 0),
                        Y: makeFakeFunction(i, 1)
                    };
                }
            }
            time = time || 0;
            if (time === 0) {
                this.setPosition(COORDS_BY.USER, [
                    p[p.length - 1].X(),
                    p[p.length - 1].Y()
                ]);
                return this.board.update();
            }
            if (!Type.exists(options.interpolate) || options.interpolate) {
                neville = Numerics.Neville(p);
                for (i = 0; i < steps; i++) {
                    interpath[i] = [];
                    interpath[i][0] = neville[0](((steps - i) / steps) * neville[3]());
                    interpath[i][1] = neville[1](((steps - i) / steps) * neville[3]());
                }
            }
            else {
                len = path.length - 1;
                for (i = 0; i < steps; ++i) {
                    pos = Math.floor((i / steps) * len);
                    part = (i / steps) * len - pos;
                    interpath[i] = [];
                    interpath[i][0] = (1.0 - part) * p[pos].X() + part * p[pos + 1].X();
                    interpath[i][1] = (1.0 - part) * p[pos].Y() + part * p[pos + 1].Y();
                }
                interpath.push([p[len].X(), p[len].Y()]);
                interpath.reverse();
                /*
                for (i = 0; i < steps; i++) {
                    interpath[i] = [];
                    interpath[i][0] = path[Math.floor((steps - i) / steps * (path.length - 1))][0];
                    interpath[i][1] = path[Math.floor((steps - i) / steps * (path.length - 1))][1];
                }
                */
            }
            this.animationPath = interpath;
        }
        else if (Type.isFunction(path)) {
            this.animationPath = path;
            this.animationStart = new Date().getTime();
        }
        this.animationCallback = options.callback;
        this.board.addAnimation(this.element);
        return this;
    }
    /**
     * Starts an animated point movement towards the given coordinates <tt>where</tt>.
     * The animation is done after <tt>time</tt> milliseconds.
     * If the second parameter is not given or is equal to 0, setPosition() is called, see
     * {@link JXG.CoordsElement#setPosition}
     * i.e. the coordinates are changed without animation.
     * @param {Array} where Array containing the x and y coordinate of the target location.
     * @param {Number} [time] Number of milliseconds the animation should last.
     * @param {Object} [options] Optional settings for the animation
     * @param {function} [options.callback] A function that is called as soon as the animation is finished.
     * @param {String} [options.effect='<>'|'>'|'<'] animation effects like speed fade in and out. possible values are
     * '<>' for speed increase on start and slow down at the end (default), '<' for speed up, '>' for slow down, and '--' for constant speed during
     * the whole animation.
     * @returns {JXG.CoordsElement} Reference to itself.
     * @see JXG.CoordsElement#setPosition
     * @see JXG.CoordsElement#moveAlong
     * @see JXG.CoordsElement#visit
     * @see JXG.CoordsElement#moveToES6
     * @see JXG.GeometryElement#animate
     * @example
     * // moveTo() with different easing options and callback options
     * let yInit = 3
     * let [A, B, C, D] = ['==', '<>', '<', '>'].map((s) => board.create('point', [4, yInit--], { name: s, label: { fontSize: 24 } }))
     * let seg = board.create('segment', [A, [() => A.X(), 0]])  // shows linear
     *
     * let isLeftRight = true;
     * let buttonMove = board.create('button', [-2, 4, 'left',
     * () => {
     *    isLeftRight = !isLeftRight;
     *    buttonMove.rendNodeButton.innerHTML = isLeftRight ? 'left' : 'right'
     *    let x = isLeftRight ? 4 : -4
     *    let sym = isLeftRight ? 'triangleleft' : 'triangleright'
     *
     *    A.moveTo([x, 3], 1000, { callback: () => A.setAttribute({ face: sym, size: 5 }) })
     *    B.moveTo([x, 2], 1000, { callback: () => B.setAttribute({ face: sym, size: 5 }), effect: "<>" })
     *    C.moveTo([x, 1], 1000, { callback: () => C.setAttribute({ face: sym, size: 5 }), effect: "<" })
     *    D.moveTo([x, 0], 1000, { callback: () => D.setAttribute({ face: sym, size: 5 }), effect: ">" })
     *
     * }]);
     *
     * </pre><div id="JXG0f35a50e-e99d-11e8-a1ca-04d3b0c2aad4" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     * {
     * let board = JXG.JSXGraph.initBoard('JXG0f35a50e-e99d-11e8-a1ca-04d3b0c2aad4')
     * let yInit = 3
     * let [A, B, C, D] = ['==', '<>', '<', '>'].map((s) => board.create('point', [4, yInit--], { name: s, label: { fontSize: 24 } }))
     * let seg = board.create('segment', [A, [() => A.X(), 0]])  // shows linear
     *
     * let isLeftRight = true;
     * let buttonMove = board.create('button', [-2, 4, 'left',
     * () => {
     *    isLeftRight = !isLeftRight;
     *    buttonMove.rendNodeButton.innerHTML = isLeftRight ? 'left' : 'right'
     *    let x = isLeftRight ? 4 : -4
     *    let sym = isLeftRight ? 'triangleleft' : 'triangleright'
     *
     *    A.moveTo([x, 3], 1000, { callback: () => A.setAttribute({ face: sym, size: 5 }) })
     *    B.moveTo([x, 2], 1000, { callback: () => B.setAttribute({ face: sym, size: 5 }), effect: "<>" })
     *    C.moveTo([x, 1], 1000, { callback: () => C.setAttribute({ face: sym, size: 5 }), effect: "<" })
     *    D.moveTo([x, 0], 1000, { callback: () => D.setAttribute({ face: sym, size: 5 }), effect: ">" })
     *
     * }]);
     *}
     *</script><pre>
     */
    moveTo(where, time, options) {
        options = options || {};
        where = new Coords$1(COORDS_BY.USER, where, this.board);
        var i, delay = this.board.attr.animationdelay, steps = Math.ceil(time / delay), coords = [], X = this.coords.usrCoords[1], Y = this.coords.usrCoords[2], dX = where.usrCoords[1] - X, dY = where.usrCoords[2] - Y, 
        /** @ignore */
        stepFun = function (i) {
            var x = i / steps; // absolute progress of the animatin
            if (options.effect) {
                if (options.effect === "<>") {
                    return Math.pow(Math.sin((x * Math.PI) / 2), 2);
                }
                if (options.effect === "<") { // cubic ease in
                    return x * x * x;
                }
                if (options.effect === ">") { // cubic ease out
                    return 1 - Math.pow(1 - x, 3);
                }
                if (options.effect === "==") {
                    return i / steps; // linear
                }
                throw new Error("valid effects are '==', '<>', '>', and '<'.");
            }
            return i / steps; // default
        };
        if (!Type.exists(time) ||
            time === 0 ||
            Math.abs(where.usrCoords[0] - this.coords.usrCoords[0]) > JSXMath.eps) {
            this.setPosition(COORDS_BY.USER, where.usrCoords);
            return this.board.update();
        }
        // In case there is no callback and we are already at the endpoint we can stop here
        if (!Type.exists(options.callback) &&
            Math.abs(dX) < JSXMath.eps &&
            Math.abs(dY) < JSXMath.eps) {
            return this;
        }
        for (i = steps; i >= 0; i--) {
            coords[steps - i] = [
                where.usrCoords[0],
                X + dX * stepFun(i),
                Y + dY * stepFun(i)
            ];
        }
        this.animationPath = coords;
        this.animationCallback = options.callback;
        this.board.addAnimation(this);
        return this;
    }
    /**
     * Starts an animated point movement towards the given coordinates <tt>where</tt>. After arriving at
     * <tt>where</tt> the point moves back to where it started. The animation is done after <tt>time</tt>
     * milliseconds.
     * @param {Array} where Array containing the x and y coordinate of the target location.
     * @param {Number} time Number of milliseconds the animation should last.
     * @param {Object} [options] Optional settings for the animation
     * @param {function} [options.callback] A function that is called as soon as the animation is finished.
     * @param {String} [options.effect='<>'|'>'|'<'] animation effects like speed fade in and out. possible values are
     * '<>' for speed increase on start and slow down at the end (default), '<' for speed up, '>' for slow down, and '--' for constant speed during
     * the whole animation.
     * @param {Number} [options.repeat=1] How often this animation should be repeated.
     * @returns {JXG.CoordsElement} Reference to itself.
     * @see JXG.CoordsElement#moveAlong
     * @see JXG.CoordsElement#moveTo
     * @see JXG.CoordsElement#visitES6
     * @see JXG.GeometryElement#animate
     * @example
     * // visit() with different easing options
     * let yInit = 3
     * let [A, B, C, D] = ['==', '<>', '<', '>'].map((s) => board.create('point', [4, yInit--], { name: s, label: { fontSize: 24 } }))
     * let seg = board.create('segment', [A, [() => A.X(), 0]])  // shows linear
     *
     *let isLeftRight = true;
     *let buttonVisit = board.create('button', [0, 4, 'visit',
     *    () => {
     *        let x = isLeftRight ? 4 : -4
     *
     *        A.visit([-x, 3], 4000, { effect: "==", repeat: 2 })  // linear
     *        B.visit([-x, 2], 4000, { effect: "<>", repeat: 2 })
     *        C.visit([-x, 1], 4000, { effect: "<", repeat: 2 })
     *        D.visit([-x, 0], 4000, { effect: ">", repeat: 2 })
     *    }])
     *
     * </pre><div id="JXG0f35a50e-e99d-11e8-a1ca-04d3b0c2aad5" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     * {
     *  let board = JXG.JSXGraph.initBoard('JXG0f35a50e-e99d-11e8-a1ca-04d3b0c2aad5')
     * let yInit = 3
     * let [A, B, C, D] = ['==', '<>', '<', '>'].map((s) => board.create('point', [4, yInit--], { name: s, label: { fontSize: 24 } }))
     * let seg = board.create('segment', [A, [() => A.X(), 0]])  // shows linear
     *
     * let isLeftRight = true;
     * let buttonVisit = board.create('button', [0, 4, 'visit',
     *    () => {
     *        let x = isLeftRight ? 4 : -4
     *
     *        A.visit([-x, 3], 4000, { effect: "==", repeat: 2 })  // linear
     *        B.visit([-x, 2], 4000, { effect: "<>", repeat: 2 })
     *        C.visit([-x, 1], 4000, { effect: "<", repeat: 2 })
     *        D.visit([-x, 0], 4000, { effect: ">", repeat: 2 })
     *    }])
     *   }
     * </script><pre>
     *
     */
    visit(where, time, options) {
        where = new Coords$1(COORDS_BY.USER, where, this.board);
        var i, j, steps, delay = this.board.attr.animationdelay, coords = [], X = this.coords.usrCoords[1], Y = this.coords.usrCoords[2], dX = where.usrCoords[1] - X, dY = where.usrCoords[2] - Y, 
        /** @ignore */
        stepFun = function (i) {
            var x = i < steps / 2 ? (2 * i) / steps : (2 * (steps - i)) / steps;
            if (options.effect) {
                if (options.effect === "<>") { // slow at beginning and end
                    return Math.pow(Math.sin((x * Math.PI) / 2), 2);
                }
                if (options.effect === "<") { // cubic ease in
                    return x * x * x;
                }
                if (options.effect === ">") { // cubic ease out
                    return 1 - Math.pow(1 - x, 3);
                }
                if (options.effect === "==") {
                    return x; // linear
                }
                throw new Error("valid effects are '==', '<>', '>', and '<'.");
            }
            return x;
        };
        // support legacy interface where the third parameter was the number of repeats
        if (Type.isNumber(options)) {
            options = { repeat: options };
        }
        else {
            options = options || {};
            if (!Type.exists(options.repeat)) {
                options.repeat = 1;
            }
        }
        steps = Math.ceil(time / (delay * options.repeat));
        for (j = 0; j < options.repeat; j++) {
            for (i = steps; i >= 0; i--) {
                coords[j * (steps + 1) + steps - i] = [
                    where.usrCoords[0],
                    X + dX * stepFun(i),
                    Y + dY * stepFun(i)
                ];
            }
        }
        this.animationPath = coords;
        this.animationCallback = options.callback;
        this.board.addAnimation(this.element);
        return this;
    }
    /**
     * ES6 version of {@link JXG.CoordsElement#moveAlong} using a promise.
     *
     * @param {Array} where Array containing the x and y coordinate of the target location.
     * @param {Number} [time] Number of milliseconds the animation should last.
     * @param {Object} [options] Optional settings for the animation
     * @returns Promise
     * @see JXG.CoordsElement#moveAlong
     * @example
     * var A = board.create('point', [4, 4]);
     * A.moveAlongES6([[3, -2], [4, 0], [3, 1], [4, 4]], 2000)
     *     .then(() => A.moveToES6([-3, -3], 1000));
     *
     * </pre><div id="JXGa45032e5-a517-4f1d-868a-65d698d344cf" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGa45032e5-a517-4f1d-868a-65d698d344cf',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var A = board.create('point', [4, 4]);
     *     A.moveAlongES6([[3, -2], [4, 0], [3, 1], [4, 4]], 2000)
     *         .then(() => A.moveToES6([-3, -3], 1000));
     *
     *     })();
     *
     * </script><pre>
     *
     */
    moveAlongES6(path, time, options) {
        return new Promise((resolve, reject) => {
            if (Type.exists(options) && Type.exists(options.callback)) {
                options.callback = resolve;
            }
            else {
                options = {
                    callback: resolve
                };
            }
            this.moveAlong(path, time, options);
        });
    }
    /**
     * ES6 version of {@link JXG.CoordsElement#moveTo} using a promise.
     *
     * @param {Array} where Array containing the x and y coordinate of the target location.
     * @param {Number} [time] Number of milliseconds the animation should last.
     * @param {Object} [options] Optional settings for the animation
     * @returns Promise
     * @see JXG.CoordsElement#moveTo
     *
     * @example
     * var A = board.create('point', [4, 4]);
     * A.moveToES6([-3, 3], 1000)
     *     .then(() => A.moveToES6([-3, -3], 1000))
     *     .then(() => A.moveToES6([3, -3], 1000))
     *     .then(() => A.moveToES6([3, -3], 1000));
     *
     * </pre><div id="JXGabdc7771-34f0-4655-bb7b-fc329e773b89" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGabdc7771-34f0-4655-bb7b-fc329e773b89',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var A = board.create('point', [4, 4]);
     *     A.moveToES6([-3, 3], 1000)
     *         .then(() => A.moveToES6([-3, -3], 1000))
     *         .then(() => A.moveToES6([3, -3], 1000))
     *         .then(() => A.moveToES6([3, -3], 1000));
     *
     *     })();
     *
     * </script><pre>
     *
     * @example
     *         var A = board.create('point', [4, 4]);
     *         A.moveToES6([-3, 3], 1000)
     *             .then(function() {
     *                 return A.moveToES6([-3, -3], 1000);
     *             }).then(function() {
     *                 return A.moveToES6([ 3, -3], 1000);
     *             }).then(function() {
     *                 return A.moveToES6([ 3, -3], 1000);
     *             }).then(function() {
     *                 return A.moveAlongES6([[3, -2], [4, 0], [3, 1], [4, 4]], 5000);
     *             }).then(function() {
     *                 return A.visitES6([-4, -4], 3000);
     *             });
     *
     * </pre><div id="JXGa9439ce5-516d-4dba-9233-2a4ad9589995" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGa9439ce5-516d-4dba-9233-2a4ad9589995',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *             var A = board.create('point', [4, 4]);
     *             A.moveToES6([-3, 3], 1000)
     *                 .then(function() {
     *                     return A.moveToES6([-3, -3], 1000);
     *                 }).then(function() {
     *                     return A.moveToES6([ 3, -3], 1000);
     *                 }).then(function() {
     *                     return A.moveToES6([ 3, -3], 1000);
     *                 }).then(function() {
     *                     return A.moveAlongES6([[3, -2], [4, 0], [3, 1], [4, 4]], 5000);
     *                 }).then(function() {
     *                     return A.visitES6([-4, -4], 3000);
     *                 });
     *
     *     })();
     *
     * </script><pre>
     *
     */
    moveToES6(where, time, options) {
        return new Promise((resolve, reject) => {
            if (Type.exists(options) && Type.exists(options.callback)) {
                options.callback = resolve;
            }
            else {
                options = {
                    callback: resolve
                };
            }
            this.moveTo(where, time, options);
        });
    }
    /**
     * ES6 version of {@link JXG.CoordsElement#moveVisit} using a promise.
     *
     * @param {Array} where Array containing the x and y coordinate of the target location.
     * @param {Number} [time] Number of milliseconds the animation should last.
     * @param {Object} [options] Optional settings for the animation
     * @returns Promise
     * @see JXG.CoordsElement#visit
     * @example
     * var A = board.create('point', [4, 4]);
     * A.visitES6([-4, -4], 3000)
     *     .then(() => A.moveToES6([-3, 3], 1000));
     *
     * </pre><div id="JXG640f1fd2-05ec-46cb-b977-36d96648ce41" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG640f1fd2-05ec-46cb-b977-36d96648ce41',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var A = board.create('point', [4, 4]);
     *     A.visitES6([-4, -4], 3000)
     *         .then(() => A.moveToES6([-3, 3], 1000));
     *
     *     })();
     *
     * </script><pre>
     *
     */
    visitES6(where, time, options) {
        return new Promise((resolve, reject) => {
            if (Type.exists(options) && Type.exists(options.callback)) {
                options.callback = resolve;
            }
            else {
                options = {
                    callback: resolve
                };
            }
            this.visit(where, time, options);
        });
    }
    /**
     * Animates a glider. Is called by the browser after startAnimation is called.
     * @param {Number} direction The direction the glider is animated.
     * @param {Number} stepCount The number of steps in which the parent element is divided.
     * Must be at least 1.
     * @param {Number} [maxRounds=-1] The number of rounds the glider will be animated. The glider will run infinitely if
     * maxRounds is negative or equal to Infinity.
     * @see JXG.CoordsElement#startAnimation
     * @see JXG.CoordsElement#stopAnimation
     * @private
     * @returns {JXG.CoordsElement} Reference to itself.
     */
    _anim(direction, stepCount, maxRounds) {
        // TODO: move this to glider
        // this._intervalCount += 1;
        // if (this._intervalCount > stepCount) {
        //     this._intervalCount = 0;
        //     this._roundsCount += 1;
        //     if (maxRounds > 0 && this._roundsCount >= maxRounds) {
        //         this._roundsCount = 0;
        //         return this.stopAnimation();
        //     }
        // }
        // if (this.slideObject.elementClass === OBJECT_CLASS.LINE) {
        //     sp1c = this.slideObject.point1.coords.scrCoords;
        //     sp2c = this.slideObject.point2.coords.scrCoords;
        //     dX = Math.round(((sp2c[1] - sp1c[1]) * this._intervalCount) / stepCount);
        //     dY = Math.round(((sp2c[2] - sp1c[2]) * this._intervalCount) / stepCount);
        //     if (direction > 0) {
        //         startPoint = this.slideObject.point1;
        //     } else {
        //         startPoint = this.slideObject.point2;
        //         dX *= -1;
        //         dY *= -1;
        //     }
        //     this.coords.setCoordinates(COORDS_BY.SCREEN, [
        //         startPoint.coords.scrCoords[1] + dX,
        //         startPoint.coords.scrCoords[2] + dY
        //     ]);
        // } else if (this.slideObject.elementClass === OBJECT_CLASS.CURVE) {
        //     if (direction > 0) {
        //         newX = (this.slideObject.maxX() - this.slideObject.minX()) * this._intervalCount / stepCount + this.slideObject.minX();
        //     } else {
        //         newX = -(this.slideObject.maxX() - this.slideObject.minX()) * this._intervalCount / stepCount + this.slideObject.maxX();
        //     }
        //     this.coords.setCoordinates(COORDS_BY.USER, [this.slideObject.X(newX), this.slideObject.Y(newX)]);
        //     res = Geometry.projectPointToCurve(this, this.slideObject, this.board);
        //     this.coords = res[0];
        //     this.position = res[1];
        // } else if (this.slideObject.elementClass === OBJECT_CLASS.CIRCLE) {
        //     alpha = 2 * Math.PI;
        //     if (direction < 0) {
        //         alpha *= this._intervalCount / stepCount;
        //     } else {
        //         alpha *= (stepCount - this._intervalCount) / stepCount;
        //     }
        //     radius = this.slideObject.Radius();
        //     this.coords.setCoordinates(COORDS_BY.USER, [
        //         this.slideObject.center.coords.usrCoords[1] + radius * Math.cos(alpha),
        //         this.slideObject.center.coords.usrCoords[2] + radius * Math.sin(alpha)
        //     ]);
        // }
        // this.board.update(this);
        return this;
    }
    // documented in GeometryElement
    getTextAnchor() {
        return this.coords;
    }
    // documented in GeometryElement
    getLabelAnchor() {
        return this.coords;
    }
    // documented in element.js
    getParents() {
        var p = [this.Z(), this.X(), this.Y()];
        if (this.parents.length !== 0) {
            p = this.parents;
        }
        // TODO: move to glider
        // if (this.type === OBJECT_TYPE.GLIDER) {
        //     p = [this.X(), this.Y(), this.slideObject.id];
        // }
        return p;
    }
    /**
     * Generic method to create point, text or image.
     * Determines the type of the construction, i.e. free, or constrained by function,
     * transformation or of glider type.
     * @param{Object} Callback Object type, e.g. JXG.Point, JXG.Text or JXG.Image
     * @param{Object} board Link to the board object
     * @param{Array} coords Array with coordinates. This may be: array of numbers, function
     * returning an array of numbers, array of functions returning a number, object and transformation.
     * If the attribute "slideObject" exists, a glider element is constructed.
     * @param{Object} attr Attributes object
     * @param{Object} arg1 Optional argument 1: in case of text this is the text content,
     * in case of an image this is the url.
     * @param{Array} arg2 Optional argument 2: in case of image this is an array containing the size of
     * the image.
     * @returns{Object} returns the created object or false.
     */
    create(Callback, board, coords, attr, arg1, arg2) {
        var el, isConstrained = false, i;
        for (i = 0; i < coords.length; i++) {
            if (Type.isFunction(coords[i]) || Type.isString(coords[i])) {
                isConstrained = true;
            }
        }
        if (!isConstrained) {
            if (Type.isNumber(coords[0]) && Type.isNumber(coords[1])) {
                el = new Callback(board, coords, attr, arg1, arg2);
                if (Type.exists(attr.slideobject)) {
                    el.makeGlider(attr.slideobject);
                }
                else {
                    // Free element
                    el.baseElement = el;
                }
                el.isDraggable = true;
            }
            else if (Type.isObject(coords[0]) && Type.isTransformationOrArray(coords[1])) {
                // Transformation
                // TODO less general specification of isObject
                el = new Callback(board, [0, 0], attr, arg1, arg2);
                el.addTransform(coords[0], coords[1]);
                el.isDraggable = false;
            }
            else {
                return false;
            }
        }
        else {
            el = new Callback(board, [0, 0], attr, arg1, arg2);
            el.addConstraint(coords);
        }
        el.handleSnapToGrid();
        el.handleSnapToPoints();
        el.handleAttractors();
        el.addParents(coords);
        return el;
    }
}

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */
/*
    Some functionalities in this file were developed as part of a software project
    with students. We would like to thank all contributors for their help:

    Winter semester 2024/2025:
        Philipp Ditz,
        Florian Hein,
        Pirmin Hinderling,
        Tim Sauer
 */
/*global JXG: true, define: true, window: true*/
/*jslint nomen: true, plusplus: true*/
/**
 * @fileoverview In this file the Text element is defined.
 */
/**
 * Construct and handle texts.
 *
 * The coordinates can be relative to the coordinates of an element
 * given in {@link JXG.Options#text.anchor}.
 *
 * MathJax, HTML and GEONExT syntax can be handled.
 * @class Creates a new text object. Do not use this constructor to create a text. Use {@link JXG.Board#create} with
 * type {@link Text} instead.
 * @augments JXG.GeometryElement
 * @augments JXG.CoordsElement
 * @param {string|JXG.Board} board The board the new text is drawn on.
 * @param {Array} coordinates An array with the user coordinates of the text.
 * @param {Object} attributes An object containing visual properties and optional a name and a id.
 * @param {string|function} content A string or a function returning a string.
 *
 */
class Text extends CoordsElement {
    constructor(board, coordinates, attributes, content) {
        super(board, COORDS_BY.USER, coordinates, attributes);
        this.content = "";
        this.plaintext = "";
        this.plaintextOld = '';
        this.orgText = "";
        this.size = [1.0, 1.0];
        this.updateText = () => console.warn('updateText not set');
        this.elType = "text";
        this.visProp = Type.merge(this.visProp, Options);
        this.relativeCoords = new Coords$1(COORDS_BY.USER, coordinates, board);
        // this.setCoordinates(this.method, coordinates, false, true);
        /**
         * Type of the element.
         * @constant
         * @type Number
            */
        this.otype = OBJECT_TYPE.TEXT;
        /**
         * Original type of the element at construction time. Used for removing glider property.
         * @constant
         * @type Number
        */
        this._org_type = OBJECT_TYPE.TEXT;
        /**
         * The element's class.
         * @constant
         * @type Number
        */
        this.oclass = OBJECT_CLASS.TEXT;
        let tmp;
        // TODO: what was this ???
        //this.element = this.board.select(attributes.anchor);
        // this.coordsConstructor(coords, this.evalVisProp('islabel'));
        this.content = "";
        this.plaintext = "";
        this.plaintextOld = "";
        this.orgText = "";
        this.needsSizeUpdate = false;
        // Only used by infobox anymore
        this.hiddenByParent = false;
        /**
         * Width and height of the text element in pixel.
         *
         * @private
         * @type Array
         */
        this.size = [1.0, 1.0];
        this.id = this.board.setId(this, "T");
        this.rendNode = this.board.renderer.drawText(this);
        this.board.finalizeAdding(this);
        // Set text before drawing
        // this._createFctUpdateText(content);
        // this.updateText();
        // Set attribute visible to true. This is necessary to
        // create all sub-elements for button, input and checkbox
        tmp = this.visProp.visible;
        this.visProp.visible = true;
        this.setText(content);
        // Restore the correct attribute visible.
        this.visProp.visible = tmp;
        if (Type.isString(this.content)) {
            this.notifyParents(this.content);
        }
        this.elType = "text";
        this.methodMap = Type.deepCopy(this.methodMap, {
            setText: "setTextJessieCode",
            // free: 'free',
            move: "setCoords",
            Size: "getSize",
            setAutoPosition: "setAutoPosition"
        });
    }
    /**
     * @private
     * @param {Number} x
     * @param {Number} y
     * @returns {Boolean}
    */
    // Test if the screen coordinates (x,y) are in a small stripe
    // at the left side or at the right side of the text.
    // Sensitivity is set in this.board.options.precision.hasPoint.
    // If dragarea is set to 'all' (default), tests if the screen
    // coordinates (x,y) are in within the text boundary.
    hasPoint(x, y) {
        var lft, rt, top, bot, ax, ay, type, r;
        if (Type.isObject(this.evalVisProp('precision'))) {
            type = this.board._inputDevice;
            r = this.evalVisProp('precision.' + type);
        }
        else {
            // 'inherit'
            r = Options.precision.hasPoint;
        }
        if (this.transformations.length > 0) {
            //Transform the mouse/touch coordinates
            // back to the original position of the text.
            lft = JSXMath.matVecMult(JSXMath.inverse(this.board.renderer.joinTransforms(this, this.transformations)), [1, x, y]);
            x = lft[1];
            y = lft[2];
        }
        ax = this.getAnchorX();
        if (ax === "right") {
            lft = this.coords.scrCoords[1] - this.size[0];
        }
        else if (ax === "middle") {
            lft = this.coords.scrCoords[1] - 0.5 * this.size[0];
        }
        else {
            lft = this.coords.scrCoords[1];
        }
        rt = lft + this.size[0];
        ay = this.getAnchorY();
        if (ay === "top") {
            bot = this.coords.scrCoords[2] + this.size[1];
        }
        else if (ay === "middle") {
            bot = this.coords.scrCoords[2] + 0.5 * this.size[1];
        }
        else {
            bot = this.coords.scrCoords[2];
        }
        top = bot - this.size[1];
        if (this.evalVisProp('dragarea') === "all") {
            return x >= lft - r && x < rt + r && y >= top - r && y <= bot + r;
        }
        // e.g. 'small'
        return (y >= top - r &&
            y <= bot + r &&
            ((x >= lft - r && x <= lft + 2 * r) || (x >= rt - 2 * r && x <= rt + r)));
    }
    /**
     * This sets the updateText function of this element depending on the type of text content passed.
     * Used by {@link JXG.Text#_setText}.
     * @param {String|Function|Number} text
     * @private
     * @see JXG.Text#_setText
     */
    _createFctUpdateText(text) {
        var digits, resolvedText, ev_p = this.evalVisProp('parse'), ev_um = this.evalVisProp('usemathjax'), ev_uk = this.evalVisProp('usekatex');
        this.orgText = text;
        if (Type.isFunction(text)) {
            /**
             * Dynamically created function to update the content
             * of a text. Can not be overwritten.
             * <p>
             * &lt;value&gt; tags will not be evaluated if text is provided by a function
             * <p>
             * Sets the property <tt>plaintext</tt> of the text element.
             *
             * @private
             */
            this.updateText = function () {
                resolvedText = text().toString(); // Evaluate function
                if (ev_p && !ev_um && !ev_uk) {
                    this.plaintext = this.replaceSub(this.replaceSup(this.convertGeonextAndSketchometry2CSS(resolvedText, false)));
                }
                else {
                    this.plaintext = resolvedText;
                }
            };
        }
        else {
            if (Type.isNumber(text) && this.evalVisProp('formatnumber')) {
                if (this.evalVisProp('tofraction')) {
                    if (ev_um) {
                        this.content = '\\(' + Type.toFraction(text, true) + '\\)';
                    }
                    else {
                        this.content = Type.toFraction(text, ev_uk);
                    }
                }
                else {
                    digits = this.evalVisProp('digits');
                    if (this.useLocale()) {
                        this.content = this.formatNumberLocale(text, digits);
                    }
                    else {
                        this.content = Type.toFixed(text, digits);
                    }
                }
            }
            else if (Type.isString(text) && ev_p) {
                if (this.evalVisProp('useasciimathml')) {
                    // ASCIIMathML
                    // value-tags are not supported
                    this.content = "'`" + text + "`'";
                }
                else if (ev_um || ev_uk) {
                    // MathJax or KaTeX
                    // Replace value-tags by functions
                    // sketchofont is ignored
                    this.content = 'Find this error! 328'; // TODO: this.valueTagToJessieCode(text);
                    if (!Array.isArray(this.content)) {
                        // For some reason we don't have to mask backslashes in an array of strings
                        // anymore.
                        //
                        // for (i = 0; i < this.content.length; i++) {
                        //     this.content[i] = this.content[i].replace(/\\/g, "\\\\"); // Replace single backslash by double
                        // }
                        // } else {
                        this.content = this.content.replace(/\\/g, "\\\\"); // Replace single backslash by double
                    }
                }
                else {
                    // No TeX involved.
                    // Converts GEONExT syntax into JavaScript string
                    // Short math is allowed
                    // Replace value-tags by functions
                    // Avoid geonext2JS calls
                    this.content = this.poorMansTeX(this.valueTagToJessieCode(text));
                }
            }
            else {
                this.content = text;
            }
            // // Generate function which returns the text to be displayed
            // if (convertJessieCode) {
            //     // Convert JessieCode to JS function
            //     if (Array.isArray(this.content)) {
            //         // This is the case if the text contained value-tags.
            //         // These value-tags consist of JessieCode snippets
            //         // which are now replaced by JavaScript functions
            //         that = this;
            //         for (i = 0; i < this.content.length; i++) {
            //             if (this.content[i][0] !== '"') {
            //                 // TODO: GEONEXT ??  // this.content[i] = this.board.jc.snippet(this.content[i], true, "", false);
            //                 for (e in this.content[i].deps) {
            //                     this.addParents(this.content[i].deps[e]);
            //                     this.content[i].deps[e].addChild(this);
            //                 }
            //             }
            //         }
            //         updateText = function () {
            //             var i, t,
            //                 digits = that.evalVisProp('digits'),
            //                 txt = '';
            //             for (i = 0; i < that.content.length; i++) {
            //                 if (Type.isFunction(that.content[i])) {
            //                     t = that.content[i]();
            //                     if (that.useLocale()) {
            //                         t = that.formatNumberLocale(t, digits);
            //                     } else {
            //                         t = Type.toFixed(t, digits);
            //                     }
            //                 } else {
            //                     t = that.content[i];
            //                     // Instead of 't.at(t.length - 1)' also 't.(-1)' should work.
            //                     // However in Moodle 4.2 't.(-1)' returns an empty string.
            //                     // In plain HTML pages it works.
            //                     if (t[0] === '"' && t[t.length - 1] === '"') {
            //                         t = t.slice(1, -1);
            //                     }
            //                 }
            //                 txt += t;
            //             }
            //             return txt;
            //         };
            //     } else {
            //         // TODO: GEONEXT ??  // updateText = this.board.jc.snippet(this.content, true, "", false);
            //         // for (e in updateText.deps) {
            //         //     this.addParents(updateText.deps[e]);
            //         //     updateText.deps[e].addChild(this);
            //         // }
            //     }
            //     // Ticks have been escaped in valueTagToJessieCode
            //     this.updateText = function () {
            //         this.plaintext = this.unescapeTicks(updateText());
            //     };
            // } else {
            this.updateText = function () {
                this.plaintext = this.content; // text;
            };
            // }
        }
    }
    /**
     * Defines new content. This is used by {@link JXG.Text#setTextJessieCode} and {@link JXG.Text#setText}. This is required because
     * JessieCode needs to filter all Texts inserted into the DOM and thus has to replace setText by setTextJessieCode.
     * @param {String|Function|Number} text
     * @returns {JXG.Text}
     * @private
     */
    _setText(text) {
        this._createFctUpdateText(text);
        // First evaluation of the string.
        // We need this for display='internal' and Canvas
        this.updateText();
        this.fullUpdate();
        // We do not call updateSize for the infobox to speed up rendering
        if (!this.board.infobox || this.id !== this.board.infobox.id) {
            this.updateSize(); // updateSize() is called at least once.
        }
        // This may slow down canvas renderer
        // if (this.board.renderer.type === 'canvas') {
        //     this.board.fullUpdate();
        // }
        return this;
    }
    /**
     * Defines new content but converts &lt; and &gt; to HTML entities before updating the DOM.
     * @param {String|function} text
     */
    setTextJessieCode(text) {
        var s;
        this.visProp.castext = text;
        if (Type.isFunction(text)) {
            s = function () {
                return Type.sanitizeHTML(text());
            };
        }
        else {
            if (Type.isNumber(text)) {
                s = text;
            }
            else {
                s = Type.sanitizeHTML(text);
            }
        }
        return this._setText(s);
    }
    /**
     * Defines new content.
     * @param {String|function} text
     * @returns {JXG.Text} Reference to the text object.
     */
    setText(text) {
        return this._setText(text);
    }
    /**
     * Recompute the width and the height of the text box.
     * Updates the array {@link JXG.Text#size} with pixel values.
     * The result may differ from browser to browser
     * by some pixels.
     * In canvas an old IEs we use a very crude estimation of the dimensions of
     * the textbox.
     * JSXGraph needs {@link JXG.Text#size} for applying rotations in IE and
     * for aligning text.
     *
     * @return {this} [description]
     */
    updateSize() {
        var tmp, that, node, ev_d = this.evalVisProp('display');
        if (!Env.isBrowser || this.board.renderer.type === "no") {
            return this;
        }
        node = this.rendNode;
        if (node === undefined) {
            console.warn('Text node is undefined');
            return this;
        }
        else {
            console.warn('node', node);
        }
        // offsetWidth and offsetHeight seem to be supported for internal vml elements by IE10+ in IE8 mode.
        if (ev_d === "html") {
            if (Type.exists(node.offsetWidth)) {
                that = this;
                window.setTimeout(function () {
                    that.size = [node.offsetWidth, node.offsetHeight];
                    that.needsUpdate = true;
                    that.updateRenderer();
                }, 0);
                // In case, there is non-zero padding or borders
                // the following approach does not longer work.
                // s = [node.offsetWidth, node.offsetHeight];
                // if (s[0] === 0 && s[1] === 0) { // Some browsers need some time to set offsetWidth and offsetHeight
                //     that = this;
                //     window.setTimeout(function () {
                //         that.size = [node.offsetWidth, node.offsetHeight];
                //         that.needsUpdate = true;
                //         that.updateRenderer();
                //     } 0);
                // } else {
                //     this.size = s;
                // }
            }
            else {
                this.size = this.crudeSizeEstimate();
            }
        }
        else if (ev_d === "internal") {
            if (this.board.renderer.type === "svg") {
                that = this;
                window.setTimeout(function () {
                    try {
                        // TODO ?? tmp = node.getBBox();
                        that.size = [tmp.width, tmp.height];
                        that.needsUpdate = true;
                        that.updateRenderer();
                    }
                    catch (e) { }
                }, 0);
            }
            else if (this.board.renderer.type === "canvas") {
                this.size = this.crudeSizeEstimate();
            }
        }
        return this;
    }
    /**
     * A very crude estimation of the dimensions of the textbox in case nothing else is available.
     * @returns {Array}
     */
    crudeSizeEstimate() {
        var ev_fs = parseFloat(this.evalVisProp('fontsize'));
        return [ev_fs * this.plaintext.length * 0.45, ev_fs * 0.9];
    }
    /**
     * Decode unicode entities into characters.
     * @param {String} string
     * @returns {String}
     */
    utf8_decode(string) {
        return string.replace(/&#x(\w+);/g, function (m, p1) {
            return String.fromCharCode(parseInt(p1, 16));
        });
    }
    /**
     * Replace _{} by &lt;sub&gt;
     * @param {String} te String containing _{}.
     * @returns {String} Given string with _{} replaced by &lt;sub&gt;.
     */
    replaceSub(te) {
        if (!te.indexOf) {
            return te;
        }
        var j, i = te.indexOf("_{");
        // The regexp in here are not used for filtering but to provide some kind of sugar for label creation,
        // i.e. replacing _{...} with <sub>...</sub>. What is passed would get out anyway.
        /*jslint regexp: true*/
        while (i >= 0) {
            te = te.slice(0, i) + te.slice(i).replace(/_\{/, "<sub>");
            j = te.indexOf("}", i + 4);
            if (j >= 0) {
                te = te.slice(0, j) + te.slice(j).replace(/\}/, "</sub>");
            }
            i = te.indexOf("_{");
        }
        i = te.indexOf("_");
        while (i >= 0) {
            te = te.slice(0, i) + te.slice(i).replace(/_(.?)/, "<sub>$1</sub>");
            i = te.indexOf("_");
        }
        return te;
    }
    /**
     * Replace ^{} by &lt;sup&gt;
     * @param {String} te String containing ^{}.
     * @returns {String} Given string with ^{} replaced by &lt;sup&gt;.
     */
    replaceSup(te) {
        if (!te.indexOf) {
            return te;
        }
        var j, i = te.indexOf("^{");
        // The regexp in here are not used for filtering but to provide some kind of sugar for label creation,
        // i.e. replacing ^{...} with <sup>...</sup>. What is passed would get out anyway.
        /*jslint regexp: true*/
        while (i >= 0) {
            te = te.slice(0, i) + te.slice(i).replace(/\^\{/, "<sup>");
            j = te.indexOf("}", i + 4);
            if (j >= 0) {
                te = te.slice(0, j) + te.slice(j).replace(/\}/, "</sup>");
            }
            i = te.indexOf("^{");
        }
        i = te.indexOf("^");
        while (i >= 0) {
            te = te.slice(0, i) + te.slice(i).replace(/\^(.?)/, "<sup>$1</sup>");
            i = te.indexOf("^");
        }
        return te;
    }
    /**
     * Return the width of the text element.
     * @returns {Array} [width, height] in pixel
     */
    getSize() {
        return this.size;
    }
    /**
     * Move the text to new coordinates.
     * @param {number} x
     * @param {number} y
     * @returns {object} reference to the text object.
     */
    setCoords(x, y) {
        var coordsAnchor, dx, dy;
        if (Array.isArray(x) && x.length > 1) {
            y = x[1];
            x = x[0];
        }
        if (this.evalVisProp('islabel') && Type.exists(this.element)) {
            coordsAnchor = this.getLabelAnchor();
            dx = (x - coordsAnchor.usrCoords[1]) * this.board.unitX;
            dy = -(y - coordsAnchor.usrCoords[2]) * this.board.unitY;
            this.relativeCoords.setCoordinates(COORDS_BY.SCREEN, [dx, dy]);
        }
        else {
            this.coords.setCoordinates(COORDS_BY.USER, [x, y]);
        }
        // this should be a local update, otherwise there might be problems
        // with the tick update routine resulting in orphaned tick labels
        this.fullUpdate();
        return this;
    }
    /**
     * Evaluates the text.
     * Then, the update function of the renderer
     * is called.
     */
    update(fromParent) {
        if (!this.needsUpdate) {
            return this;
        }
        this.updateCoords(fromParent);
        this.updateText();
        if (this.evalVisProp('display') === "internal") {
            if (Type.isString(this.plaintext)) {
                this.plaintext = this.utf8_decode(this.plaintext);
            }
        }
        this.checkForSizeUpdate();
        if (this.needsSizeUpdate) {
            this.updateSize();
        }
        return this;
    }
    /**
     * Used to save updateSize() calls.
     * Called in JXG.Text.update
     * That means this.update() has been called.
     * More tests are in JXG.Renderer.updateTextStyle. The latter tests
     * are one update off. But this should pose not too many problems, since
     * it affects fontSize and cssClass changes.
     *
     * @private
     */
    checkForSizeUpdate() {
        if (this.board.infobox && this.id === this.board.infobox.id) {
            this.needsSizeUpdate = false;
        }
        else {
            // For some magic reason it is more efficient on the iPad to
            // call updateSize() for EVERY text element EVERY time.
            this.needsSizeUpdate = this.plaintextOld !== this.plaintext;
            if (this.needsSizeUpdate) {
                this.plaintextOld = this.plaintext;
            }
        }
    }
    /**
     * The update function of the renderer
     * is called.
     * @private
     */
    updateRenderer() {
        if (
        //this.board.updateQuality === this.board.BOARD_QUALITY_HIGH &&
        this.evalVisProp('autoposition')) {
            this.setAutoPosition().updateConstraint();
        }
        return this.updateRendererGeneric("updateText");
    }
    /**
     * Converts shortened math syntax into correct syntax:  3x instead of 3*x or
     * (a+b)(3+1) instead of (a+b)*(3+1).
     *
     * @private
     * @param{String} expr Math term
     * @returns {string} expanded String
     */
    expandShortMath(expr) {
        var re = /([)0-9.])\s*([(a-zA-Z_])/g;
        return expr.replace(re, "$1*$2");
    }
    /**
     * Converts the GEONExT syntax of the <value> terms into JavaScript.
     * Also, all Objects whose name appears in the term are searched and
     * the text is added as child to these objects.
     * This method is called if the attribute parse==true is set.
     *
     * Obsolete, replaced by JXG.Text.valueTagToJessieCode
     *
     * @param{String} contentStr String to be parsed
     * @param{Boolean} [expand] Optional flag if shortened math syntax is allowed (e.g. 3x instead of 3*x).
     * @param{Boolean} [avoidGeonext2JS] Optional flag if geonext2JS should be called. For backwards compatibility
     * this has to be set explicitly to true.
     * @param{Boolean} [outputTeX] Optional flag which has to be true if the resulting term will be sent to MathJax or KaTeX.
     * If true, "_" and "^" are NOT replaced by HTML tags sub and sup. Default: false, i.e. the replacement is done.
     * This flag allows the combination of &lt;value&gt; tag containing calculations with TeX output.
     *
     * @deprecated
     * @private
     * @see JXG.GeonextParser#geonext2JS
     * @see JXG.Text#valueTagToJessieCode
     *
     */
    generateTerm(contentStr, expand, avoidGeonext2JS) {
        var res, term, i, j, plaintext = '""';
        // Revert possible jc replacement
        contentStr = contentStr || "";
        contentStr = contentStr.replace(/\r/g, "");
        contentStr = contentStr.replace(/\n/g, "");
        contentStr = contentStr.replace(/"/g, "'");
        contentStr = contentStr.replace(/'/g, "\\'");
        // Old GEONExT syntax, not (yet) supported as TeX output.
        // Otherwise, the else clause should be used.
        // That means, i.e. the <arc> tag and <sqrt> tag are not
        // converted into TeX syntax.
        contentStr = contentStr.replace(/&amp;arc;/g, "&ang;");
        contentStr = contentStr.replace(/<arc\s*\/>/g, "&ang;");
        contentStr = contentStr.replace(/&lt;arc\s*\/&gt;/g, "&ang;");
        contentStr = contentStr.replace(/&lt;sqrt\s*\/&gt;/g, "&radic;");
        contentStr = contentStr.replace(/&lt;value&gt;/g, "<value>");
        contentStr = contentStr.replace(/&lt;\/value&gt;/g, "</value>");
        // Convert GEONExT syntax into  JavaScript syntax
        i = contentStr.indexOf("<value>");
        j = contentStr.indexOf("</value>");
        if (i >= 0) {
            while (i >= 0) {
                plaintext +=
                    ' + "' + this.replaceSub(this.replaceSup(contentStr.slice(0, i))) + '"';
                // plaintext += ' + "' + this.replaceSub(contentStr.slice(0, i)) + '"';
                term = contentStr.slice(i + 7, j);
                term = term.replace(/\s+/g, ""); // Remove all whitespace
                if (expand === true) {
                    term = this.expandShortMath(term);
                }
                if (avoidGeonext2JS) {
                    res = term;
                }
                res = res.replace(/\\"/g, "'");
                res = res.replace(/\\'/g, "'");
                // GEONExT-Hack: apply rounding once only.
                if (res.indexOf("toFixed") < 0) {
                    // output of a value tag
                    // if (
                    //     Type.isNumber(
                    //         // TODO: GEONEXT ??  //  Type.bind(this.board.jc.snippet(res, true, '', false), this)()
                    //     )
                    // ) {
                    //     // may also be a string
                    //     plaintext += '+(' + res + ').toFixed(' + this.evalVisProp('digits') + ')';
                    // } else {
                    plaintext += '+(' + res + ')';
                    // }
                }
                else {
                    plaintext += '+(' + res + ')';
                }
                contentStr = contentStr.slice(j + 8);
                i = contentStr.indexOf("<value>");
                j = contentStr.indexOf("</value>");
            }
        }
        plaintext += ' + "' + this.replaceSub(this.replaceSup(contentStr)) + '"';
        plaintext = this.convertGeonextAndSketchometry2CSS(plaintext);
        // This should replace e.g. &amp;pi; by &pi;
        plaintext = plaintext.replace(/&amp;/g, "&");
        plaintext = plaintext.replace(/"/g, "'");
        return plaintext;
    }
    /**
     * Replace value-tags in string by JessieCode functions.
     * @param {String} contentStr
     * @returns String
     * @private
     * @example
     * "The x-coordinate of A is &lt;value&gt;X(A)&lt;/value&gt;"
     *
     */
    valueTagToJessieCode(contentStr) {
        var res, term, i, j, textComps = [], tick = '"';
        contentStr = contentStr || "";
        contentStr = contentStr.replace(/\r/g, "");
        contentStr = contentStr.replace(/\n/g, "");
        contentStr = contentStr.replace(/&lt;value&gt;/g, "<value>");
        contentStr = contentStr.replace(/&lt;\/value&gt;/g, "</value>");
        // Convert content of value tag (GEONExT/JessieCode) syntax into JavaScript syntax
        i = contentStr.indexOf("<value>");
        j = contentStr.indexOf("</value>");
        if (i >= 0) {
            while (i >= 0) {
                // Add string fragment before <value> tag
                textComps.push(tick + this.escapeTicks(contentStr.slice(0, i)) + tick);
                term = contentStr.slice(i + 7, j);
                term = term.replace(/\s+/g, ""); // Remove all whitespace
                {
                    term = this.expandShortMath(term);
                }
                res = term;
                res = res.replace(/\\"/g, "'").replace(/\\'/g, "'");
                // // Hack: apply rounding once only.
                // if (res.indexOf("toFixed") < 0) {
                //     // Output of a value tag
                //     // Run the JessieCode parser
                //     if (
                //         Type.isNumber(
                //             Type.bind(this.board.jc.snippet(res, true, "", false), this)()
                //         )
                //     ) {
                //         // Output is number
                //         // textComps.push(
                //         //     '(' + res + ').toFixed(' + this.evalVisProp('digits') + ')'
                //         // );
                //         textComps.push('(' + res + ')');
                //     } else {
                //         // Output is a string
                //         textComps.push("(" + res + ")");
                //     }
                // } else {
                textComps.push("(" + res + ")");
                // }
                contentStr = contentStr.slice(j + 8);
                i = contentStr.indexOf("<value>");
                j = contentStr.indexOf("</value>");
            }
        }
        // Add trailing string fragment
        textComps.push(tick + this.escapeTicks(contentStr) + tick);
        // return textComps.join(" + ").replace(/&amp;/g, "&");
        for (i = 0; i < textComps.length; i++) {
            textComps[i] = textComps[i].replace(/&amp;/g, "&");
        }
        return textComps;
    }
    /**
     * Simple math rendering using HTML / CSS only. In case of array,
     * handle each entry separately and return array with the
     * rendering strings.
     *
     * @param {String|Array} s
     * @returns {String|Array}
     * @see JXG.Text#convertGeonextAndSketchometry2CSS
     * @private
     * @see JXG.Text#replaceSub
     * @see JXG.Text#replaceSup
     * @see JXG.Text#convertGeonextAndSketchometry2CSS
     */
    poorMansTeX(s) {
        var i, a;
        if (Array.isArray(s)) {
            a = [];
            for (i = 0; i < s.length; i++) {
                a.push(this.poorMansTeX(s[i]));
            }
            return a;
        }
        s = s
            .replace(/<arc\s*\/*>/g, "&ang;")
            .replace(/&lt;arc\s*\/*&gt;/g, "&ang;")
            .replace(/<sqrt\s*\/*>/g, "&radic;")
            .replace(/&lt;sqrt\s*\/*&gt;/g, "&radic;");
        return this.convertGeonextAndSketchometry2CSS(this.replaceSub(this.replaceSup(s)), true);
    }
    /**
     * Replace ticks by URI escape sequences
     *
     * @param {String} s
     * @returns String
     * @private
     *
     */
    escapeTicks(s) {
        return s.replace(/"/g, "%22").replace(/'/g, "%27");
    }
    /**
     * Replace escape sequences for ticks by ticks
     *
     * @param {String} s
     * @returns String
     * @private
     */
    unescapeTicks(s) {
        return s.replace(/%22/g, '"').replace(/%27/g, "'");
    }
    /**
     * Converts the GEONExT tags <overline> and <arrow> to
     * HTML span tags with proper CSS formatting.
     * @private
     * @see JXG.Text.poorMansTeX
     * @see JXG.Text._setText
     */
    convertGeonext2CSS(s) {
        if (Type.isString(s)) {
            s = s.replace(/(<|&lt;)overline(>|&gt;)/g, "<span style=text-decoration:overline;>");
            s = s.replace(/(<|&lt;)\/overline(>|&gt;)/g, "</span>");
            s = s.replace(/(<|&lt;)arrow(>|&gt;)/g, "<span style=text-decoration:overline;>");
            s = s.replace(/(<|&lt;)\/arrow(>|&gt;)/g, "</span>");
        }
        return s;
    }
    /**
     * Converts the sketchometry tag <sketchofont> to
     * HTML span tags with proper CSS formatting.
     *
     * @param {String|Function|Number} s Text
     * @param {Boolean} escape Flag if ticks should be escaped. Escaping is necessary
     * if s is a text. It has to be avoided if s is a function returning text.
     * @private
     * @see JXG.Text._setText
     * @see JXG.Text.convertGeonextAndSketchometry2CSS
     *
     */
    convertSketchometry2CSS(s, escape) {
        var t1 = "<span class=\"sketcho sketcho-inherit sketcho-", t2 = "\"></span>";
        if (Type.isString(s)) {
            if (escape) {
                t1 = this.escapeTicks(t1);
                t2 = this.escapeTicks(t2);
            }
            s = s.replace(/(<|&lt;)sketchofont(>|&gt;)/g, t1);
            s = s.replace(/(<|&lt;)\/sketchofont(>|&gt;)/g, t2);
        }
        return s;
    }
    /**
     * Alias for convertGeonext2CSS and convertSketchometry2CSS
     *
     * @param {String|Function|Number} s Text
     * @param {Boolean} escape Flag if ticks should be escaped
     * @private
     * @see JXG.Text.convertGeonext2CSS
     * @see JXG.Text.convertSketchometry2CSS
     */
    convertGeonextAndSketchometry2CSS(s, escape = false) {
        s = this.convertGeonext2CSS(s);
        s = this.convertSketchometry2CSS(s, escape);
        return s;
    }
    /**
     * Finds dependencies in a given term and notifies the parents by adding the
     * dependent object to the found objects child elements.
     * @param {String} content String containing dependencies for the given object.
     * @private
     */
    notifyParents(content) {
        // TODO what is GEONEXT ??
        // // revert possible jc replacement
        // content = content.replace(/&lt;value&gt;/g, "<value>");
        // content = content.replace(/&lt;\/value&gt;/g, "</value>");
        // do {
        //     search = /<value>([\w\s*/^\-+()[\],<>=!]+)<\/value>/;
        //     res = search.exec(content);
        //     if (res !== null) {
        //         GeonextParser.findDependencies(this, res[1], this.board);
        //         content = content.slice(res.index);
        //         content = content.replace(search, "");
        //     }
        // } while (res !== null);
        return this;
    }
    // documented in element.js
    getParents() {
        var p;
        if (this.relativeCoords !== undefined) {
            // Texts with anchor elements, excluding labels
            p = [
                this.relativeCoords.usrCoords[1],
                this.relativeCoords.usrCoords[2],
                this.orgText
            ];
        }
        else {
            // Other texts
            p = [this.Z(), this.X(), this.Y(), this.orgText];
        }
        if (this.parents.length !== 0) {
            p = this.parents;
        }
        return p;
    }
    /**
     * Returns the bounding box of the text element in user coordinates as an
     * array of length 4: [upper left x, upper left y, lower right x, lower right y].
     * The method assumes that the lower left corner is at position [el.X(), el.Y()]
     * of the text element el, i.e. the attributes anchorX, anchorY are ignored.
     *
     * <p>
     * <strong>Attention:</strong> for labels, [0, 0, 0, 0] is returned.
     *
     * @returns Array
     */
    bounds() {
        var c = this.coords.usrCoords;
        if (this.evalVisProp('islabel') ||
            this.board.unitY === 0 ||
            this.board.unitX === 0) {
            return [0, 0, 0, 0];
        }
        return [
            c[1],
            c[2] + this.size[1] / this.board.unitY,
            c[1] + this.size[0] / this.board.unitX,
            c[2]
        ];
    }
    /**
     * Returns the value of the attribute "anchorX". If this equals "auto",
     * returns "left", "middle", or "right", depending on the
     * value of the attribute "position".
     * @returns String
     */
    getAnchorX() {
        var a = this.evalVisProp('anchorx');
        if (a === "auto") {
            switch (this.visProp.position) {
                case "top":
                case "bot":
                    return "middle";
                case "rt":
                case "lrt":
                case "urt":
                    return "left";
                case "lft":
                case "llft":
                case "ulft":
                default:
                    return "right";
            }
        }
        return a;
    }
    /**
     * Returns the value of the attribute "anchorY". If this equals "auto",
     * returns "bottom", "middle", or "top", depending on the
     * value of the attribute "position".
     * @returns String
     */
    getAnchorY() {
        var a = this.evalVisProp('anchory');
        if (a === "auto") {
            switch (this.visProp.position) {
                case "top":
                case "ulft":
                case "urt":
                    return "bottom";
                case "bot":
                case "lrt":
                case "llft":
                    return "top";
                case "rt":
                case "lft":
                default:
                    return "middle";
            }
        }
        return a;
    }
    /**
     * Computes the number of overlaps of a box of w pixels width, h pixels height
     * and center (x, y)
     *
     * An overlap occurs when either:
     * <ol>
     *   <li> For labels/points: Their bounding boxes intersect
     *   <li> For other objects: The object contains the center point of the box
     * </ol>
     *
     * @private
     * @param  {Number} x x-coordinate of the center (screen coordinates)
     * @param  {Number} y y-coordinate of the center (screen coordinates)
     * @param  {Number} w width of the box in pixel
     * @param  {Number} h width of the box in pixel
     * @param  {Array} [whiteList] array of ids which should be ignored
     * @return {Number}   Number of overlapping elements
     */
    getNumberOfConflicts(x, y, w, h, whiteList) {
        whiteList = whiteList || [];
        var count = 0, i, obj, coords, saveHasInnerPoints, savePointPrecision = Options.precision.hasPoint, objCenterX, objCenterY, objWidth, objHeight;
        // set a new precision for hasPoint
        // this.board.options.precision.hasPoint = Math.max(w, h) * 0.5;
        Options.precision.hasPoint = (w + h) * 0.3;
        // loop over all objects
        for (i = 0; i < this.board.objectsList.length; i++) {
            obj = this.board.objectsList[i];
            //Skip the object if it is not meant to influence label position
            if (obj.visPropCalc.visible &&
                obj !== this &&
                whiteList.indexOf(obj.id) === -1 &&
                obj.evalVisProp("ignoreforlabelautoposition") !== true) {
                // Save hasinnerpoints and temporarily disable to handle polygon areas
                saveHasInnerPoints = obj.visProp.hasinnerpoints;
                obj.visProp.hasinnerpoints = false;
                // If is label or point use other conflict detection
                if (obj.visProp.islabel ||
                    obj.elementClass === OBJECT_CLASS.POINT) {
                    // get coords and size of the object
                    coords = obj.coords.scrCoords;
                    objCenterX = coords[1];
                    objCenterY = coords[2];
                    objWidth = obj.size[0];
                    objHeight = obj.size[1];
                    // move coords to the center of the label
                    if (obj.visProp.islabel) {
                        // Vertical adjustment
                        if (obj.visProp.anchory === 'top') {
                            objCenterY = objCenterY + objHeight / 2;
                        }
                        else {
                            objCenterY = objCenterY - objHeight / 2;
                        }
                        // Horizontal adjustment
                        if (obj.visProp.anchorx === 'left') {
                            objCenterX = objCenterX + objWidth / 2;
                        }
                        else {
                            objCenterX = objCenterX - objWidth / 2;
                        }
                    }
                    else {
                        // Points are treated dimensionless
                        objWidth = 0;
                        objHeight = 0;
                    }
                    // Check for overlap
                    if (Math.abs(objCenterX - x) < (w + objWidth) / 2 &&
                        Math.abs(objCenterY - y) < (h + objHeight) / 2) {
                        count++;
                    }
                    //if not label or point check conflict with hasPoint
                }
                else if (obj.hasPoint(x, y)) {
                    count++;
                }
                // Restore original hasinnerpoints
                obj.visProp.hasinnerpoints = saveHasInnerPoints;
            }
        }
        // Restore original precision
        Options.precision.hasPoint = savePointPrecision;
        return count;
    }
    /**
     * Calculates the score of a label position with a given radius and angle. The score is calculated by the following rules:
     * <ul>
     * <li> the maximum score is 0
     * <li> if the label is outside of the bounding box, the score is reduced by 1
     * <li> for each conflict, the score is reduced by 1
     * <li> the score is reduced by the displacement (angle difference between old and new position) of the label
     * <li> the score is reduced by the angle between the original label position and the new label position
     * </ul>
     *
     * @param {number} radius radius in pixels
     * @param {number} angle angle in radians
     * @returns {number} Position score, higher values indicate better positions
     */
    calculateScore(radius, angle) {
        var x, y, co, si, angleCurrentOffset, angleDifference, score = 0, cornerPoint = [0, 0], w = this.getSize()[0], h = this.getSize()[1], anchorCoords, currentOffset = this.evalVisProp("offset"), boundingBox = this.board.getBoundingBox();
        if (this.evalVisProp('islabel') && Type.exists(this.element)) {
            anchorCoords = this.getLabelAnchor().scrCoords;
        }
        else {
            return 0;
        }
        co = Math.cos(angle);
        si = Math.sin(angle);
        // calculate new position with srccoords, radius and angle
        x = anchorCoords[1] + radius * co;
        y = anchorCoords[2] - radius * si;
        // if the label was placed on the left side of the element, the anchorx is set to "right"
        if (co < 0) {
            cornerPoint[0] = x - w;
            x -= w / 2;
        }
        else {
            cornerPoint[0] = x + w;
            x += w / 2;
        }
        // If the label was placed on the bottom side of the element, so the anchory is set to "top"
        if (si < 0) {
            cornerPoint[1] = y + h;
            y += h / 2;
        }
        else {
            cornerPoint[1] = y - h;
            y -= h / 2;
        }
        // If label was not in bounding box, score is reduced by 1
        if (cornerPoint[0] < 0 ||
            cornerPoint[0] > (boundingBox[2] - boundingBox[0]) * this.board.unitX ||
            cornerPoint[1] < 0 ||
            cornerPoint[1] > (boundingBox[1] - boundingBox[3]) * this.board.unitY) {
            score -= 1;
        }
        // Per conflict, score is reduced by 1
        score -= this.getNumberOfConflicts(x, y, w, h, Type.evaluate(this.visProp.autopositionwhitelist));
        // Calculate displacement, minimum score is 0 if radius is minRadius, maximum score is < 1 when radius is maxRadius
        score -= radius / this.evalVisProp("autopositionmindistance") / 10 - 0.1;
        // Calculate angle between current offset and new offset
        angleCurrentOffset = Math.atan2(currentOffset[1], currentOffset[0]);
        // If angle is negative, add 2*PI to get positive angle
        if (angleCurrentOffset < 0) {
            angleCurrentOffset += 2 * Math.PI;
        }
        // Calculate displacement by angle between original label position and new label position,
        // use cos to check if angle is on the right side.
        // If both angles are on the right side and more than 180 apart, add 2*PI. e.g. 0.1 and 6.1 are near each other
        if (co > 0 && Math.cos(angleCurrentOffset) > 0 && Math.abs(angle - angleCurrentOffset) > Math.PI) {
            angleDifference = Math.abs(angle - angleCurrentOffset - 2 * Math.PI);
        }
        else {
            angleDifference = Math.abs(angle - angleCurrentOffset);
        }
        // Minimum score is 0 if angle difference is 0, maximum score is pi / 10
        score -= angleDifference / 10;
        return score;
    }
    /**
     * Automatically positions the label by finding the optimal position.
     * Aims to minimize conflicts while maintaining readability.
     * <p>
     * The method tests 60 different angles (0 to 2) at 3 different distances (radii).
     * It evaluates each position using calculateScore(radius, angle) and chooses the position with the highest score.
     * Then the label's anchor points and offset are adjusted accordingly.
     *
     * @returns {JXG.Text} Reference to the text object.
     */
    setAutoPosition() {
        var radius, angle, radiusStep, i, bestScore = -Infinity, bestRadius, bestAngle, minRadius = this.evalVisProp("autopositionmindistance"), maxRadius = this.evalVisProp("autopositionmaxdistance"), score, co, si, currentOffset = this.evalVisProp("offset"), currentRadius, currentAngle, numAngles = 60, numRadius = 4;
        if (this === this.board.infobox ||
            !this.element ||
            !this.visPropCalc.visible ||
            !this.evalVisProp('islabel')) {
            return this;
        }
        // Calculate current position
        currentRadius = Math.sqrt(currentOffset[0] * currentOffset[0] + currentOffset[1] * currentOffset[1]);
        currentAngle = Math.atan2(currentOffset[1], currentOffset[0]);
        if (this.calculateScore(currentRadius, currentAngle) === 0) {
            return this;
        }
        // Initialize search at min radius
        radius = minRadius;
        // Calculate step size
        radiusStep = (maxRadius - minRadius) / (numRadius - 1);
        // Test the different radii
        while (maxRadius - radius > -0.01) {
            // Radius gets bigger so just check if its smaller than maxnumber of angles.
            for (i = 0; i < numAngles; i++) {
                // calculate angle
                angle = i / numAngles * 2 * Math.PI;
                // calculate score
                score = this.calculateScore(radius, angle);
                // if score is better than bestScore, set bestAngle, bestRadius and bestScore
                if (score > bestScore) {
                    bestAngle = angle;
                    bestRadius = radius;
                    bestScore = score;
                }
                // if bestScore is 0, break, because it can't get better
                if (bestScore === 0) {
                    radius = maxRadius;
                    break;
                }
            }
            radius += radiusStep;
        }
        co = Math.cos(bestAngle);
        si = Math.sin(bestAngle);
        // If label is on the left side of the element, the anchorx is set to "right"
        if (co < 0) {
            this.visProp.anchorx = "right";
        }
        else {
            this.visProp.anchorx = "left";
        }
        // If label is on the bottom side of the element, so the anchory is set to "top"
        if (si < 0) {
            this.visProp.anchory = "top";
        }
        else {
            this.visProp.anchory = "bottom";
        }
        // Set offset
        this.visProp.offset = [bestRadius * co, bestRadius * si];
        return this;
    }
}
/**
 * @class Constructs a text element.
 *
 * The coordinates can either be absolute (i.e. respective to the coordinate system of the board) or be relative to the coordinates of an element
 * given in {@link Text#anchor}.
 * <p>
 * HTML, MathJaX, KaTeX and GEONExT syntax can be handled.
 * <p>
 * There are two ways to display texts:
 * <ul>
 * <li> using the text element of the renderer (canvas or svg). In most cases this is the suitable approach if speed matters.
 * However, advanced rendering like MathJax, KaTeX or HTML/CSS are not possible.
 * <li> using HTML &lt;div&gt;. This is the most flexible approach. The drawback is that HTML can only be display "above" the geometry elements.
 * If HTML should be displayed in an inbetween layer, conder to use an element of type {@link ForeignObject} (available in svg renderer, only).
 * </ul>
 * @pseudo
 * @name Text
 * @augments JXG.Text
 * @constructor
 * @type JXG.Text
 *
 * @param {number,function_number,function_number,function_String,function} z_,x,y,str Parent elements for text elements.
 *                     <p>
 *   Parent elements can be two or three elements of type number, a string containing a GEONE<sub>x</sub>T
 *   constraint, or a function which takes no parameter and returns a number. Every parent element beside the last determines one coordinate.
 *   If a coordinate is
 *   given by a number, the number determines the initial position of a free text. If given by a string or a function that coordinate will be constrained
 *   that means the user won't be able to change the texts's position directly by mouse because it will be calculated automatically depending on the string
 *   or the function's return value. If two parent elements are given the coordinates will be interpreted as 2D affine Euclidean coordinates, if three such
 *   parent elements are given they will be interpreted as homogeneous coordinates.
 *                     <p>
 *                     The text to display may be given as string or as function returning a string.
 *
 * There is the attribute 'display' which takes the values 'html' or 'internal'. In case of 'html' an HTML division tag is created to display
 * the text. In this case it is also possible to use MathJax, KaTeX, or ASCIIMathML. If neither of these is used, basic Math rendering is
 * applied.
 * <p>
 * In case of 'internal', an SVG text element is used to display the text.
 * @see JXG.Text
 * @example
 * // Create a fixed text at position [0,1].
 *   var t1 = board.create('text',[0,1,"Hello World"]);
 * </pre><div class="jxgbox" id="JXG896013aa-f24e-4e83-ad50-7bc7df23f6b7" style="width: 300px; height: 300px;"></div>
 * <script type="text/javascript">
 *   var t1_board = JXG.JSXGraph.initBoard('JXG896013aa-f24e-4e83-ad50-7bc7df23f6b7', {boundingbox: [-3, 6, 5, -3], axis: true, showcopyright: false, shownavigation: false});
 *   var t1 = t1_board.create('text',[0,1,"Hello World"]);
 * </script><pre>
 * @example
 * // Create a variable text at a variable position.
 *   var s = board.create('slider',[[0,4],[3,4],[-2,0,2]]);
 *   var graph = board.create('text',
 *                        [function(x){ return s.Value();} 1,
 *                         function(){return "The value of s is"+JXG.toFixed(s.Value(), 2);}
 *                        ]
 *                     );
 * </pre><div class="jxgbox" id="JXG5441da79-a48d-48e8-9e53-75594c384a1c" style="width: 300px; height: 300px;"></div>
 * <script type="text/javascript">
 *   var t2_board = JXG.JSXGraph.initBoard('JXG5441da79-a48d-48e8-9e53-75594c384a1c', {boundingbox: [-3, 6, 5, -3], axis: true, showcopyright: false, shownavigation: false});
 *   var s = t2_board.create('slider',[[0,4],[3,4],[-2,0,2]]);
 *   var t2 = t2_board.create('text',[function(x){ return s.Value();} 1, function(){return "The value of s is "+JXG.toFixed(s.Value(), 2);}]);
 * </script><pre>
 * @example
 * // Create a text bound to the point A
 * var p = board.create('point',[0, 1]),
 *     t = board.create('text',[0, -1,"Hello World"], {anchor: p});
 *
 * </pre><div class="jxgbox" id="JXGff5a64b2-2b9a-11e5-8dd9-901b0e1b8723" style="width: 300px; height: 300px;"></div>
 * <script type="text/javascript">
 *     (function() {
 *         var board = JXG.JSXGraph.initBoard('JXGff5a64b2-2b9a-11e5-8dd9-901b0e1b8723',
 *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
 *     var p = board.create('point',[0, 1]),
 *         t = board.create('text',[0, -1,"Hello World"], {anchor: p});
 *
 *     })();
 *
 * </script><pre>
 *
 */
function createText(board, parents, attributes) {
    var t, attr = Type.copyAttributes(attributes, board.options, "text"), coords = parents.slice(0, -1), content = parents[parents.length - 1];
    console.log('createText', coords, content, parents);
    // Backwards compatibility
    attr.anchor = attr.parent || attr.anchor;
    t = new Text(board, coords, attr, content);
    if (!t) {
        throw new Error("JSXGraph: Can't create text with parent types '" +
            typeof parents[0] +
            "' and '" +
            typeof parents[1] +
            "'." +
            "\nPossible parent types: [x,y], [z,x,y], [element,transformation]");
    }
    if (attr.rotate !== 0) {
        // This is the default value, i.e. no rotation
        t.addRotation(attr.rotate);
    }
    return t;
}
/**
 * @class Labels are text objects tied to other elements like points, lines and curves.
 * Labels are handled internally by JSXGraph, only. There is NO constructor "board.create('label', ...)".
 *
 * @description
 * Labels for points are positioned with the attributes {@link Text#anchorX} {@link Text#anchorX} and {@link Label#offset}.
 * <p>
 * Labels for lines, segments, curves and circles can be controlled additionally by the attributes {@link Label#position} and
 * {@link Label#distance} i.e. for a segment [A, B] one could use the follwoing attributes:
 * <ul>
 * <li> "position": determines, where in the direction of the segment from A to B the label is placed
 * <li> "distance": determines the (orthogonal) distance of the label from the line segment. It is a factor which is multiplied by the font-size.
 * <li> "offset: [h, v]": a final correction in pixel (horizontally: h, vertically: v)
 * <li> "anchorX" ('left', 'middle', 'right') and "anchorY" ('bottom', 'middle', 'top'): determines which part of the
 * label string is the anchor position that is positioned to the coordinates determined by "position", "distance" and "offset".
 * </ul>
 *
 * @pseudo
 * @name Label
 * @augments JXG.Text
 * @constructor
 * @type JXG.Text
 */
//  See element.js#createLabel
// /**
//  * [[x,y], [w px, h px], [range]
//  */
// export class HTMLSlider extends Text {
//     constructor(board, parents, attributes) {
//         super(board,parents[0],parents,attributes)
//         var t:Text,
//             par,
//             attr = Type.copyAttributes(attributes, board.options, "htmlslider");
//         if (parents.length !== 2 || parents[0].length !== 2 || parents[1].length !== 3) {
//             throw new Error(
//                 "JSXGraph: Can't create htmlslider with parent types '" +
//                 typeof parents[0] +
//                 "' and '" +
//                 typeof parents[1] +
//                 "'." +
//                 "\nPossible parents are: [[x,y], [min, start, max]]"
//             );
//         }
//         // Backwards compatibility
//         attr.anchor = attr.parent || attr.anchor;
//         attr.fixed = attr.fixed || true;
//         par = [
//             parents[0][0],
//             parents[0][1],
//             '<form style="display:inline">' +
//             '<input type="range" /><span></span><input type="text" />' +
//             "</form>"
//         ];
//         t = createText(board, par, attr);
//         t.type = OBJECT_TYPE.HTMLSLIDER;
//         t.rendNodeForm = t.rendNode.childNodes[0];
//         t.rendNodeRange = t.rendNodeForm.childNodes[0];
//         t.rendNodeRange.min = parents[1][0];
//         t.rendNodeRange.max = parents[1][2];
//         t.rendNodeRange.step = attr.step;
//         t.rendNodeRange.value = parents[1][1];
//         t.rendNodeLabel = t.rendNodeForm.childNodes[1];
//         t.rendNodeLabel.id = t.rendNode.id + "_label";
//         if (attr.withlabel) {
//             t.rendNodeLabel.innerHTML = t.name + "=";
//         }
//         t.rendNodeOut = t.rendNodeForm.childNodes[2];
//         t.rendNodeOut.value = parents[1][1];
//         try {
//             t.rendNodeForm.id = t.rendNode.id + "_form";
//             t.rendNodeRange.id = t.rendNode.id + "_range";
//             t.rendNodeOut.id = t.rendNode.id + "_out";
//         } catch (e) {
//             JXG.debug(e);
//         }
//         t.rendNodeRange.style.width = attr.widthrange + "px";
//         t.rendNodeRange.style.verticalAlign = "middle";
//         t.rendNodeOut.style.width = attr.widthout + "px";
//         t._val = parents[1][1];
//         Env.addEvent(t.rendNodeForm, "input", t.HTMLSliderInputEventHandler, t);
//         t.Value = function () {
//             return this._val;
//         };
//         return t;
//     };
// }
JXG_registerElement("text", createText);

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */
/*global JXG: true, define: true, console: true, window: true*/
/*jslint nomen: true, plusplus: true*/
/**
 * @fileoverview The geometry object Point is defined in this file. Point stores all
 * style and functional properties that are required to draw and move a point on
 * a board.
 */
/**
 * A point is the basic geometric element. Based on points lines and circles can be constructed which can be intersected
 * which in turn are points again which can be used to construct new lines, circles, polygons, etc. This class holds methods for
 * all kind of points like free points, gliders, and intersection points.
 * @class Creates a new point object. Do not use this constructor to create a point. Use {@link JXG.Board#create} with
 * type {@link Point} {@link Glider} or {@link Intersection} instead.
 * @augments JXG.GeometryElement
 * @augments JXG.CoordsElement
 * @param {string|JXG.Board} board The board the new point is drawn on.
 * @param {Array} coordinates An array with the user coordinates of the point.
 * @param {Object} attributes An object containing visual properties like in {@link JXG.Options#point} and
 * {@link JXG.Options#elements} and optional a name and an id.
 * @see JXG.Board#generateName
 */
// Point, Text, and Image extend CoordsElement before GeometryElement
class Point extends CoordsElement {
    constructor(board, coordinates, attributes) {
        super(board, COORDS_BY.USER, coordinates, attributes);
        // this.element = this.board.select(attributes.anchor);   // tbtb only for text !?!
        // this.usrC coords = new Coords(coordinates);
        this.elType = "point";
        this.visProp = Type.merge(this.visProp, Options);
        this.otype = OBJECT_TYPE.POINT;
        this.oclass = OBJECT_CLASS.POINT;
        /* Register point at board. */
        this.id = this.board.setId(this, "P");
        this.board.renderer.drawPoint(this);
        this.board.finalizeAdding(this);
        this.createGradient();
        // TODO  //this.createLabel();
    }
    ////////////////// this was the original JSXGraph Point
    // this.constructor(board, attributes, Const.OBJECT_TYPE_POINT, Const.OBJECT_CLASS_POINT);
    // this.element = this.board.select(attributes.anchor);
    // this.coordsConstructor(coordinates);
    // this.elType = 'point';
    // /* Register point at board. */
    // this.id = this.board.setId(this, 'P');
    // this.board.renderer.drawPoint(this);
    // this.board.finalizeAdding(this);
    // this.createGradient();
    // this.createLabel();
    /**
     * Checks whether (x,y) is near the point.
     * @param {Number} x Coordinate in x direction, screen coordinates.
     * @param {Number} y Coordinate in y direction, screen coordinates.
     * @returns {Boolean} True if (x,y) is near the point, False otherwise.
     * @private
     */
    hasPoint(x, y) {
        var coordsScr = this.scrCoords, r, prec, type, unit = this.evalVisProp('sizeunit');
        if (Type.isObject(this.evalVisProp('precision'))) {
            type = this.board._inputDevice;
            prec = this.evalVisProp('precision.' + type);
        }
        else {
            // 'inherit'
            prec = Options.precision.hasPoint;
        }
        r = parseFloat(this.evalVisProp('size'));
        if (unit === "user") {
            r *= Math.sqrt(Math.abs(this.board.unitX * this.board.unitY));
        }
        r += parseFloat(this.evalVisProp('strokewidth')) * 0.5;
        if (r < prec) {
            r = prec;
        }
        return Math.abs(coordsScr[1] - x) < r + 2 && Math.abs(coordsScr[2] - y) < r + 2;
    }
    /**
     * Updates the position of the point.
     */
    update(fromParent) {
        if (!this.needsUpdate) {
            return this;
        }
        this.updateCoords(fromParent);
        if (this.evalVisProp('trace')) {
            this.cloneToBackground();
        }
        return this;
    }
    /**
     * Applies the transformations of the element to {@link JXG.Point#baseElement}.
     * Point transformations are relative to a base element.
     * @param {Boolean} fromParent True if the drag comes from a child element. This is the case if a line
     *    through two points is dragged. Otherwise, the element is the drag element and we apply the
     *    the inverse transformation to the baseElement if is different from the element.
     * @returns {JXG.CoordsElement} Reference to this object.
     */
    updateTransform(fromParent) {
        var c, i;
        if (this.transformations.length === 0 || this.baseElement === null) {
            return this;
        }
        this.transformations[0].update();
        if (this === this.baseElement) {
            // Case of bindTo
            c = this.transformations[0].apply(this, "self");
        }
        else {
            c = this.transformations[0].apply(this.baseElement);
        }
        for (i = 1; i < this.transformations.length; i++) {
            this.transformations[i].update();
            c = JSXMath.matVecMult(this.transformations[i].matrix, c);
        }
        this.coords.setCoordinates(COORDS_BY.USER, c);
        return this;
    }
    /**
     * Calls the renderer to update the drawing.
     * @private
     */
    updateRenderer() {
        this.updateRendererGeneric("updatePoint");
        return this;
    }
    // documented in JXG.GeometryElement
    bounds() {
        return this.coords.usrCoords.slice(1).concat(this.coords.usrCoords.slice(1));
    }
    /**
     * Convert the point to intersection point and update the construction.
     * To move the point visual onto the intersection, a call of board update is necessary.
     *
     * @param {String|Object} el1, el2, i, j The intersecting objects and the numbers.
     **/
    makeIntersection(el1, el2, i, j) {
        var func;
        el1 = this.board.select(el1);
        el2 = this.board.select(el2);
        func = Geometry.intersectionFunction(this.board, el1, el2, i, j, this.visProp.alwaysintersect);
        this.addConstraint([func]);
        try {
            el1.addChild(this);
            el2.addChild(this);
        }
        catch (e) {
            throw new Error("JSXGraph: Can't create 'intersection' with parent types '" +
                typeof el1 +
                "' and '" +
                typeof el2 +
                "'.");
        }
        this.type = OBJECT_TYPE.INTERSECTION;
        this.elType = "intersection";
        this.parents = [el1.id, el2.id, i, j];
        this.generatePolynomial = function () {
            var poly1 = el1.generatePolynomial(this), poly2 = el2.generatePolynomial(this);
            if (poly1.length === 0 || poly2.length === 0) {
                return [];
            }
            return [poly1[0], poly2[0]];
        };
        this.prepareUpdate().update(true);
    }
    /**
     * Set the style of a point.
     * Used for GEONExT import and should not be used to set the point's face and size.
     * @param {Number} i Integer to determine the style.
     * @private
     */
    setStyle(i) {
        var facemap = [
            // 0-2
            "cross",
            "cross",
            "cross",
            // 3-6
            "circle",
            "circle",
            "circle",
            "circle",
            // 7-9
            "square",
            "square",
            "square",
            // 10-12
            "plus",
            "plus",
            "plus"
        ], sizemap = [
            // 0-2
            2, 3, 4,
            // 3-6
            1, 2, 3, 4,
            // 7-9
            2, 3, 4,
            // 10-12
            2, 3, 4
        ];
        this.visProp.face = facemap[i];
        this.visProp.size = sizemap[i];
        this.board.renderer.changePointStyle(this);
        return this;
    }
    /**
     * @deprecated Use JXG#normalizePointFace instead
     * @param s
     * @returns {*}
     */
    normalizeFace(s) {
        JXG.deprecated("Point.normalizeFace()", "JXG.normalizePointFace()");
        return Options.normalizePointFace(s);
    }
    /**
     * Set the face of a point element.
     * @param {String} f String which determines the face of the point. See {@link JXG.GeometryElement#face} for a list of available faces.
     * @see JXG.GeometryElement#face
     * @deprecated Use setAttribute()
     */
    face(f) {
        JXG.deprecated("Point.face()", "Point.setAttribute()");
        this.setAttribute({ face: f });
    }
    /**
     * Set the size of a point element
     * @param {Number} s Integer which determines the size of the point.
     * @see JXG.GeometryElement#size
     * @deprecated Use setAttribute()
     */
    size(s) {
        JXG.deprecated("Point.size()", "Point.setAttribute()");
        this.setAttribute({ size: s });
    }
    /**
     * Test if the point is on (is incident with) element "el".
     *
     * @param {JXG.GeometryElement} el
     * @param {Number} tol
     * @returns {Boolean}
     *
     * @example
     * var circ = board.create('circle', [[-2, -2], 1]);
     * var seg = board.create('segment', [[-1, -3], [0,0]]);
     * var line = board.create('line', [[1, 3], [2, -2]]);
     * var po = board.create('point', [-1, 0], {color: 'blue'});
     * var curve = board.create('functiongraph', ['sin(x)'], {strokeColor: 'blue'});
     * var pol = board.create('polygon', [[2,2], [4,2], [4,3]], {strokeColor: 'blue'});
     *
     * var point = board.create('point', [-1, 1], {
     *               attractors: [line, seg, circ, po, curve, pol],
     *               attractorDistance: 0.2
     *             });
     *
     * var txt = board.create('text', [-4, 3, function() {
     *              return 'point on line: ' + point.isOn(line) + '<br>' +
     *                 'point on seg: ' + point.isOn(seg) + '<br>' +
     *                 'point on circ = ' + point.isOn(circ) + '<br>' +
     *                 'point on point = ' + point.isOn(po) + '<br>' +
     *                 'point on curve = ' + point.isOn(curve) + '<br>' +
     *                 'point on polygon = ' + point.isOn(pol) + '<br>';
     * }]);
     *
     * </pre><div id="JXG6c7d7404-758a-44eb-802c-e9644b9fab71" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG6c7d7404-758a-44eb-802c-e9644b9fab71',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var circ = board.create('circle', [[-2, -2], 1]);
     *     var seg = board.create('segment', [[-1, -3], [0,0]]);
     *     var line = board.create('line', [[1, 3], [2, -2]]);
     *     var po = board.create('point', [-1, 0], {color: 'blue'});
     *     var curve = board.create('functiongraph', ['sin(x)'], {strokeColor: 'blue'});
     *     var pol = board.create('polygon', [[2,2], [4,2], [4,3]], {strokeColor: 'blue'});
     *
     *     var point = board.create('point', [-1, 1], {
     *                   attractors: [line, seg, circ, po, curve, pol],
     *                   attractorDistance: 0.2
     *                 });
     *
     *     var txt = board.create('text', [-4, 3, function() {
     *             return 'point on line: ' + point.isOn(line) + '<br>' +
     *                     'point on seg: ' + point.isOn(seg) + '<br>' +
     *                     'point on circ = ' + point.isOn(circ) + '<br>' +
     *                     'point on point = ' + point.isOn(po) + '<br>' +
     *                     'point on curve = ' + point.isOn(curve) + '<br>' +
     *                     'point on polygon = ' + point.isOn(pol) + '<br>';
     *     }]);
     *
     *     })();
     *
     * </script><pre>
     *
     */
    isOn(el, tol) {
        var arr, crds;
        tol = tol || JSXMath.eps;
        if (Type.isPoint(el)) {
            return this.Dist(el) < tol;
        }
        else if (el.elementClass === OBJECT_CLASS.LINE) {
            if (el.elType === "segment" && !this.evalVisProp('alwaysintersect')) {
                arr = Geometry.projectCoordsToSegment(this.coords.usrCoords, el.point1.coords.usrCoords, el.point2.coords.usrCoords);
                if (arr[1] >= 0 &&
                    arr[1] <= 1 &&
                    Geometry.distPointLine(this.coords.usrCoords, el.stdform) < tol) {
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                return Geometry.distPointLine(this.coords.usrCoords, el.stdform) < tol;
            }
        }
        else if (el.elementClass === OBJECT_CLASS.CIRCLE) {
            if (el.evalVisProp('hasinnerpoints')) {
                return this.Dist(el.center) < el.Radius() + tol;
            }
            return Math.abs(this.Dist(el.center) - el.Radius()) < tol;
        }
        else if (el.elementClass === OBJECT_CLASS.CURVE) {
            crds = Geometry.projectPointToCurve(this, el, this.board)[0];
            return Geometry.distance(this.coords.usrCoords, crds.usrCoords, 3) < tol;
        }
        else if (el.type === OBJECT_TYPE.POLYGON) {
            if (el.evalVisProp('hasinnerpoints')) {
                if (el.pnpoly(this.coords.usrCoords[1], this.coords.usrCoords[2], COORDS_BY.USER)) {
                    return true;
                }
            }
            arr = Geometry.projectCoordsToPolygon(this.coords.usrCoords, el);
            return Geometry.distance(this.coords.usrCoords, arr, 3) < tol;
        }
        else if (el.type === OBJECT_TYPE.TURTLE) {
            crds = Geometry.projectPointToTurtle(this, el, this.board);
            return Geometry.distance(this.coords.usrCoords, crds.usrCoords, 3) < tol;
        }
        // TODO: Arc, Sector
        return false;
    }
    // Already documented in GeometryElement
    cloneToBackground() {
        // TODO used for tracingn  // var copy = Type.getCloneObject(this);
        // this.board.renderer.drawPoint(copy);
        // this.traces[copy.id] = copy.rendNode;
        return this;
    }
}
/**
 * @class Construct a free or a fixed point. A free point is created if the given parent elements are all numbers
 * and the property fixed is not set or set to false. If one or more parent elements is not a number but a string containing a GEONE<sub>x</sub>T
 * constraint or a function the point will be considered as constrained). That means that the user won't be able to change the point's
 * position directly.
 * @see Glider for a non-free point that is attached to another geometric element.
 * @pseudo
 * @name Point
 * @augments JXG.Point
 * @constructor
 * @type JXG.Point
 * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.
 * @param {Number,string,function_Number,string,function_Number,string,function} z_,x,y Parent elements can be two or three elements of type number, a string containing a GEONE<sub>x</sub>T
 * constraint, or a function which takes no parameter and returns a number. Every parent element determines one coordinate. If a coordinate is
 * given by a number, the number determines the initial position of a free point. If given by a string or a function that coordinate will be constrained
 * that means the user won't be able to change the point's position directly by mouse because it will be calculated automatically depending on the string
 * or the function's return value. If two parent elements are given the coordinates will be interpreted as 2D affine Euclidean coordinates, if three such
 * parent elements are given they will be interpreted as homogeneous coordinates.
 * @param {JXG.Point_JXG.Transformation_Array} Point,Transformation A point can also be created providing a transformation or an array of transformations.
 * The resulting point is a clone of the base point transformed by the given Transformation. {@see JXG.Transformation}.
 *
 * @example
 * // Create a free point using affine Euclidean coordinates
 * var p1 = board.create('point', [3.5, 2.0]);
 * </pre><div class="jxgbox" id="JXG672f1764-7dfa-4abc-a2c6-81fbbf83e44b" style="width: 200px; height: 200px;"></div>
 * <script type="text/javascript">
 *   var board = JXG.JSXGraph.initBoard('JXG672f1764-7dfa-4abc-a2c6-81fbbf83e44b', {boundingbox: [-1, 5, 5, -1], axis: true, showcopyright: false, shownavigation: false});
 *   var p1 = board.create('point', [3.5, 2.0]);
 * </script><pre>
 * @example
 * // Create a constrained point using anonymous function
 * var p2 = board.create('point', [3.5, function () { return p1.X(); }]);
 * </pre><div class="jxgbox" id="JXG4fd4410c-3383-4e80-b1bb-961f5eeef224" style="width: 200px; height: 200px;"></div>
 * <script type="text/javascript">
 *   var fpex1_board = JXG.JSXGraph.initBoard('JXG4fd4410c-3383-4e80-b1bb-961f5eeef224', {boundingbox: [-1, 5, 5, -1], axis: true, showcopyright: false, shownavigation: false});
 *   var fpex1_p1 = fpex1_board.create('point', [3.5, 2.0]);
 *   var fpex1_p2 = fpex1_board.create('point', [3.5, function () { return fpex1_p1.X(); }]);
 * </script><pre>
 * @example
 * // Create a point using transformations
 * var trans = board.create('transform', [2, 0.5], {type:'scale'});
 * var p3 = board.create('point', [p2, trans]);
 * </pre><div class="jxgbox" id="JXG630afdf3-0a64-46e0-8a44-f51bd197bb8d" style="width: 400px; height: 400px;"></div>
 * <script type="text/javascript">
 *   var fpex2_board = JXG.JSXGraph.initBoard('JXG630afdf3-0a64-46e0-8a44-f51bd197bb8d', {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});
 *   var fpex2_trans = fpex2_board.create('transform', [2, 0.5], {type:'scale'});
 *   var fpex2_p2 = fpex2_board.create('point', [3.5, 2.0]);
 *   var fpex2_p3 = fpex2_board.create('point', [fpex2_p2, fpex2_trans]);
 * </script><pre>
 */
function createPoint(board, parents, attributes) {
    var el, attr;
    attr = Type.copyAttributes(attributes, Options.board, "point");
    el = new Point(board, parents, attr);
    if (!el) {
        throw new Error("JSXGraph: Can't create point with parent types '" +
            typeof parents[0] +
            "' and '" +
            typeof parents[1] +
            "'." +
            "\nPossible parent types: [x,y], [z,x,y], [element,transformation]");
    }
    return el;
}
/**
 * @class A glider is a point bound to a line, circle or curve or even another point.
 * @pseudo
 * @description A glider is a point which lives on another geometric element like a line, circle, curve, turtle.
 * @name Glider
 * @augments JXG.Point
 * @constructor
 * @type JXG.Point
 * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.
 * @param {Number_Number_Number_JXG.GeometryElement} z_,x_,y_,GlideObject Parent elements can be two or three elements of type number and the object the glider lives on.
 * The coordinates are completely optional. If not given the origin is used. If you provide two numbers for coordinates they will be interpreted as affine Euclidean
 * coordinates, otherwise they will be interpreted as homogeneous coordinates. In any case the point will be projected on the glide object.
 * @example
 * // Create a glider with user defined coordinates. If the coordinates are not on
 * // the circle (like in this case) the point will be projected onto the circle.
 * var p1 = board.create('point', [2.0, 2.0]);
 * var c1 = board.create('circle', [p1, 2.0]);
 * var p2 = board.create('glider', [2.0, 1.5, c1]);
 * </pre><div class="jxgbox" id="JXG4f65f32f-e50a-4b50-9b7c-f6ec41652930" style="width: 300px; height: 300px;"></div>
 * <script type="text/javascript">
 *   var gpex1_board = JXG.JSXGraph.initBoard('JXG4f65f32f-e50a-4b50-9b7c-f6ec41652930', {boundingbox: [-1, 5, 5, -1], axis: true, showcopyright: false, shownavigation: false});
 *   var gpex1_p1 = gpex1_board.create('point', [2.0, 2.0]);
 *   var gpex1_c1 = gpex1_board.create('circle', [gpex1_p1, 2.0]);
 *   var gpex1_p2 = gpex1_board.create('glider', [2.0, 1.5, gpex1_c1]);
 * </script><pre>
 * @example
 * // Create a glider with default coordinates (1,0,0). Same premises as above.
 * var p1 = board.create('point', [2.0, 2.0]);
 * var c1 = board.create('circle', [p1, 2.0]);
 * var p2 = board.create('glider', [c1]);
 * </pre><div class="jxgbox" id="JXG4de7f181-631a-44b1-a12f-bc4d995609e8" style="width: 200px; height: 200px;"></div>
 * <script type="text/javascript">
 *   var gpex2_board = JXG.JSXGraph.initBoard('JXG4de7f181-631a-44b1-a12f-bc4d995609e8', {boundingbox: [-1, 5, 5, -1], axis: true, showcopyright: false, shownavigation: false});
 *   var gpex2_p1 = gpex2_board.create('point', [2.0, 2.0]);
 *   var gpex2_c1 = gpex2_board.create('circle', [gpex2_p1, 2.0]);
 *   var gpex2_p2 = gpex2_board.create('glider', [gpex2_c1]);
 * </script><pre>
 *@example
 * //animate example 2
 * var p1 = board.create('point', [2.0, 2.0]);
 * var c1 = board.create('circle', [p1, 2.0]);
 * var p2 = board.create('glider', [c1]);
 * var button1 = board.create('button', [1, 7, 'start animation',function(){p2.startAnimation(1,4)}]);
 * var button2 = board.create('button', [1, 5, 'stop animation',function(){p2.stopAnimation()}]);
 * </pre><div class="jxgbox" id="JXG4de7f181-631a-44b1-a12f-bc4d133709e8" style="width: 200px; height: 200px;"></div>
 * <script type="text/javascript">
 *   var gpex3_board = JXG.JSXGraph.initBoard('JXG4de7f181-631a-44b1-a12f-bc4d133709e8', {boundingbox: [-1, 10, 10, -1], axis: true, showcopyright: false, shownavigation: false});
 *   var gpex3_p1 = gpex3_board.create('point', [2.0, 2.0]);
 *   var gpex3_c1 = gpex3_board.create('circle', [gpex3_p1, 2.0]);
 *   var gpex3_p2 = gpex3_board.create('glider', [gpex3_c1]);
 *   gpex3_board.create('button', [1, 7, 'start animation',function(){gpex3_p2.startAnimation(1,4)}]);
 *   gpex3_board.create('button', [1, 5, 'stop animation',function(){gpex3_p2.stopAnimation()}]);
 * </script><pre>
 */
function createGlider(board, parents, attributes) {
    var el, coords, attr = Type.copyAttributes(attributes, board.options, "glider");
    if (parents.length === 1) {
        coords = [0, 0];
    }
    else {
        coords = parents.slice(0, 2);
    }
    el = board.create("point", coords, attr);
    // eltype is set in here
    el.makeGlider(parents[parents.length - 1]);
    return el;
}
/**
 * @class A point intersecting two 1-dimensional elements.
 * It is one point of the set  * consisting of the intersection points of the two elements.
 * The following element types can be (mutually) intersected: line, circle,
 * curve, polygon, polygonal chain.
 *
 * @pseudo
 * @name Intersection
 * @augments JXG.Point
 * @constructor
 * @type JXG.Point
 * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.
 * @param {JXG.Line,JXG.Circle_JXG.Line,JXG.Circle_Number|Function} el1,el2,i The result will be a intersection point on el1 and el2. i determines the
 * intersection point if two points are available: <ul>
 *   <li>i==0: use the positive square root,</li>
 *   <li>i==1: use the negative square root.</li></ul>
 * @example
 * // Create an intersection point of circle and line
 * var p1 = board.create('point', [4.0, 4.0]);
 * var c1 = board.create('circle', [p1, 2.0]);
 *
 * var p2 = board.create('point', [1.0, 1.0]);
 * var p3 = board.create('point', [5.0, 3.0]);
 * var l1 = board.create('line', [p2, p3]);
 *
 * var i = board.create('intersection', [c1, l1, 0]);
 * </pre><div class="jxgbox" id="JXGe5b0e190-5200-4bc3-b995-b6cc53dc5dc0" style="width: 300px; height: 300px;"></div>
 * <script type="text/javascript">
 *   var ipex1_board = JXG.JSXGraph.initBoard('JXGe5b0e190-5200-4bc3-b995-b6cc53dc5dc0', {boundingbox: [-1, 7, 7, -1], axis: true, showcopyright: false, shownavigation: false});
 *   var ipex1_p1 = ipex1_board.create('point', [4.0, 4.0]);
 *   var ipex1_c1 = ipex1_board.create('circle', [ipex1_p1, 2.0]);
 *   var ipex1_p2 = ipex1_board.create('point', [1.0, 1.0]);
 *   var ipex1_p3 = ipex1_board.create('point', [5.0, 3.0]);
 *   var ipex1_l1 = ipex1_board.create('line', [ipex1_p2, ipex1_p3]);
 *   var ipex1_i = ipex1_board.create('intersection', [ipex1_c1, ipex1_l1, 0]);
 * </script><pre>
 */
function createIntersectionPoint(board, parents, attributes) {
    var el, el1, el2, func, i, j, attr = Type.copyAttributes(attributes, board.options, "intersection");
    // make sure we definitely have the indices
    parents.push(0, 0);
    el1 = board.select(parents[0]);
    el2 = board.select(parents[1]);
    i = parents[2] || 0;
    j = parents[3] || 0;
    el = board.create("point", [0, 0, 0], attr);
    // el.visProp.alwaysintersect is evaluated as late as in the returned function
    func = Geometry.intersectionFunction(board, el1, el2, i, j, el.visProp.alwaysintersect);
    el.addConstraint([func]);
    try {
        el1.addChild(el);
        el2.addChild(el);
    }
    catch (e) {
        throw new Error("JSXGraph: Can't create 'intersection' with parent types '" +
            typeof parents[0] +
            "' and '" +
            typeof parents[1] +
            "'.");
    }
    el.type = OBJECT_TYPE.INTERSECTION;
    el.elType = "intersection";
    el.setParents([el1.id, el2.id]);
    /**
     * Array of length 2 containing the numbers i and j.
     * The intersection point is i-th intersection point.
     * j is unused.
     * @type Array
     * @name intersectionNumbers
     * @memberOf Intersection
     * @private
     */
    el.intersectionNumbers = [i, j];
    el.getParents = function () {
        return this.parents.concat(this.intersectionNumbers);
    };
    el.generatePolynomial = function () {
        var poly1 = el1.generatePolynomial(el), poly2 = el2.generatePolynomial(el);
        if (poly1.length === 0 || poly2.length === 0) {
            return [];
        }
        return [poly1[0], poly2[0]];
    };
    return el;
}
/**
 * @class Given a set of intersection points, this is another ("other") intersection point,
 * @pseudo
 * @description If two elements of type curve, circle or line intersect in more than one point, with this element it is possible
 * to construct the "other" intersection. This is a an intersection which is different from a supplied point or different from any
 * point in an array of supplied points. This might be helpful in situtations where one intersection point is already part of the construction
 * or in situtation where the order of the intersection points changes while interacting with the construction.
 *
 * @name OtherIntersection
 * @augments JXG.Point
 * @constructor
 * @type JXG.Point
 * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.
 * @param {JXG.Line,JXG.Circle_JXG.Line,JXG.Circle_JXG.Point,Array} el1,el2,p Two elements which are intersected and a point or an array of points
 * which have to be different from the new intersection point.
 *
 * @example
 * // Create an intersection point of circle and line
 * var p1 = board.create('point', [2.0, 2.0]);
 * var c1 = board.create('circle', [p1, 2.0]);
 *
 * var p2 = board.create('point', [2.0, 2.0]);
 * var p3 = board.create('point', [2.0, 2.0]);
 * var l1 = board.create('line', [p2, p3]);
 *
 * var p1 = board.create('intersection', [c1, l1, 0]);
 * var p2 = board.create('otherintersection', [c1, l1, p1]);
 * </pre><div class="jxgbox" id="JXG45e25f12-a1de-4257-a466-27a2ae73614c" style="width: 300px; height: 300px;"></div>
 * <script type="text/javascript">
 *   var ipex2_board = JXG.JSXGraph.initBoard('JXG45e25f12-a1de-4257-a466-27a2ae73614c', {boundingbox: [-1, 7, 7, -1], axis: false, showcopyright: false, shownavigation: false});
 *   var ipex2_p1 = ipex2_board.create('point', [4.0, 4.0]);
 *   var ipex2_c1 = ipex2_board.create('circle', [ipex2_p1, 2.0]);
 *   var ipex2_p2 = ipex2_board.create('point', [1.0, 1.0]);
 *   var ipex2_p3 = ipex2_board.create('point', [5.0, 3.0]);
 *   var ipex2_l1 = ipex2_board.create('line', [ipex2_p2, ipex2_p3]);
 *   var ipex2_i = ipex2_board.create('intersection', [ipex2_c1, ipex2_l1, 0], {name:'D'});
 *   var ipex2_j = ipex2_board.create('otherintersection', [ipex2_c1, ipex2_l1, ipex2_i], {name:'E'});
 * </script><pre>
 *
 * @example
 *  // circle / circle
 *  var c1 = board.create('circle', [[0, 0], 3]);
 *  var c2 = board.create('circle', [[2, 2], 3]);
 *
 *  var p1 = board.create('intersection', [c1, c2, 0]);
 *  var p2 = board.create('otherintersection', [c1, c2, p1]);
 *
 * </pre><div id="JXGdb5c974c-3092-4cdf-b5ef-d0af4a912581" class="jxgbox" style="width: 300px; height: 300px;"></div>
 * <script type="text/javascript">
 *     (function() {
 *         var board = JXG.JSXGraph.initBoard('JXGdb5c974c-3092-4cdf-b5ef-d0af4a912581',
 *             {boundingbox: [-8, 8, 8,-8], axis: false, showcopyright: false, shownavigation: false});
 *           var c1 = board.create('circle', [[0, 0], 3]);
 *           var c2 = board.create('circle', [[2, 2], 3]);
 *
 *           var p1 = board.create('intersection', [c1, c2, 0]);
 *           var p2 = board.create('otherintersection', [c1, c2, p1]);
 *     })();
 * </script><pre>
 *
 * @example
 *  // curve / line
 *  var curve = board.create('implicitcurve', ['-(y**2) + x**3 - 2 * x + 1'], { strokeWidth: 2 });
 *  var A = board.create('glider', [-1.5, 1, curve]);
 *  var B = board.create('glider', [0.5, 0.5, curve]);
 *  var line = board.create('line', [A, B], { color: 'black', strokeWidth: 1 });
 *  var C = board.create('otherintersection', [curve, line, [A, B]], {precision: 0.01});
 *  var D = board.create('point', [() => C.X(), () => -C.Y()], { name: '-C = A + B' });
 *
 * </pre><div id="JXG033f15b0-f5f1-4003-ab6a-b7e13e867fbd" class="jxgbox" style="width: 300px; height: 300px;"></div>
 * <script type="text/javascript">
 *     (function() {
 *         var board = JXG.JSXGraph.initBoard('JXG033f15b0-f5f1-4003-ab6a-b7e13e867fbd',
 *             {boundingbox: [-2, 2, 2, -2], axis: false, showcopyright: false, shownavigation: false});
 *           var curve = board.create('implicitcurve', ['-(y**2) + x**3 - 2 * x + 1'], { strokeWidth: 2 });
 *           var A = board.create('glider', [-1.5, 1, curve]);
 *           var B = board.create('glider', [0.5, 0.5, curve]);
 *           var line = board.create('line', [A, B], { color: 'black', strokeWidth: 1 });
 *           var C = board.create('otherintersection', [curve, line, [A, B]], {precision: 0.01});
 *           var D = board.create('point', [() => C.X(), () => -C.Y()], { name: '-C = A + B' });
 *     })();
 * </script><pre>
 *
 * @example
 *  // curve / curve
 *  var c1 = board.create('functiongraph', ['x**2 - 3'], { strokeWidth: 2 });
 *  var A = board.create('point', [0, 2]);
 *  var c2 = board.create('functiongraph', [(x) => -(x**2) + 2 * A.X() * x + A.Y() - A.X()**2], { strokeWidth: 2 });
 *  var p1 = board.create('intersection', [c1, c2]);
 *  var p2 = board.create('otherintersection', [c1, c2, [p1]]);
 *
 * </pre><div id="JXG29359aa9-3066-4f45-9e5d-d74201b991d3" class="jxgbox" style="width: 300px; height: 300px;"></div>
 * <script type="text/javascript">
 *     (function() {
 *         var board = JXG.JSXGraph.initBoard('JXG29359aa9-3066-4f45-9e5d-d74201b991d3',
 *             {boundingbox: [-5, 5, 5, -5], axis: true, showcopyright: false, shownavigation: false});
 *           var c1 = board.create('functiongraph', ['x**2 - 3'], { strokeWidth: 2 });
 *           var A = board.create('point', [0, 2]);
 *           var c2 = board.create('functiongraph', [(x) => -(x**2) + 2 * A.X() * x + A.Y() - A.X()**2], { strokeWidth: 2 });
 *           var p1 = board.create('intersection', [c1, c2]);
 *           var p2 = board.create('otherintersection', [c1, c2, [p1]]);
 *     })();
 * </script><pre>
 *
 */
function createOtherIntersectionPoint(board, parents, attributes) {
    var el, el1, el2, i, others, func, input, isGood = true, attr = Type.copyAttributes(attributes, board.options, 'otherintersection');
    if (parents.length !== 3) {
        isGood = false;
    }
    else {
        el1 = board.select(parents[0]);
        el2 = board.select(parents[1]);
        if (Array.isArray(parents[2])) {
            others = parents[2];
        }
        else {
            others = [parents[2]];
        }
        for (i = 0; i < others.length; i++) {
            others[i] = board.select(others[i]);
            if (!Type.isPoint(others[i])) {
                isGood = false;
                break;
            }
        }
        if (isGood) {
            input = [el1, el2];
            // Sort parent elements in order: curve, circle, line
            input.sort(function (a, b) { return b.elementClass - a.elementClass; });
            // Two lines are forbidden:
            if ([OBJECT_CLASS.CIRCLE, OBJECT_CLASS.CURVE].indexOf(input[0].elementClass) < 0) {
                isGood = false;
            }
            else if ([OBJECT_CLASS.CIRCLE, OBJECT_CLASS.CURVE, OBJECT_CLASS.LINE].indexOf(input[1].elementClass) < 0) {
                isGood = false;
            }
        }
    }
    if (!isGood) {
        throw new Error("JSXGraph: Can't create 'other intersection point' with parent types '" +
            typeof parents[0] + "',  '" + typeof parents[1] + "'and  '" + typeof parents[2] + "'." +
            "\nPossible parent types: [circle|curve|line,circle|curve|line, point], not two lines");
    }
    el = board.create('point', [0, 0, 0], attr);
    // el.visProp.alwaysintersect is evaluated as late as in the returned function
    func = Geometry.otherIntersectionFunction(input, others, el.visProp.alwaysintersect, el.visProp.precision);
    el.addConstraint([func]);
    el.type = OBJECT_TYPE.INTERSECTION;
    el.elType = "otherintersection";
    el.setParents([el1.id, el2.id]);
    el.addParents(others);
    el1.addChild(el);
    el2.addChild(el);
    if (el1.elementClass === OBJECT_CLASS.CIRCLE) {
        // circle, circle|line
        el.generatePolynomial = function () {
            var poly1 = el1.generatePolynomial(el), poly2 = el2.generatePolynomial(el);
            if (poly1.length === 0 || poly2.length === 0) {
                return [];
            }
            return [poly1[0], poly2[0]];
        };
    }
    return el;
}
/**
 * @class This element is used to provide a constructor for the pole point of a line with respect to a conic or a circle.
 * @pseudo
 * @description The pole point is the unique reciprocal relationship of a line with respect to a conic.
 * The lines tangent to the intersections of a conic and a line intersect at the pole point of that line with respect to that conic.
 * A line tangent to a conic has the pole point of that line with respect to that conic as the tangent point.
 * See {@link https://en.wikipedia.org/wiki/Pole_and_polar} for more information on pole and polar.
 * @name PolePoint
 * @augments JXG.Point
 * @constructor
 * @type JXG.Point
 * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.
 * @param {JXG.Conic,JXG.Circle_JXG.Point} el1,el2 or
 * @param {JXG.Point_JXG.Conic,JXG.Circle} el1,el2 The result will be the pole point of the line with respect to the conic or the circle.
 * @example
 * // Create the pole point of a line with respect to a conic
 * var p1 = board.create('point', [-1, 2]);
 * var p2 = board.create('point', [ 1, 4]);
 * var p3 = board.create('point', [-1,-2]);
 * var p4 = board.create('point', [ 0, 0]);
 * var p5 = board.create('point', [ 4,-2]);
 * var c1 = board.create('conic',[p1,p2,p3,p4,p5]);
 * var p6 = board.create('point', [-1, 4]);
 * var p7 = board.create('point', [2, -2]);
 * var l1 = board.create('line', [p6, p7]);
 * var p8 = board.create('polepoint', [c1, l1]);
 * </pre><div class="jxgbox" id="JXG7b7233a0-f363-47dd-9df5-8018d0d17a98" class="jxgbox" style="width:400px; height:400px;"></div>
 * <script type='text/javascript'>
 * var ppex1_board = JXG.JSXGraph.initBoard('JXG7b7233a0-f363-47dd-9df5-8018d0d17a98', {boundingbox: [-3, 5, 5, -3], axis: true, showcopyright: false, shownavigation: false});
 * var ppex1_p1 = ppex1_board.create('point', [-1, 2]);
 * var ppex1_p2 = ppex1_board.create('point', [ 1, 4]);
 * var ppex1_p3 = ppex1_board.create('point', [-1,-2]);
 * var ppex1_p4 = ppex1_board.create('point', [ 0, 0]);
 * var ppex1_p5 = ppex1_board.create('point', [ 4,-2]);
 * var ppex1_c1 = ppex1_board.create('conic',[ppex1_p1,ppex1_p2,ppex1_p3,ppex1_p4,ppex1_p5]);
 * var ppex1_p6 = ppex1_board.create('point', [-1, 4]);
 * var ppex1_p7 = ppex1_board.create('point', [2, -2]);
 * var ppex1_l1 = ppex1_board.create('line', [ppex1_p6, ppex1_p7]);
 * var ppex1_p8 = ppex1_board.create('polepoint', [ppex1_c1, ppex1_l1]);
 * </script><pre>
 * @example
 * // Create the pole point of a line with respect to a circle
 * var p1 = board.create('point', [1, 1]);
 * var p2 = board.create('point', [2, 3]);
 * var c1 = board.create('circle',[p1,p2]);
 * var p3 = board.create('point', [-1, 4]);
 * var p4 = board.create('point', [4, -1]);
 * var l1 = board.create('line', [p3, p4]);
 * var p5 = board.create('polepoint', [c1, l1]);
 * </pre><div class="jxgbox" id="JXG7b7233a0-f363-47dd-9df5-9018d0d17a98" class="jxgbox" style="width:400px; height:400px;"></div>
 * <script type='text/javascript'>
 * var ppex2_board = JXG.JSXGraph.initBoard('JXG7b7233a0-f363-47dd-9df5-9018d0d17a98', {boundingbox: [-3, 7, 7, -3], axis: true, showcopyright: false, shownavigation: false});
 * var ppex2_p1 = ppex2_board.create('point', [1, 1]);
 * var ppex2_p2 = ppex2_board.create('point', [2, 3]);
 * var ppex2_c1 = ppex2_board.create('circle',[ppex2_p1,ppex2_p2]);
 * var ppex2_p3 = ppex2_board.create('point', [-1, 4]);
 * var ppex2_p4 = ppex2_board.create('point', [4, -1]);
 * var ppex2_l1 = ppex2_board.create('line', [ppex2_p3, ppex2_p4]);
 * var ppex2_p5 = ppex2_board.create('polepoint', [ppex2_c1, ppex2_l1]);
 * </script><pre>
 */
function createPolePoint(board, parents, attributes) {
    var el, el1, el2, firstParentIsConic, secondParentIsConic, firstParentIsLine, secondParentIsLine;
    if (parents.length > 1) {
        firstParentIsConic =
            parents[0].type === OBJECT_TYPE.CONIC ||
                parents[0].elementClass === OBJECT_CLASS.CIRCLE;
        secondParentIsConic =
            parents[1].type === OBJECT_TYPE.CONIC ||
                parents[1].elementClass === OBJECT_CLASS.CIRCLE;
        firstParentIsLine = parents[0].elementClass === OBJECT_CLASS.LINE;
        secondParentIsLine = parents[1].elementClass === OBJECT_CLASS.LINE;
    }
    /*        if (parents.length !== 2 || !((
                parents[0].type === OBJECT_TYPE.CONIC ||
                parents[0].elementClass === OBJECT_CLASS.CIRCLE) &&
                parents[1].elementClass === OBJECT_CLASS.LINE ||
                parents[0].elementClass === OBJECT_CLASS.LINE && (
                parents[1].type === OBJECT_TYPE.CONIC ||
                parents[1].elementClass === OBJECT_CLASS.CIRCLE))) {*/
    if (parents.length !== 2 ||
        !((firstParentIsConic && secondParentIsLine) ||
            (firstParentIsLine && secondParentIsConic))) {
        // Failure
        throw new Error("JSXGraph: Can't create 'pole point' with parent types '" +
            typeof parents[0] +
            "' and '" +
            typeof parents[1] +
            "'." +
            "\nPossible parent type: [conic|circle,line], [line,conic|circle]");
    }
    if (secondParentIsLine) {
        el1 = board.select(parents[0]);
        el2 = board.select(parents[1]);
    }
    else {
        el1 = board.select(parents[1]);
        el2 = board.select(parents[0]);
    }
    el = board.create("point", [
        function () {
            var q = el1.quadraticform, s = el2.stdform.slice(0, 3);
            return [
                Numerics.det([s, q[1], q[2]]),
                Numerics.det([q[0], s, q[2]]),
                Numerics.det([q[0], q[1], s])
            ];
        }
    ], attributes);
    el.elType = "polepoint";
    el.setParents([el1.id, el2.id]);
    el1.addChild(el);
    el2.addChild(el);
    return el;
}
console.warn('point has been loaded !!');
JXG_registerElement("point", createPoint);
JXG_registerElement("glider", createGlider);
JXG_registerElement("intersection", createIntersectionPoint);
JXG_registerElement("otherintersection", createOtherIntersectionPoint);
JXG_registerElement("polepoint", createPolePoint);

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */
/*global JXG: true, define: true, AMprocessNode: true, MathJax: true, window: true, document: true, init: true, translateASCIIMath: true, google: true*/
/*jslint nomen: true, plusplus: true*/
/**
 * @fileoverview The JXG.Board class is defined in this file. JXG.Board controls all properties and methods
 * used to manage a geonext board like managing geometric elements, managing mouse and touch events, etc.
 */
class Board extends Events {
    constructor(container = '', renderer, id, origin, zoomX, zoomY, unitX, unitY, canvasWidth, canvasHeight, attributes) {
        super();
        /**
         * Constant: the small gray version indicator in the top left corner of every JSXGraph board (if
         * showCopyright is not set to false on board creation).
         */
        this.licenseText = `JSXGraph v${JXG.version} \u00A9 jsxgraph.org`;
        /**
         * JSXGraph logo: base64 data-URL of img/png/screen/jsxgraph-logo_black-square-solid.png
         */
        this.licenseLogo = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJ8AAACfCAYAAADnGwvgAAAACXBIWXMAAAsSAAALEgHS3X78AAAIPklEQVR4nO2d21XjSBCG/96z75ABzgBPBHgiWDLARDCeCBAZeCMYO4KFCEbOwM7AZIAjqH1QiTHGF7XUF7X6/87xw4APqodv+qaqaiMiICQGf8UOgOQL5SPRoHwkGpSPROPv2AH4whhzDWCs/xwDuI4YTu4sRGR7+MPByGeMGQG4BzBBJdtNxHDIZ0oA28MfJi2fCjfVD2VLjCTlU+kKAA9RAyGdSEo+SjcskpHPGFMAmAG4ihwKcUTv5dPR7gXAbdxIiGt6fc5njJkAWIPiDZLeymeMmQL4DU6zg6WX8ql4v2LHQfzSO/koXj70Sj6Klxd92+2uAXyPHQS5yBQOzlp7JZ+IrGPHQC6jpxCd6dW0S/KC8pFoUD4SDcpHokH5SDQoH4kG5SPRoHwkGpSPRCPaGw5jzBjACFWl2Ug/JB4LEVmEfGAw+bSO9h5/yhuZp9cvytAP9C6fvgecAfjH97NIWniTT9OjCrCelpzAuXw60hUA7lz/bTIsnMmna7oCwA9Xf5MMGyfy6c51AVaZEQs6n/Pp2q4ExSOWdBr5WHNButB65KN4pCut5KN4xAXW8ulRCsUjnbGSb69pDyGdsR35XsB3ssQRjeXT/ng8TiHOaCSfTrczr5GQ7Gg68hXgdEscc/GQWUc99kC+zArAO6p+M4fU94Aw2WKPJm84Ct9BJMorqteKpU2PGX0PPkGVVJu1jGfl46j3hTcAc1Qp5+9t/oCKugYwz/0ekUtrvmmIIBLgDcCjiIxEZN5WvENEZCsihYiMADzqc7KB8p1nB+BZpVv4fJD+/TGAZ5/P6RMn5dMpIbupYI8NgLGIFKEeKCLv+rxv+vxBc27kuw8WRf9Yisj42E2JIdB14QTAMsbzQ3FOvkmoIHrGTxGZxg5CR8EpBizgud3u+Mzvhspj6MLpS4jI1BgDDPDU4ejIp8VAua33nvsmXs1QR8BT025uo94y5MaiDSrga+w4XNKrbvSR2MBR0oS+vbjG5/VyCeDdUaf9KaoD6kHMSqfky2nkm3Y5NDbG1P1n7nE8+eJJv7dDlQ+5EJGyzbNE5H3vTrrkOTXtXgeNIh7PbUckY8y9MWYL4D9Um4FLWT9X+r3fxph127ssVNxBrP9y7s+3Q/We1gpjzLUx5gWVdG2nv1tUEi50c2fLDFX8SZOzfDPb6VbXdCXcddx6AFDaCqhxW//H6Ru5ylevvxqzJ57rUoJbtBAQlC9ZrFKiVIwF/GVz38KyOaPGn/TaL1f5bEeNAv6Lp261SMuGhYc4gpGjfG82CQO6Kw3V9u1Js4kaoTvfZDceOcpnW/Re+AjC4fOSLeLPUb6y6Rd1kxG6zuLBZvRDhEberqB855l6iuESNrmUyV6QnZ18lmd7E19xXKCxfCnfzp6bfCvL78dqD2I71Se56chNvsa0ffcaiSRHP8rXUxKTvxWUj0SD8vUXJ4XpfYbynWYb8+GWu9gk8y9zk2/U9Iv6Ci7WLtK2bUaSTTtzk882+bP0EYTL57ZMRu0FuclXvzJrSqz3pjbPTbbeJjv5YPfW4gXhp96diNjIN/EViG9ClU6+oXnu2Qh+q/MnaJjPp9Vic2gFWiBscw0nPoIIQSj5tk2LsvVw1bd8NsxRFeyE6EldN59shK73ku1umuO0e6W1to3QRISpv3A+YVtDnHQnsRzlAyw7FOga7F9PsdT8bFFMnvT1FLnKd2eZsAkRmcFfwc5SRKzWero8SfJ8ryZX+YAW6fHarMd129rHlv0AC8dxBCdn+R7aZI7oxuk7ujfv3gD41qYtm8ad7EajJmf5gJaF1yJSduggX3e2H7fJQt6rIU6e3OVrUyv7gYgsVMJvqKbjFb4eSr/pz59RjXRdO9sXGHiLtJx4Msa8dKmF2LvYxSuBa4i9k/vIV9OmV0pQ9J10sjW6x6B8FVfosYAa1+Au2qZ8f2jbLcorGk+Jgazz9qF8n6kFHEWOA8DHVLtG4ofJp6B8X7kF0LptrSv0/XOJAY54NZTvOFeo2tbOQ0/D2nZ3jqrt7qDWeIdQvvP8QDUKBske0U7zawzoOOUclO8yNwD+M8aUviQ0xky1s/0vDHiaPYSHzM25Q5UNU2dlL7rcSqmbiSmqnLxshNuH8tlzgyqt/klFLPWzBbA+lgyq68bx3meCTIXbh/J14wZVyv9H2r/eEEkawDUfiQblIyHYHvsh5SPeObUxo3zENyeL7ikf8c3JPEfKR3xD+Ug0KB+JRnnqF5SP+GRz7hUk5SM+WZz7JeUjPjlb8ET5iC9Wl7J+KB/xRXHpC5SP+GDVpN0b5SM+KJp8ifIR17w2bXJJ+YhLdrBoIUz5iEusekpTPuKKpeX9IZSPOGHTprUv5SNd2aDlRTSUj3RhA2BieXfIB70rndRtehL1h8aYEgNozN2STuIBHPlIOxboKB7Qw5GP9J8ubUL24chHasrQD6R8JBqUjwD42OgFhfIRoNq5BofyESDABTbHoHwEiLDZACgfqYhysxHlI69dD4vbEuqQ+c4YI4GeReyIdp8bR768eet4/WonKF/eLGI+nPLlyw4tb1p3BeXLl1msjUYN5cuTVcy1Xg3ly5NZ7AAAypcjP0Ukyuu0QyhfXixFJOomYx/Klw8b9GS6raF8edC52McHlG/49FI8gPINnd6KB1C+IbMUkXFfxQNYOjlEdqi6RUXLVmkKR75h8QpglIJ4AOUbCisA30Xkvs/T7CGcdtNmBaCIUfboAsqXHhtUeXgvrtpWxILy9ZsdqrLG+lOmLtw+RuRraYUxZgRgFDgW8oftkCQ7xVH5CAkBd7skGpSPRIPykWhQPhKN/wEKYnCiOMadyQAAAABJRU5ErkJggg==';
        this.isSuspendedUpdate = false;
        /**
         * Keep aspect ratio if bounding box is set and the width/height ratio differs from the
         * width/height ratio of the canvas.
         * @type Boolean
         * @private
         */
        this.keepaspectratio = false;
        this.hooks = [];
        /**
         * An array containing all other boards that are updated after this board has been updated.
         * @type Array
         * @see JXG.Board#addChild
         * @see JXG.Board#removeChild
         */
        this.dependentBoards = [];
        /**
         * During the update process this is set to false to prevent an endless loop.
         * @default false
         * @type Boolean
         */
        this.inUpdate = false;
        /**
         * An associative array containing all geometric objects belonging to the board. Key is the id of the object and value is a reference to the object.
         * @type Object
         */
        this.objects = {};
        /**
         * An array containing all geometric objects on the board in the order of construction.
         * @type Array
         */
        this.objectsList = [];
        /**
         * An associative array containing all groups belonging to the board. Key is the id of the group and value is a reference to the object.
         * @type Object
         */
        this.groups = {};
        /**
         * Stores all the objects that are currently running an animation.
         * @type Object
         */
        this.animationObjects = {};
        /**
         * An associative array containing all highlighted elements belonging to the board.
         * @type Object
         */
        this.highlightedObjects = {};
        /**
         * Number of objects ever created on this board. This includes every object, even invisible and deleted ones.
         * @type Number
         */
        this.numObjects = 0;
        /**
         * An associative array / dictionary to store the objects of the board by name. The name of the object is the key and value is a reference to the object.
         * @type Object
         */
        this.elementsByName = {};
        /**
         * The board mode the board is currently in. Possible values are
         * <ul>
         * <li>JXG.Board.BOARD_MODE.NONE</li>
         * <li>JXG.Board.BOARD_MODE.DRAG</li>
         * <li>JXG.Board.BOARD_MODE.MOVE_ORIGIN</li>
         * </ul>
         * @type Number
         */
        this.mode = BOARD_MODE.NONE;
        /**
         * The update quality of the board. In most cases this is set to {@link JXG.Board#BOARD_QUALITY_HIGH}.
         * If {@link JXG.Board#mode} equals {@link JXG.Board#BOARD_MODE_DRAG} this is set to
         * {@link JXG.Board#BOARD_QUALITY_LOW} to speed up the update process by e.g. reducing the number of
         * evaluation points when plotting functions. Possible values are
         * <ul>
         * <li>BOARD_QUALITY_LOW</li>
         * <li>BOARD_QUALITY_HIGH</li>
         * </ul>
         * @type Number
         * @see JXG.Board#mode
         */
        this.updateQuality = BOARD_QUALITY.HIGH;
        /**
         * If true updates are skipped.
         * @type Boolean
         */
        this.isSuspendedRedraw = false;
        /**
         * The distance from the mouse to the dragged object in x direction when the user clicked the mouse button.
         * @type Number
         * @see JXG.Board#drag_dy
         */
        this.drag_dx = 0;
        /**
         * The distance from the mouse to the dragged object in y direction when the user clicked the mouse button.
         * @type Number
         * @see JXG.Board#drag_dx
         */
        this.drag_dy = 0;
        /**
         * The last position where a drag event has been fired.
         * @type Array
         * @see JXG.Board#moveObject
         */
        this.drag_position = [0, 0];
        /**
         * References to the object that is dragged with the mouse on the board.
         * @type JXG.GeometryElement
         * @see JXG.Board#touches
         */
        this.mouse = {};
        /**
         * Keeps track on touched elements, like {@link JXG.Board#mouse} does for mouse events.
         * @type Array
         * @see JXG.Board#mouse
         */
        this.touches = [];
        /**
         * A string containing the XML text of the construction.
         * This is set in {@link JXG.FileReader.parseString}.
         * Only useful if a construction is read from a GEONExT-, Intergeo-, Geogebra-, or Cinderella-File.
         * @type String
         */
        this.xmlString = '';
        /**
         * Cached result of getCoordsTopLeftCorner for touch/mouseMove-Events to save some DOM operations.
         * @type Array
         */
        this.cPos = [];
        /**
         * Contains the last time (epoch, msec) since the last touchMove event which was not thrown away or since
         * touchStart because Android's Webkit browser fires too much of them.
         * @type Number
         */
        this.touchMoveLast = 0;
        /**
         * Contains the pointerId of the last touchMove event which was not thrown away or since
         * touchStart because Android's Webkit browser fires too much of them.
         * @type Number
         */
        this.touchMoveLastId = Infinity;
        /**
         * Contains the last time (epoch, msec) since the last getCoordsTopLeftCorner call which was not thrown away.
         * @type Number
         */
        this.positionAccessLast = 0;
        /**
         * Collects all elements that triggered a mouse down event.
         * @type Array
         */
        this.downObjects = [];
        this.clickObjects = {};
        /**
         * Collects all elements that have keyboard focus. Should be either one or no element.
         * Elements are stored with their id.
         * @type Array
         */
        this.focusObjects = [];
        /**
         * Full updates are needed after zoom and axis translates. This saves some time during an update.
         * @default false
         * @type Boolean
         */
        this.needsFullUpdate = false;
        /**
         * If reducedUpdate is set to true then only the dragged element and few (e.g. 2) following
         * elements are updated during mouse move. On mouse up the whole construction is
         * updated. This enables us to be fast even on very slow devices.
         * @type Boolean
         * @default false
         */
        this.reducedUpdate = false;
        /**
         * The current color blindness deficiency is stored in this property. If color blindness is not emulated
         * at the moment, it's value is 'none'.
         */
        this.currentCBDef = 'none';
        /**
         * If GEONExT constructions are displayed, then this property should be set to true.
         * At the moment there should be no difference. But this may change.
         * This is set in {@link JXG.GeonextReader.readGeonext}.
         * @type Boolean
         * @default false
         * @see JXG.GeonextReader.readGeonext
         */
        this.geonextCompatibilityMode = false;
        /**
         * A flag which tells if the board registers mouse events.
         * @type Boolean
         * @default false
         */
        this.hasMouseHandlers = false;
        /**
         * A flag which tells if the board registers touch events.
         * @type Boolean
         * @default false
         */
        this.hasTouchHandlers = false;
        /**
         * A flag which stores if the board registered pointer events.
         * @type Boolean
         * @default false
         */
        this.hasPointerHandlers = false;
        /**
         * A flag which stores if the board registered zoom events, i.e. mouse wheel scroll events.
         * @type Boolean
         * @default false
         */
        this.hasWheelHandlers = false;
        /**
         * A flag which tells if the board the JXG.Board#mouseUpListener is currently registered.
         * @type Boolean
         * @default false
         */
        this.hasMouseUp = false;
        /**
         * A flag which tells if the board the JXG.Board#touchEndListener is currently registered.
         * @type Boolean
         * @default false
         */
        this.hasTouchEnd = false;
        /**
         * A flag which tells us if the board has a pointerUp event registered at the moment.
         * @type Boolean
         * @default false
         */
        this.hasPointerUp = false;
        /**
         * Array containing the events related to resizing that have event listeners.
         * @type Array
         * @default []
         */
        this.resizeHandlers = [];
        /**
         * Offset for large coords elements like images
         * @type Array
         * @private
         * @default [0, 0]
         */
        this._drag_offset = [0, 0];
        /**
         * Stores the input device used in the last down or move event.
         * @type String
         * @private
         * @default 'mouse'
         */
        this._inputDevice = 'mouse';
        /**
         * Keeps a list of pointer devices which are currently touching the screen.
         * @type Array
         * @private
         */
        this._board_touches = [];
        /**
         * A flag which tells us if the board is in the selecting mode
         * @type Boolean
         * @default false
         */
        this.selectingMode = false;
        /**
         * A flag which tells us if the user is selecting
         * @type Boolean
         * @default false
         */
        this.isSelecting = false;
        /**
         * A flag which tells us if the user is scrolling the viewport
         * @type Boolean
         * @private
         * @default false
         * @see JXG.Board#scrollListener
         */
        this._isScrolling = false;
        /**
         * A flag which tells us if a resize is in process
         * @type Boolean
         * @private
         * @default false
         * @see JXG.Board#resizeListener
         */
        this._isResizing = false;
        /**
         * A flag which tells us if the update is triggered by a change of the
         * 3D view. In that case we only have to update the projection of
         * the 3D elements and can avoid a full board update.
         *
         * @type Boolean
         * @private
         * @default false
         */
        this._change3DView = false;
        /**
         * A bounding box for the selection
         * @type Array
         * @default [ [0,0], [0,0] ]
         */
        this.selectingBox = [[0, 0], [0, 0]];
        /**
         * Array to log user activity.
         * Entries are objects of the form '{type, id, start, end}' notifying
         * the start time as well as the last time of a single event of type 'type'
         * on a JSXGraph element of id 'id'.
         * <p> 'start' and 'end' contain the amount of milliseconds elapsed between 1 January 1970 00:00:00 UTC
         * and the time the event happened.
         * <p>
         * For the time being (i.e. v1.5.0) the only supported type is 'drag'.
         * @type Array
         */
        this.userLog = [];
        /**
        * ID of the board
        * @type String
        */
        this.id = '';
        /**
         * Grids keeps track of all grids attached to this board.
         * @type Array
         * @private
         */
        this.grids = [];
        this.hasFullscreenEventHandlers = false;
        this.hasKeyboardHandlers = false;
        this._fullscreen_inner_id = '';
        this.licenseText = `JSXGraph v${JXG.version} \u00A9 jsxgraph.org`;
        if (('document' in attributes) && attributes.document !== false && attributes.document !== null) {
            this.document = attributes.document;
        }
        else if (Env.isBrowser) {
            this.document = document;
        }
        this.container = container;
        /**
         * Pointer to the html element containing the board.
         * @type Object
         */
        this.containerObj = null; // (Env.isBrowser ? this.document.getElementById(this.container) : null);
        // Set this.container and this.containerObj
        if (Type.isString(container)) {
            // Hosting div is given as string
            this.container = container; // container
            this.containerObj = (Env.isBrowser ? document.getElementById(this.container) : null);
        }
        else if (Env.isBrowser) {
            // Hosting div is given as object pointer
            this.containerObj = container;
            this.container = this.containerObj.getAttribute('id');
            if (this.container === null) {
                // Set random ID to this.container, but not to the DOM element
                this.container = 'null' + (Math.random() * 16777216).toString();
            }
        }
        if (Env.isBrowser && renderer.type !== 'no' && this.containerObj === null) {
            throw new Error('\nJSXGraph: HTML container element "' + container + '" not found.');
        }
        // TODO
        // Why do we need this.id AND this.container?
        // There was never a board attribute "id".
        // The origin seems to be that in the geonext renderer we use a separate id, extracted from the GEONExT file.
        if (Type.exists(id) && id !== '' && Env.isBrowser && !Type.exists(this.document.getElementById(id))) {
            // If the given id is not valid, generate an unique id
            this.id = id;
        }
        else {
            this.id = this.generateId();
        }
        /**
         * A reference to this boards renderer.
         * @type JXG.AbstractRenderer
         * @name JXG.Board#renderer
         * @private
         * @ignore
         */
        this.renderer = renderer;
        /**
         * Copy of the default options
         * @type JXG.Options
         */
        this.options = Type.deepCopy(Options); // A possible theme is not yet merged in
        /**
         * Board attributes
         * @type Object
         */
        this.attr = attributes;
        if (this.attr.theme !== 'default' && Type.exists(JXG.themes[this.attr.theme])) {
            this.options = Type.mergeAttrHelper(this.options, JXG.themes[this.attr.theme], true);
        }
        /**
         * Dimension of the board.
         * @default 2
         * @type Number
         */
        this.dimension = 2;
        // TODO:  have coomented this out
        // this.jc = new JessieCode();
        // this.jc.use(this);
        /**
         * Coordinates of the boards origin. This a object with the two properties
         * usrCoords and scrCoords. usrCoords always equals [1, 0, 0] and scrCoords
         * stores the boards origin in homogeneous screen coordinates.
         * @type Object
         * @private
         */
        this.origin = {};
        this.origin.usrCoords = [1, 0, 0];
        this.origin.scrCoords = [1, origin[0], origin[1]];
        /**
         * Zoom factor in X direction. It only stores the zoom factor to be able
         * to get back to 100% in zoom100().
         * @name JXG.Board.zoomX
         * @type Number
         * @private
         * @ignore
         */
        this.zoomX = zoomX;
        /**
         * Zoom factor in Y direction. It only stores the zoom factor to be able
         * to get back to 100% in zoom100().
         * @name JXG.Board.zoomY
         * @type Number
         * @private
         * @ignore
         */
        this.zoomY = zoomY;
        /**
         * The number of pixels which represent one unit in user-coordinates in x direction.
         * @type Number
         * @private
         */
        this.unitX = unitX * this.zoomX;
        /**
         * The number of pixels which represent one unit in user-coordinates in y direction.
         * @type Number
         * @private
         */
        this.unitY = unitY * this.zoomY;
        /**
         * Keep aspect ratio if bounding box is set and the width/height ratio differs from the
         * width/height ratio of the canvas.
         * @type Boolean
         * @private
         */
        this.keepaspectratio = false;
        /**
         * Canvas width.
         * @type Number
         * @private
         */
        this.canvasWidth = canvasWidth;
        /**
         * Canvas Height
         * @type Number
         * @private
         */
        this.canvasHeight = canvasHeight;
        // EventEmitter.eventify(this);  // tb now handled by class hierarchy
        this.hooks = [];
        /**
         * An array containing all other boards that are updated after this board has been updated.
         * @type Array
         * @see JXG.Board#addChild
         * @see JXG.Board#removeChild
         */
        this.dependentBoards = [];
        /**
         * During the update process this is set to false to prevent an endless loop.
         * @default false
         * @type Boolean
         */
        this.inUpdate = false;
        /**
         * An associative array containing all geometric objects belonging to the board. Key is the id of the object and value is a reference to the object.
         * @type Object
         */
        this.objects = {};
        /**
         * An array containing all geometric objects on the board in the order of construction.
         * @type Array
         */
        this.objectsList = [];
        /**
         * An associative array containing all groups belonging to the board. Key is the id of the group and value is a reference to the object.
         * @type Object
         */
        this.groups = {};
        /**
         * Stores all the objects that are currently running an animation.
         * @type Object
         */
        this.animationObjects = {};
        /**
         * An associative array containing all highlighted elements belonging to the board.
         * @type Object
         */
        this.highlightedObjects = {};
        /**
         * Number of objects ever created on this board. This includes every object, even invisible and deleted ones.
         * @type Number
         */
        this.numObjects = 0;
        /**
         * An associative array / dictionary to store the objects of the board by name. The name of the object is the key and value is a reference to the object.
         * @type Object
         */
        this.elementsByName = {};
        /**
         * The board mode the board is currently in. Possible values are
         * <ul>
         * <li>JXG.Board.BOARD_MODE_NONE</li>
         * <li>JXG.Board.BOARD_MODE_DRAG</li>
         * <li>JXG.Board.BOARD_MODE_MOVE_ORIGIN</li>
         * </ul>
         * @type Number
         */
        this.mode = BOARD_MODE.NONE;
        /**
         * The update quality of the board. In most cases this is set to {@link JXG.Board#BOARD_QUALITY_HIGH}.
         * If {@link JXG.Board#mode} equals {@link JXG.Board#BOARD_MODE_DRAG} this is set to
         * {@link JXG.Board#BOARD_QUALITY_LOW} to speed up the update process by e.g. reducing the number of
         * evaluation points when plotting functions. Possible values are
         * <ul>
         * <li>BOARD_QUALITY_LOW</li>
         * <li>BOARD_QUALITY_HIGH</li>
         * </ul>
         * @type Number
         * @see JXG.Board#mode
         */
        this.updateQuality = BOARD_QUALITY.HIGH;
        /**
         * If true updates are skipped.
         * @type Boolean
         */
        this.isSuspendedRedraw = false;
        this.calculateSnapSizes();
        /**
         * The distance from the mouse to the dragged object in x direction when the user clicked the mouse button.
         * @type Number
         * @see JXG.Board#drag_dy
         */
        this.drag_dx = 0;
        /**
         * The distance from the mouse to the dragged object in y direction when the user clicked the mouse button.
         * @type Number
         * @see JXG.Board#drag_dx
         */
        this.drag_dy = 0;
        /**
         * The last position where a drag event has been fired.
         * @type Array
         * @see JXG.Board#moveObject
         */
        this.drag_position = [0, 0];
        /**
         * References to the object that is dragged with the mouse on the board.
         * @type JXG.GeometryElement
         * @see JXG.Board#touches
         */
        this.mouse = {};
        /**
         * Keeps track on touched elements, like {@link JXG.Board#mouse} does for mouse events.
         * @type Array
         * @see JXG.Board#mouse
         */
        this.touches = [];
        /**
         * A string containing the XML text of the construction.
         * This is set in {@link JXG.FileReader.parseString}.
         * Only useful if a construction is read from a GEONExT-, Intergeo-, Geogebra-, or Cinderella-File.
         * @type String
         */
        this.xmlString = '';
        /**
         * Cached result of getCoordsTopLeftCorner for touch/mouseMove-Events to save some DOM operations.
         * @type Array
         */
        this.cPos = [];
        /**
         * Contains the last time (epoch, msec) since the last touchMove event which was not thrown away or since
         * touchStart because Android's Webkit browser fires too much of them.
         * @type Number
         */
        this.touchMoveLast = 0;
        /**
         * Contains the pointerId of the last touchMove event which was not thrown away or since
         * touchStart because Android's Webkit browser fires too much of them.
         * @type Number
         */
        this.touchMoveLastId = Infinity;
        /**
         * Contains the last time (epoch, msec) since the last getCoordsTopLeftCorner call which was not thrown away.
         * @type Number
         */
        this.positionAccessLast = 0;
        /**
         * Collects all elements that triggered a mouse down event.
         * @type Array
         */
        this.downObjects = [];
        this.clickObjects = {};
        /**
         * Collects all elements that have keyboard focus. Should be either one or no element.
         * Elements are stored with their id.
         * @type Array
         */
        this.focusObjects = [];
        if (this.attr.showcopyright || this.attr.showlogo) {
            this.renderer.displayLogo(this.licenseLogo, Options.text.fontSize);
        }
        if (this.attr.showcopyright) {
            this.renderer.displayCopyright(this.licenseText, Options.text.fontSize);
        }
        /**
         * Full updates are needed after zoom and axis translates. This saves some time during an update.
         * @default false
         * @type Boolean
         */
        this.needsFullUpdate = false;
        /**
         * If reducedUpdate is set to true then only the dragged element and few (e.g. 2) following
         * elements are updated during mouse move. On mouse up the whole construction is
         * updated. This enables us to be fast even on very slow devices.
         * @type Boolean
         * @default false
         */
        this.reducedUpdate = false;
        /**
         * The current color blindness deficiency is stored in this property. If color blindness is not emulated
         * at the moment, it's value is 'none'.
         */
        this.currentCBDef = 'none';
        // /**
        //  * If GEONExT constructions are displayed, then this property should be set to true.
        //  * At the moment there should be no difference. But this may change.
        //  * This is set in {@link JXG.GeonextReader.readGeonext}.
        //  * @type Boolean
        //  * @default false
        //  * @see JXG.GeonextReader.readGeonext
        //  */
        // this.geonextCompatibilityMode = false;
        // if (Options.text.useASCIIMathML && translateASCIIMath) {
        //     init();
        // } else {
        //     this.options.text.useASCIIMathML = false;
        // }
        /**
         * A flag which tells if the board registers mouse events.
         * @type Boolean
         * @default false
         */
        this.hasMouseHandlers = false;
        /**
         * A flag which tells if the board registers touch events.
         * @type Boolean
         * @default false
         */
        this.hasTouchHandlers = false;
        /**
         * A flag which stores if the board registered pointer events.
         * @type Boolean
         * @default false
         */
        this.hasPointerHandlers = false;
        /**
         * A flag which stores if the board registered zoom events, i.e. mouse wheel scroll events.
         * @type Boolean
         * @default false
         */
        this.hasWheelHandlers = false;
        /**
         * A flag which tells if the board the JXG.Board#mouseUpListener is currently registered.
         * @type Boolean
         * @default false
         */
        this.hasMouseUp = false;
        /**
         * A flag which tells if the board the JXG.Board#touchEndListener is currently registered.
         * @type Boolean
         * @default false
         */
        this.hasTouchEnd = false;
        /**
         * A flag which tells us if the board has a pointerUp event registered at the moment.
         * @type Boolean
         * @default false
         */
        this.hasPointerUp = false;
        /**
         * Array containing the events related to resizing that have event listeners.
         * @type Array
         * @default []
         */
        this.resizeHandlers = [];
        /**
         * Offset for large coords elements like images
         * @type Array
         * @private
         * @default [0, 0]
         */
        this._drag_offset = [0, 0];
        /**
         * Stores the input device used in the last down or move event.
         * @type String
         * @private
         * @default 'mouse'
         */
        this._inputDevice = 'mouse';
        /**
         * Keeps a list of pointer devices which are currently touching the screen.
         * @type Array
         * @private
         */
        this._board_touches = [];
        /**
         * A flag which tells us if the board is in the selecting mode
         * @type Boolean
         * @default false
         */
        this.selectingMode = false;
        /**
         * A flag which tells us if the user is selecting
         * @type Boolean
         * @default false
         */
        this.isSelecting = false;
        /**
         * A flag which tells us if the user is scrolling the viewport
         * @type Boolean
         * @private
         * @default false
         * @see JXG.Board#scrollListener
         */
        this._isScrolling = false;
        /**
         * A flag which tells us if a resize is in process
         * @type Boolean
         * @private
         * @default false
         * @see JXG.Board#resizeListener
         */
        this._isResizing = false;
        /**
         * A flag which tells us if the update is triggered by a change of the
         * 3D view. In that case we only have to update the projection of
         * the 3D elements and can avoid a full board update.
         *
         * @type Boolean
         * @private
         * @default false
         */
        this._change3DView = false;
        /**
         * A bounding box for the selection
         * @type Array
         * @default [ [0,0], [0,0] ]
         */
        this.selectingBox = [[0, 0], [0, 0]];
        /**
         * Array to log user activity.
         * Entries are objects of the form '{type, id, start, end}' notifying
         * the start time as well as the last time of a single event of type 'type'
         * on a JSXGraph element of id 'id'.
         * <p> 'start' and 'end' contain the amount of milliseconds elapsed between 1 January 1970 00:00:00 UTC
         * and the time the event happened.
         * <p>
         * For the time being (i.e. v1.5.0) the only supported type is 'drag'.
         * @type Array
         */
        this.userLog = [];
        this.mathLib = Math; // Math or JXG.Math.IntervalArithmetic
        this.mathLibJXG = JSXMath; // JXG.Math or JXG.Math.IntervalArithmetic
        if (this.attr.registerevents === true) {
            this.attr.registerevents = {
                fullscreen: true,
                keyboard: true,
                pointer: true,
                resize: true,
                wheel: true
            };
        }
        else if (typeof this.attr.registerevents === 'object') {
            if (!Type.exists(this.attr.registerevents.fullscreen)) {
                this.attr.registerevents.fullscreen = true;
            }
            if (!Type.exists(this.attr.registerevents.keyboard)) {
                this.attr.registerevents.keyboard = true;
            }
            if (!Type.exists(this.attr.registerevents.pointer)) {
                this.attr.registerevents.pointer = true;
            }
            if (!Type.exists(this.attr.registerevents.resize)) {
                this.attr.registerevents.resize = true;
            }
            if (!Type.exists(this.attr.registerevents.wheel)) {
                this.attr.registerevents.wheel = true;
            }
        }
        if (this.attr.registerevents !== false) {
            if (this.attr.registerevents.fullscreen) {
                this.addFullscreenEventHandlers();
            }
            if (this.attr.registerevents.keyboard) {
                this.addKeyboardEventHandlers();
            }
            if (this.attr.registerevents.pointer) {
                this.addEventHandlers();
            }
            if (this.attr.registerevents.resize) {
                this.addResizeEventHandlers();
            }
            if (this.attr.registerevents.wheel) {
                this.addWheelEventHandlers();
            }
        }
        this.methodMap = {
            update: 'update',
            fullUpdate: 'fullUpdate',
            on: 'on',
            off: 'off',
            trigger: 'trigger',
            setAttribute: 'setAttribute',
            setBoundingBox: 'setBoundingBox',
            setView: 'setBoundingBox',
            getBoundingBox: 'getBoundingBox',
            BoundingBox: 'getBoundingBox',
            getView: 'getBoundingBox',
            View: 'getBoundingBox',
            migratePoint: 'migratePoint',
            colorblind: 'emulateColorblindness',
            suspendUpdate: 'suspendUpdate',
            unsuspendUpdate: 'unsuspendUpdate',
            clearTraces: 'clearTraces',
            left: 'clickLeftArrow',
            right: 'clickRightArrow',
            up: 'clickUpArrow',
            down: 'clickDownArrow',
            zoomIn: 'zoomIn',
            zoomOut: 'zoomOut',
            zoom100: 'zoom100',
            zoomElements: 'zoomElements',
            remove: 'removeObject',
            removeObject: 'removeObject'
        };
    }
    ;
    /**
     * Generates an unique name for the given object. The result depends on the objects type, if the
     * object is a {@link JXG.Point} capital characters are used, if it is of type {@link JXG.Line}
     * only lower case characters are used. If object is of type {@link JXG.Polygon} a bunch of lower
     * case characters prefixed with P_ are used. If object is of type {@link JXG.Circle} the name is
     * generated using lower case characters. prefixed with k_ is used. In any other case, lower case
     * chars prefixed with s_ is used.
     * @param {Object} object Reference of an JXG.GeometryElement that is to be named.
     * @returns {String} Unique name for the object.
     */
    generateName(object) {
        var possibleNames, i, maxNameLength = this.attr.maxnamelength, pre = '', post = '', indices = [], name = '';
        if (object.type === OBJECT_TYPE.TICKS) {
            return '';
        }
        if (Type.isPoint(object) || Type.isPoint3D(object)) {
            // points have capital letters
            possibleNames = [
                '', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'
            ];
        }
        else if (object.type === OBJECT_TYPE.ANGLE) {
            possibleNames = [
                '', '&alpha;', '&beta;', '&gamma;', '&delta;', '&epsilon;', '&zeta;', '&eta;', '&theta;', '&iota;', '&kappa;', '&lambda;',
                '&mu;', '&nu;', '&xi;', '&omicron;', '&pi;', '&rho;', '&sigma;', '&tau;', '&upsilon;', '&phi;', '&chi;', '&psi;', '&omega;'
            ];
        }
        else {
            // all other elements get lowercase labels
            possibleNames = [
                '', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
            ];
        }
        if (!Type.isPoint(object) &&
            !Type.isPoint3D(object) &&
            object.elementClass !== OBJECT_CLASS.LINE &&
            object.type !== OBJECT_TYPE.ANGLE) {
            if (object.type === OBJECT_TYPE.POLYGON) {
                pre = 'P_{';
            }
            else if (object.elementClass === OBJECT_CLASS.CIRCLE) {
                pre = 'k_{';
            }
            else if (object.elementClass === OBJECT_CLASS.TEXT) {
                pre = 't_{';
            }
            else {
                pre = 's_{';
            }
            post = '}';
        }
        for (i = 0; i < maxNameLength; i++) {
            indices[i] = 0;
        }
        while (indices[maxNameLength - 1] < possibleNames.length) {
            for (indices[0] = 1; indices[0] < possibleNames.length; indices[0]++) {
                name = pre;
                for (i = maxNameLength; i > 0; i--) {
                    name += possibleNames[indices[i - 1]];
                }
                if (!Type.exists(this.elementsByName[name + post])) {
                    return name + post;
                }
            }
            indices[0] = possibleNames.length;
            for (i = 1; i < maxNameLength; i++) {
                if (indices[i - 1] === possibleNames.length) {
                    indices[i - 1] = 1;
                    indices[i] += 1;
                }
            }
        }
        return '';
    }
    /**
     * Generates unique id for a board. The result is randomly generated and prefixed with 'jxgBoard'.
     * @returns {String} Unique id for a board.
     */
    generateId() {
        var r = 1;
        // as long as we don't have a unique id generate a new one
        while (Type.exists(JXG.boards['jxgBoard' + r])) {
            r = Math.round(Math.random() * 16777216);
        }
        return 'jxgBoard' + r;
    }
    /**
     * Composes an id for an element. If the ID is empty ('' or null) a new ID is generated, depending on the
     * object type. As a side effect {@link JXG.Board#numObjects}
     * is updated.
     * @param {Object} obj Reference of an geometry object that needs an id.
     * @param {Number} type Type of the object.
     * @returns {String} Unique id for an element.
     */
    setId(obj, type) {
        var randomNumber, num = this.numObjects, elId = obj.id;
        this.numObjects += 1;
        // If no id is provided or id is empty string, a new one is chosen
        if (elId === '' || !Type.exists(elId)) {
            elId = this.id + type + num;
            while (Type.exists(this.objects[elId])) {
                randomNumber = Math.round(Math.random() * 65535);
                elId = this.id + type + num + '-' + randomNumber;
            }
        }
        obj.id = elId;
        this.objects[elId] = obj;
        obj._pos = this.objectsList.length;
        this.objectsList[this.objectsList.length] = obj;
        return elId;
    }
    /**
     * After construction of the object the visibility is set
     * and the label is constructed if necessary.
     * @param {Object} obj The object to add.
     */
    finalizeAdding(obj) {
        if (obj.evalVisProp('visible') === false) {
            this.renderer.display(obj, false);
        }
    }
    finalizeLabel(obj) {
        if (obj.hasLabel &&
            !obj.label.evalVisProp('islabel') &&
            obj.label.evalVisProp('visible') === false) {
            this.renderer.display(obj.label, false);
        }
    }
    /**********************************************************
     *
     * Event Handler helpers
     *
     **********************************************************/
    /**
     * Returns false if the event has been triggered faster than the maximum frame rate.
     *
     * @param {Event} evt Event object given by the browser (unused)
     * @returns {Boolean} If the event has been triggered faster than the maximum frame rate, false is returned.
     * @private
     * @see JXG.Board#pointerMoveListener
     * @see JXG.Board#touchMoveListener
     * @see JXG.Board#mouseMoveListener
     */
    checkFrameRate(evt) {
        var handleEvt = false, time = new Date().getTime();
        if (Type.exists(evt.pointerId) && this.touchMoveLastId !== evt.pointerId) {
            handleEvt = true;
            this.touchMoveLastId = evt.pointerId;
        }
        if (!handleEvt && (time - this.touchMoveLast) * this.attr.maxframerate >= 1000) {
            handleEvt = true;
        }
        if (handleEvt) {
            this.touchMoveLast = time;
        }
        return handleEvt;
    }
    /**
     * Calculates mouse coordinates relative to the boards container.
     * @returns {Array} Array of coordinates relative the boards container top left corner.
     */
    getCoordsTopLeftCorner() {
        var cPos, doc, crect, 
        // In ownerDoc we need the 'real' document object.
        // The first version is used in the case of shadowDom,
        // the second case in the 'normal' case.
        ownerDoc = this.document.ownerDocument || this.document, docElement = ownerDoc.documentElement || this.document.body.parentNode, docBody = ownerDoc.body, container = this.containerObj, zoom, o;
        /**
         * During drags and origin moves the container element is usually not changed.
         * Check the position of the upper left corner at most every 1000 msecs
         */
        if (this.cPos.length > 0 &&
            (this.mode === BOARD_MODE.DRAG ||
                this.mode === BOARD_MODE.MOVE_ORIGIN ||
                new Date().getTime() - this.positionAccessLast < 1000)) {
            return this.cPos;
        }
        this.positionAccessLast = new Date().getTime();
        // Check if getBoundingClientRect exists. If so, use this as this covers *everything*
        // even CSS3D transformations etc.
        // Supported by all browsers but IE 6, 7.
        if (container.getBoundingClientRect) {
            crect = container.getBoundingClientRect();
            zoom = 1.0;
            // Recursively search for zoom style entries.
            // This is necessary for reveal.js on webkit.
            // It fails if the user does zooming
            o = container;
            while (o && Type.exists(o.parentNode)) {
                if (Type.exists(o.style) &&
                    Type.exists(o.style.zoom) &&
                    o.style.zoom !== '') {
                    zoom *= parseFloat(o.style.zoom);
                }
                o = o.parentNode;
            }
            cPos = [crect.left * zoom, crect.top * zoom];
            // add border width
            cPos[0] += Env.getProp(container, 'border-left-width');
            cPos[1] += Env.getProp(container, 'border-top-width');
            // vml seems to ignore paddings
            if (this.renderer.type !== 'vml') {
                // add padding
                cPos[0] += Env.getProp(container, 'padding-left');
                cPos[1] += Env.getProp(container, 'padding-top');
            }
            this.cPos = cPos.slice();
            return this.cPos;
        }
        //
        //  OLD CODE
        //  IE 6-7 only:
        //
        cPos = Env.getOffset(container);
        doc = this.document.documentElement.ownerDocument;
        if ( /*!this.containerObj.currentStyle && */doc.defaultView) {
            // Non IE
            // this is for hacks like this one used in wordpress for the admin bar:
            // html { margin-top: 28px }
            // seems like it doesn't work in IE
            cPos[0] += Env.getProp(docElement, 'margin-left');
            cPos[1] += Env.getProp(docElement, 'margin-top');
            cPos[0] += Env.getProp(docElement, 'border-left-width');
            cPos[1] += Env.getProp(docElement, 'border-top-width');
            cPos[0] += Env.getProp(docElement, 'padding-left');
            cPos[1] += Env.getProp(docElement, 'padding-top');
        }
        if (docBody) {
            cPos[0] += Env.getProp(docBody, 'left');
            cPos[1] += Env.getProp(docBody, 'top');
        }
        // Google Translate offers widgets for web authors. These widgets apparently tamper with the clientX
        // and clientY coordinates of the mouse events. The minified sources seem to be the only publicly
        // available version so we're doing it the hacky way: Add a fixed offset.
        // see https://groups.google.com/d/msg/google-translate-general/H2zj0TNjjpY/jw6irtPlCw8J
        // if (typeof google === 'object' && google.translate) {   // removed TBTB
        //     cPos[0] += 10;
        //     cPos[1] += 25;
        // }
        // add border width
        cPos[0] += Env.getProp(container, 'border-left-width');
        cPos[1] += Env.getProp(container, 'border-top-width');
        // vml seems to ignore paddings
        if (this.renderer.type !== 'vml') {
            // add padding
            cPos[0] += Env.getProp(container, 'padding-left');
            cPos[1] += Env.getProp(container, 'padding-top');
        }
        cPos[0] += this.attr.offsetx;
        cPos[1] += this.attr.offsety;
        this.cPos = cPos.slice();
        return this.cPos;
    }
    /**
     * This function divides the board into 9 sections and returns an array <tt>[u,v]</tt> which symbolizes the location of <tt>position</tt>.
     * Optional a <tt>margin</tt> to the inner of the board is respected.<br>
     *
     * @name Board#getPointLoc
     * @param {Array} position Array of requested position <tt>[x, y]</tt> or <tt>[w, x, y]</tt>.
     * @param {Array|Number} [margin] Optional margin for the inner of the board: <tt>[top, right, bottom, left]</tt>. A single number <tt>m</tt> is interpreted as <tt>[m, m, m, m]</tt>.
     * @returns {Array} [u,v] with the following meanings:
     * <pre>
     *     v    u > |   -1    |    0   |    1   |
     * ------------------------------------------
     *     1        | [-1,1]  |  [0,1] |  [1,1] |
     * ------------------------------------------
     *     0        | [-1,0]  |  Board |  [1,0] |
     * ------------------------------------------
     *    -1        | [-1,-1] | [0,-1] | [1,-1] |
     * </pre>
     * Positions inside the board (minus margin) return the value <tt>[0,0]</tt>.
     *
     * @example
     *      var point1, point2, point3, point4, margin,
     *             p1Location, p2Location, p3Location, p4Location,
     *             helppoint1, helppoint2, helppoint3, helppoint4;
     *
     *      // margin to make the boundingBox virtually smaller
     *      margin = [2,2,2,2];
     *
     *      // Points which are seen on screen
     *      point1 = board.create('point', [0,0]);
     *      point2 = board.create('point', [0,7]);
     *      point3 = board.create('point', [7,7]);
     *      point4 = board.create('point', [-7,-5]);
     *
     *      p1Location = board.getPointLoc(point1.coords.usrCoords, margin);
     *      p2Location = board.getPointLoc(point2.coords.usrCoords, margin);
     *      p3Location = board.getPointLoc(point3.coords.usrCoords, margin);
     *      p4Location = board.getPointLoc(point4.coords.usrCoords, margin);
     *
     *      // Text seen on screen
     *      board.create('text', [1,-1, "getPointLoc(A): " + "[" + p1Location + "]"])
     *      board.create('text', [1,-2, "getPointLoc(B): " + "[" + p2Location + "]"])
     *      board.create('text', [1,-3, "getPointLoc(C): " + "[" + p3Location + "]"])
     *      board.create('text', [1,-4, "getPointLoc(D): " + "[" + p4Location + "]"])
     *
     *
     *      // Helping points that are used to create the helping lines
     *      helppoint1 = board.create('point', [(function (){
     *          var bbx = board.getBoundingBox();
     *          return [bbx[2] - 2, bbx[1] -2];
     *      })], {
     *          visible: false,
     *      })
     *
     *      helppoint2 = board.create('point', [(function (){
     *          var bbx = board.getBoundingBox();
     *          return [bbx[0] + 2, bbx[1] -2];
     *      })], {
     *          visible: false,
     *      })
     *
     *      helppoint3 = board.create('point', [(function (){
     *          var bbx = board.getBoundingBox();
     *          return [bbx[0]+ 2, bbx[3] + 2];
     *      })],{
     *          visible: false,
     *      })
     *
     *      helppoint4 = board.create('point', [(function (){
     *          var bbx = board.getBoundingBox();
     *          return [bbx[2] -2, bbx[3] + 2];
     *      })], {
     *          visible: false,
     *      })
     *
     *      // Helping lines to visualize the 9 sectors and the margin
     *      board.create('line', [helppoint1, helppoint2]);
     *      board.create('line', [helppoint2, helppoint3]);
     *      board.create('line', [helppoint3, helppoint4]);
     *      board.create('line', [helppoint4, helppoint1]);
     *
     * </pre><div id="JXG4b3efef5-839d-4fac-bad1-7a14c0a89c70" class="jxgbox" style="width: 500px; height: 500px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG4b3efef5-839d-4fac-bad1-7a14c0a89c70',
     *             {boundingbox: [-8, 8, 8,-8], maxboundingbox: [-7.5,7.5,7.5,-7.5], axis: true, showcopyright: false, shownavigation: false, showZoom: false});
     *     var point1, point2, point3, point4, margin,
     *             p1Location, p2Location, p3Location, p4Location,
     *             helppoint1, helppoint2, helppoint3, helppoint4;
     *
     *      // margin to make the boundingBox virtually smaller
     *      margin = [2,2,2,2];
     *
     *      // Points which are seen on screen
     *      point1 = board.create('point', [0,0]);
     *      point2 = board.create('point', [0,7]);
     *      point3 = board.create('point', [7,7]);
     *      point4 = board.create('point', [-7,-5]);
     *
     *      p1Location = board.getPointLoc(point1.coords.usrCoords, margin);
     *      p2Location = board.getPointLoc(point2.coords.usrCoords, margin);
     *      p3Location = board.getPointLoc(point3.coords.usrCoords, margin);
     *      p4Location = board.getPointLoc(point4.coords.usrCoords, margin);
     *
     *      // Text seen on screen
     *      board.create('text', [1,-1, "getPointLoc(A): " + "[" + p1Location + "]"])
     *      board.create('text', [1,-2, "getPointLoc(B): " + "[" + p2Location + "]"])
     *      board.create('text', [1,-3, "getPointLoc(C): " + "[" + p3Location + "]"])
     *      board.create('text', [1,-4, "getPointLoc(D): " + "[" + p4Location + "]"])
     *
     *
     *      // Helping points that are used to create the helping lines
     *      helppoint1 = board.create('point', [(function (){
     *          var bbx = board.getBoundingBox();
     *          return [bbx[2] - 2, bbx[1] -2];
     *      })], {
     *          visible: false,
     *      })
     *
     *      helppoint2 = board.create('point', [(function (){
     *          var bbx = board.getBoundingBox();
     *          return [bbx[0] + 2, bbx[1] -2];
     *      })], {
     *          visible: false,
     *      })
     *
     *      helppoint3 = board.create('point', [(function (){
     *          var bbx = board.getBoundingBox();
     *          return [bbx[0]+ 2, bbx[3] + 2];
     *      })],{
     *          visible: false,
     *      })
     *
     *      helppoint4 = board.create('point', [(function (){
     *          var bbx = board.getBoundingBox();
     *          return [bbx[2] -2, bbx[3] + 2];
     *      })], {
     *          visible: false,
     *      })
     *
     *      // Helping lines to visualize the 9 sectors and the margin
     *      board.create('line', [helppoint1, helppoint2]);
     *      board.create('line', [helppoint2, helppoint3]);
     *      board.create('line', [helppoint3, helppoint4]);
     *      board.create('line', [helppoint4, helppoint1]);
     *  })();
     *
     * </script><pre>
     *
     */
    getPointLoc(position, margin) {
        var bbox, pos, res, marg;
        bbox = this.getBoundingBox();
        pos = position;
        if (pos.length === 2) {
            pos.unshift(undefined);
        }
        res = [0, 0];
        marg = margin || 0;
        if (Type.isNumber(marg)) {
            marg = [marg, marg, marg, marg];
        }
        if (pos[1] > (bbox[2] - marg[1])) {
            res[0] = 1;
        }
        if (pos[1] < (bbox[0] + marg[3])) {
            res[0] = -1;
        }
        if (pos[2] > (bbox[1] - marg[0])) {
            res[1] = 1;
        }
        if (pos[2] < (bbox[3] + marg[2])) {
            res[1] = -1;
        }
        return res;
    }
    /**
     * This function calculates where the origin is located (@link Board#getPointLoc).
     * Optional a <tt>margin</tt> to the inner of the board is respected.<br>
     *
     * @name Board#getLocationOrigin
     * @param {Array|Number} [margin] Optional margin for the inner of the board: <tt>[top, right, bottom, left]</tt>. A single number <tt>m</tt> is interpreted as <tt>[m, m, m, m]</tt>.
     * @returns {Array} [u,v] which shows where the origin is located (@link Board#getPointLoc).
     */
    getLocationOrigin(margin) {
        return this.getPointLoc([0, 0], margin);
    }
    /**
     * Get the position of the pointing device in screen coordinates, relative to the upper left corner
     * of the host tag.
     * @param {Event} e Event object given by the browser.
     * @param {Number} [i] Only use in case of touch events. This determines which finger to use and should not be set
     * for mouseevents.
     * @returns {Array} Contains the mouse coordinates in screen coordinates, ready for {@link JXG.Coords}
     */
    getMousePosition(e, i) {
        var cPos = this.getCoordsTopLeftCorner(), absPos, v;
        // Position of cursor using clientX/Y
        absPos = Env.getPosition(e, i, this.document);
        // Old:
        // This seems to be obsolete anyhow:
        // "In case there has been no down event before."
        // if (!Type.exists(this.cssTransMat)) {
        // this.updateCSSTransforms();
        // }
        // New:
        // We have to update the CSS transform matrix all the time,
        // since libraries like ZIMJS do not notify JSXGraph about a change.
        // In particular, sending a resize event event to JSXGraph
        // would be necessary.
        this.updateCSSTransforms();
        // Position relative to the top left corner
        v = [1, absPos[0] - cPos[0], absPos[1] - cPos[1]];
        v = JSXMath.matVecMult(this.cssTransMat, v);
        v[1] /= v[0];
        v[2] /= v[0];
        return [v[1], v[2]];
        // Method without CSS transformation
        /*
         return [absPos[0] - cPos[0], absPos[1] - cPos[1]];
         */
    }
    /**
     * Initiate moving the origin. This is used in mouseDown and touchStart listeners.
     * @param {Number} x Current mouse/touch coordinates
     * @param {Number} y Current mouse/touch coordinates
     */
    initMoveOrigin(x, y) {
        this.drag_dx = x - this.origin.scrCoords[1];
        this.drag_dy = y - this.origin.scrCoords[2];
        this.mode = BOARD_MODE.MOVE_ORIGIN;
        this.updateQuality = BOARD_QUALITY.HIGHLOW;
    }
    /**
     * Collects all elements below the current mouse pointer and fulfilling the following constraints:
     * <ul>
     * <li>isDraggable</li>
     * <li>visible</li>
     * <li>not fixed</li>
     * <li>not frozen</li>
     * </ul>
     * @param {Number} x Current mouse/touch coordinates
     * @param {Number} y current mouse/touch coordinates
     * @param {Object} evt An event object
     * @param {String} type What type of event? 'touch', 'mouse' or 'pen'.
     * @returns {Array} A list of geometric elements.
     */
    initMoveObject(x, y, evt, type) {
        var pEl, el, collect = [], offset = [], haspoint, len = this.objectsList.length, dragEl = { visProp: { layer: -1e4 } };
        // Store status of key presses for 3D movement
        this._shiftKey = evt.shiftKey;
        this._ctrlKey = evt.ctrlKey;
        //for (el in this.objects) {
        for (el = 0; el < len; el++) {
            pEl = this.objectsList[el];
            haspoint = pEl.hasPoint && pEl.hasPoint(x, y);
            if (pEl.visPropCalc.visible && haspoint) {
                pEl.triggerEventHandlers([type + 'down', 'down'], [evt]);
                this.downObjects.push(pEl);
            }
            if (haspoint &&
                pEl.isDraggable &&
                pEl.visPropCalc.visible &&
                ((this.geonextCompatibilityMode &&
                    (Type.isPoint(pEl) || pEl.elementClass === OBJECT_CLASS.TEXT)) ||
                    !this.geonextCompatibilityMode) &&
                !pEl.evalVisProp('fixed')
            /*(!pEl.visProp.frozen) &&*/
            ) {
                // Elements in the highest layer get priority.
                if (pEl.visProp.layer > dragEl.visProp.layer ||
                    (pEl.visProp.layer === dragEl.visProp.layer &&
                        pEl.lastDragTime.getTime() >= dragEl.lastDragTime.getTime())) {
                    // If an element and its label have the focus
                    // simultaneously, the element is taken.
                    // This only works if we assume that every browser runs
                    // through this.objects in the right order, i.e. an element A
                    // added before element B turns up here before B does.
                    if (!this.attr.ignorelabels ||
                        !Type.exists(dragEl.label) ||
                        pEl !== dragEl.label) {
                        dragEl = pEl;
                        collect.push(dragEl);
                        // Save offset for large coords elements.
                        if (Type.exists(dragEl.coords)) {
                            if (dragEl.elementClass === OBJECT_CLASS.POINT ||
                                dragEl.relativeCoords // Relative texts like labels
                            ) {
                                offset.push(Statistics.subtract(dragEl.coords.scrCoords.slice(1), [x, y]));
                            }
                            else {
                                // Images and texts
                                offset.push(Statistics.subtract(dragEl.actualCoords.scrCoords.slice(1), [x, y]));
                            }
                        }
                        else {
                            offset.push([0, 0]);
                        }
                        // We can't drop out of this loop because of the event handling system
                        //if (this.attr.takefirst) {
                        //    return collect;
                        //}
                    }
                }
            }
        }
        if (this.attr.drag.enabled && collect.length > 0) {
            this.mode = BOARD_MODE.DRAG;
        }
        // A one-element array is returned.
        if (this.attr.takefirst) {
            collect.length = 1;
            this._drag_offset = offset[0];
        }
        else {
            collect = collect.slice(-1);
            this._drag_offset = offset[offset.length - 1];
        }
        if (!this._drag_offset) {
            this._drag_offset = [0, 0];
        }
        // Move drag element to the top of the layer
        if (this.renderer.type === 'svg' &&
            Type.exists(collect[0]) &&
            collect[0].evalVisProp('dragtotopoflayer') &&
            collect.length === 1 &&
            Type.exists(collect[0].rendNode)) {
            collect[0].rendNode.parentNode.appendChild(collect[0].rendNode);
        }
        // // Init rotation angle and scale factor for two finger movements
        // this.previousRotation = 0.0;
        // this.previousScale = 1.0;
        if (collect.length >= 1) {
            collect[0].highlight(true);
            this.triggerEventHandlers(['mousehit', 'hit'], [evt, collect[0]]);
        }
        return collect;
    }
    /**
     * Moves an object.
     * @param {Number} x Coordinate
     * @param {Number} y Coordinate
     * @param {Object} o The touch object that is dragged: {JXG.Board#mouse} or {JXG.Board#touches}.
     * @param {Object} evt The event object.
     * @param {String} type Mouse or touch event?
     */
    moveObject(x, y, o, evt, type) {
        var newPos = new Coords$1(COORDS_BY.SCREEN, this.getScrCoordsOfMouse(x, y), this), drag, dragScrCoords, newDragScrCoords;
        if (!(o && o.obj)) {
            return;
        }
        drag = o.obj;
        // Avoid updates for very small movements of coordsElements, see below
        if (drag.coords) {
            dragScrCoords = drag.coords.scrCoords.slice();
        }
        this.addLogEntry('drag', drag, newPos.usrCoords.slice(1));
        // Store the position and add the correctionvector from the mouse
        // position to the object's coords.
        this.drag_position = [newPos.scrCoords[1], newPos.scrCoords[2]];
        this.drag_position = Statistics.add(this.drag_position, this._drag_offset);
        // TODO: never used
        // // Store status of key presses for 3D movement
        // this._shiftKey = evt.shiftKey;
        // this._ctrlKey = evt.ctrlKey;
        //
        // We have to distinguish between CoordsElements and other elements like lines.
        // The latter need the difference between two move events.
        if (Type.exists(drag.coords)) {
            drag.setPositionDirectly(COORDS_BY.SCREEN, this.drag_position, [x, y]);
        }
        else {
            this.displayInfobox(false);
            // Hide infobox in case the user has touched an intersection point
            // and drags the underlying line now.
            if (!isNaN(o.targets[0].Xprev + o.targets[0].Yprev)) {
                drag.setPositionDirectly(COORDS_BY.SCREEN, [newPos.scrCoords[1], newPos.scrCoords[2]], [o.targets[0].Xprev, o.targets[0].Yprev]);
            }
            // Remember the actual position for the next move event. Then we are able to
            // compute the difference vector.
            o.targets[0].Xprev = newPos.scrCoords[1];
            o.targets[0].Yprev = newPos.scrCoords[2];
        }
        // This may be necessary for some gliders and labels
        if (Type.exists(drag.coords)) {
            drag.prepareUpdate().update(false).updateRenderer();
            this.updateInfobox(drag);
            drag.prepareUpdate().update(true).updateRenderer();
        }
        if (drag.coords) {
            newDragScrCoords = drag.coords.scrCoords;
        }
        // No updates for very small movements of coordsElements
        if (!drag.coords ||
            dragScrCoords[1] !== newDragScrCoords[1] ||
            dragScrCoords[2] !== newDragScrCoords[2]) {
            drag.triggerEventHandlers([type + 'drag', 'drag'], [evt]);
            // Update all elements of the board
            this.update(drag);
        }
        drag.highlight(true);
        this.triggerEventHandlers(['mousehit', 'hit'], [evt, drag]);
        drag.lastDragTime = new Date();
    }
    /**
     * Moves elements in multitouch mode.
     * @param {Array} p1 x,y coordinates of first touch
     * @param {Array} p2 x,y coordinates of second touch
     * @param {Object} o The touch object that is dragged: {JXG.Board#touches}.
     * @param {Object} evt The event object that lead to this movement.
     */
    twoFingerMove(o, id, evt) {
        var drag;
        if (Type.exists(o) && Type.exists(o.obj)) {
            drag = o.obj;
        }
        else {
            return;
        }
        if (drag.elementClass === OBJECT_CLASS.LINE ||
            drag.type === OBJECT_TYPE.POLYGON) {
            this.twoFingerTouchObject(o.targets, drag, id);
        }
        else if (drag.elementClass === OBJECT_CLASS.CIRCLE) {
            this.twoFingerTouchCircle(o.targets, drag, id);
        }
        if (evt) {
            drag.triggerEventHandlers(['touchdrag', 'drag'], [evt]);
        }
    }
    /**
     * Compute the transformation matrix to move an element according to the
     * previous and actual positions of finger 1 and finger 2.
     * See also https://math.stackexchange.com/questions/4010538/solve-for-2d-translation-rotation-and-scale-given-two-touch-point-movements
     *
     * @param {Object} finger1 Actual and previous position of finger 1
     * @param {Object} finger1 Actual and previous position of finger 1
     * @param {Boolean} scalable Flag if element may be scaled
     * @param {Boolean} rotatable Flag if element may be rotated
     * @returns {Array}
     */
    getTwoFingerTransform(finger1, finger2, scalable, rotatable) {
        var crd, x1, y1, x2, y2, dx, dy, xx1, yy1, xx2, yy2, dxx, dyy, C, S, LL, tx, ty, lbda;
        crd = new Coords$1(COORDS_BY.SCREEN, [finger1.Xprev, finger1.Yprev], this).usrCoords;
        x1 = crd[1];
        y1 = crd[2];
        crd = new Coords$1(COORDS_BY.SCREEN, [finger2.Xprev, finger2.Yprev], this).usrCoords;
        x2 = crd[1];
        y2 = crd[2];
        crd = new Coords$1(COORDS_BY.SCREEN, [finger1.X, finger1.Y], this).usrCoords;
        xx1 = crd[1];
        yy1 = crd[2];
        crd = new Coords$1(COORDS_BY.SCREEN, [finger2.X, finger2.Y], this).usrCoords;
        xx2 = crd[1];
        yy2 = crd[2];
        dx = x2 - x1;
        dy = y2 - y1;
        dxx = xx2 - xx1;
        dyy = yy2 - yy1;
        LL = dx * dx + dy * dy;
        C = (dxx * dx + dyy * dy) / LL;
        S = (dyy * dx - dxx * dy) / LL;
        if (!scalable) {
            lbda = JSXMath.hypot(C, S);
            C /= lbda;
            S /= lbda;
        }
        if (!rotatable) {
            S = 0;
        }
        tx = 0.5 * (xx1 + xx2 - C * (x1 + x2) + S * (y1 + y2));
        ty = 0.5 * (yy1 + yy2 - S * (x1 + x2) - C * (y1 + y2));
        return [1, 0, 0,
            tx, C, -S,
            ty, S, C];
    }
    /**
     * Moves, rotates and scales a line or polygon with two fingers.
     * <p>
     * If one vertex of the polygon snaps to the grid or to points or is not draggable,
     * two-finger-movement is cancelled.
     *
     * @param {Array} tar Array containing touch event objects: {JXG.Board#touches.targets}.
     * @param {object} drag The object that is dragged:
     * @param {Number} id pointerId of the event. In case of old touch event this is emulated.
     */
    twoFingerTouchObject(tar, drag, id) {
        var t, T, ar, i, len, snap = false;
        if (Type.exists(tar[0]) &&
            Type.exists(tar[1]) &&
            !isNaN(tar[0].Xprev + tar[0].Yprev + tar[1].Xprev + tar[1].Yprev)) {
            T = this.getTwoFingerTransform(tar[0], tar[1], drag.evalVisProp('scalable'), drag.evalVisProp('rotatable'));
            t = this.create('transform', T, { type: 'generic' });
            t.update();
            if (drag.elementClass === OBJECT_CLASS.LINE) {
                ar = [];
                if (drag.point1.draggable()) {
                    ar.push(drag.point1);
                }
                if (drag.point2.draggable()) {
                    ar.push(drag.point2);
                }
                t.applyOnce(ar);
            }
            else if (drag.type === OBJECT_TYPE.POLYGON) {
                len = drag.vertices.length - 1;
                snap = drag.evalVisProp('snaptogrid') || drag.evalVisProp('snaptopoints');
                for (i = 0; i < len && !snap; ++i) {
                    snap = snap || drag.vertices[i].evalVisProp('snaptogrid') || drag.vertices[i].evalVisProp('snaptopoints');
                    snap = snap || (!drag.vertices[i].draggable());
                }
                if (!snap) {
                    ar = [];
                    for (i = 0; i < len; ++i) {
                        if (drag.vertices[i].draggable()) {
                            ar.push(drag.vertices[i]);
                        }
                    }
                    t.applyOnce(ar);
                }
            }
            this.update();
            drag.highlight(true);
        }
    }
    /*
     * Moves, rotates and scales a circle with two fingers.
     * @param {Array} tar Array containing touch event objects: {JXG.Board#touches.targets}.
     * @param {object} drag The object that is dragged:
     * @param {Number} id pointerId of the event. In case of old touch event this is emulated.
     */
    twoFingerTouchCircle(tar, drag, id) {
        var fixEl, moveEl, np, op, fix, d, alpha, t1, t2, t3, t4;
        if (drag.method === 'pointCircle' || drag.method === 'pointLine') {
            return;
        }
        if (Type.exists(tar[0]) &&
            Type.exists(tar[1]) &&
            !isNaN(tar[0].Xprev + tar[0].Yprev + tar[1].Xprev + tar[1].Yprev)) {
            if (id === tar[0].num) {
                fixEl = tar[1];
                moveEl = tar[0];
            }
            else {
                fixEl = tar[0];
                moveEl = tar[1];
            }
            fix = new Coords$1(COORDS_BY.SCREEN, [fixEl.Xprev, fixEl.Yprev], this)
                .usrCoords;
            // Previous finger position
            op = new Coords$1(COORDS_BY.SCREEN, [moveEl.Xprev, moveEl.Yprev], this)
                .usrCoords;
            // New finger position
            np = new Coords$1(COORDS_BY.SCREEN, [moveEl.X, moveEl.Y], this).usrCoords;
            alpha = Geometry.rad(op.slice(1), fix.slice(1), np.slice(1));
            // Rotate and scale by the movement of the second finger
            t1 = this.create('transform', [-fix[1], -fix[2]], {
                type: 'translate'
            });
            t2 = this.create('transform', [alpha], { type: 'rotate' });
            t1.melt(t2);
            if (drag.evalVisProp('scalable')) {
                d = Geometry.distance(fix, np) / Geometry.distance(fix, op);
                t3 = this.create('transform', [d, d], { type: 'scale' });
                t1.melt(t3);
            }
            t4 = this.create('transform', [fix[1], fix[2]], {
                type: 'translate'
            });
            t1.melt(t4);
            if (drag.center.draggable()) {
                t1.applyOnce([drag.center]);
            }
            if (drag.method === 'twoPoints') {
                if (drag.point2.draggable()) {
                    t1.applyOnce([drag.point2]);
                }
            }
            else if (drag.method === 'pointRadius') {
                if (Type.isNumber(drag.updateRadius.origin)) {
                    drag.setRadius(drag.radius * d);
                }
            }
            this.update(drag.center);
            drag.highlight(true);
        }
    }
    highlightElements(x, y, evt, target) {
        var el, pEl, pId, overObjects = {}, len = this.objectsList.length;
        // Elements  below the mouse pointer which are not highlighted yet will be highlighted.
        for (el = 0; el < len; el++) {
            pEl = this.objectsList[el];
            pId = pEl.id;
            if (Type.exists(pEl.hasPoint) &&
                pEl.visPropCalc.visible &&
                pEl.hasPoint(x, y)) {
                // this is required in any case because otherwise the box won't be shown until the point is dragged
                this.updateInfobox(pEl);
                if (!Type.exists(this.highlightedObjects[pId])) {
                    // highlight only if not highlighted
                    overObjects[pId] = pEl;
                    pEl.highlight();
                    // triggers board event.
                    this.triggerEventHandlers(['mousehit', 'hit'], [evt, pEl, target]);
                }
                if (pEl.mouseover) {
                    pEl.triggerEventHandlers(['mousemove', 'move'], [evt]);
                }
                else {
                    pEl.triggerEventHandlers(['mouseover', 'over'], [evt]);
                    pEl.mouseover = true;
                }
            }
        }
        for (el = 0; el < len; el++) {
            pEl = this.objectsList[el];
            pId = pEl.id;
            if (pEl.mouseover) {
                if (!overObjects[pId]) {
                    pEl.triggerEventHandlers(['mouseout', 'out'], [evt]);
                    pEl.mouseover = false;
                }
            }
        }
    }
    /**
     * Helper function which returns a reasonable starting point for the object being dragged.
     * Formerly known as initXYstart().
     * @private
     * @param {JXG.GeometryElement} obj The object to be dragged
     * @param {Array} targets Array of targets. It is changed by this function.
     */
    saveStartPos(obj, targets) {
        var xy = [], i, len;
        if (obj.type === OBJECT_TYPE.TICKS) {
            xy.push([1, NaN, NaN]);
        }
        else if (obj.elementClass === OBJECT_CLASS.LINE) {
            xy.push(obj.point1.coords.usrCoords);
            xy.push(obj.point2.coords.usrCoords);
        }
        else if (obj.elementClass === OBJECT_CLASS.CIRCLE) {
            xy.push(obj.center.coords.usrCoords);
            if (obj.method === 'twoPoints') {
                xy.push(obj.point2.coords.usrCoords);
            }
        }
        else if (obj.type === OBJECT_TYPE.POLYGON) {
            len = obj.vertices.length - 1;
            for (i = 0; i < len; i++) {
                xy.push(obj.vertices[i].coords.usrCoords);
            }
        }
        else if (obj.type === OBJECT_TYPE.SECTOR) {
            xy.push(obj.point1.coords.usrCoords);
            xy.push(obj.point2.coords.usrCoords);
            xy.push(obj.point3.coords.usrCoords);
        }
        else if (Type.isPoint(obj) || obj.type === OBJECT_TYPE.GLIDER) {
            xy.push(obj.coords.usrCoords);
        }
        else if (obj.elementClass === OBJECT_CLASS.CURVE) {
            // if (Type.exists(obj.parents)) {
            //     len = obj.parents.length;
            //     if (len > 0) {
            //         for (i = 0; i < len; i++) {
            //             xy.push(this.select(obj.parents[i]).coords.usrCoords);
            //         }
            //     } else
            // }
            if (obj.points.length > 0) {
                xy.push(obj.points[0].usrCoords);
            }
        }
        else {
            try {
                xy.push(obj.coords.usrCoords);
            }
            catch (e) {
                JXG.debug('JSXGraph+ saveStartPos: obj.coords.usrCoords not available: ' + e);
            }
        }
        len = xy.length;
        for (i = 0; i < len; i++) {
            targets.Zstart.push(xy[i][0]);
            targets.Xstart.push(xy[i][1]);
            targets.Ystart.push(xy[i][2]);
        }
    }
    mouseOriginMoveStart(evt) {
        var r, pos;
        r = this._isRequiredKeyPressed(evt, 'pan');
        if (r) {
            pos = this.getMousePosition(evt);
            this.initMoveOrigin(pos[0], pos[1]);
        }
        return r;
    }
    mouseOriginMove(evt) {
        var r = this.mode === BOARD_MODE.MOVE_ORIGIN, pos;
        if (r) {
            pos = this.getMousePosition(evt);
            this.moveOrigin(pos[0], pos[1], true);
        }
        return r;
    }
    /**
     * Start moving the origin with one finger.
     * @private
     * @param  {Object} evt Event from touchStartListener
     * @return {Boolean}   returns if the origin is moved.
     */
    touchStartMoveOriginOneFinger(evt) {
        var touches = evt['touches'], conditions, pos;
        conditions =
            this.attr.pan.enabled && !this.attr.pan.needtwofingers && touches.length === 1;
        if (conditions) {
            pos = this.getMousePosition(evt, 0);
            this.initMoveOrigin(pos[0], pos[1]);
        }
        return conditions;
    }
    /**
     * Move the origin with one finger
     * @private
     * @param  {Object} evt Event from touchMoveListener
     * @return {Boolean}     returns if the origin is moved.
     */
    touchOriginMove(evt) {
        var r = this.mode === BOARD_MODE.MOVE_ORIGIN, pos;
        if (r) {
            pos = this.getMousePosition(evt, 0);
            this.moveOrigin(pos[0], pos[1], true);
        }
        return r;
    }
    /**
     * Stop moving the origin with one finger
     * @return {null} null
     * @private
     */
    originMoveEnd() {
        this.updateQuality = BOARD_QUALITY.HIGH;
        this.mode = BOARD_MODE.NONE;
    }
    /**********************************************************
     *
     * Event Handler
     *
     **********************************************************/
    /**
     * Suppresses the default event handling.
     * Used for context menu.
     *
     * @param {Event} e
     * @returns {Boolean} false
     */
    suppressDefault(e) {
        if (Type.exists(e)) {
            e.preventDefault();
        }
        return false;
    }
    /**
     * Add all possible event handlers to the board object
     * that move objects, i.e. mouse, pointer and touch events.
     */
    addEventHandlers() {
        if (Env.supportsPointerEvents()) {
            this.addPointerEventHandlers();
        }
        else {
            this.addMouseEventHandlers();
            this.addTouchEventHandlers();
        }
        if (this.containerObj !== null) {
            // this.containerObj.oncontextmenu = this.suppressDefault;
            Env.addEvent(this.containerObj, 'contextmenu', this.suppressDefault, this);
        }
        // This one produces errors on IE
        // // Env.addEvent(this.containerObj, 'contextmenu', function (e) { e.preventDefault(); return false;} this);
        // This one works on IE, Firefox and Chromium with default configurations. On some Safari
        // or Opera versions the user must explicitly allow the deactivation of the context menu.
    }
    /**
     * Remove all event handlers from the board object
     */
    removeEventHandlers() {
        if ((this.hasPointerHandlers || this.hasMouseHandlers || this.hasTouchHandlers) &&
            this.containerObj !== null) {
            Env.removeEvent(this.containerObj, 'contextmenu', this.suppressDefault, this);
        }
        this.removeMouseEventHandlers();
        this.removeTouchEventHandlers();
        this.removePointerEventHandlers();
        this.removeFullscreenEventHandlers();
        this.removeKeyboardEventHandlers();
        this.removeResizeEventHandlers();
        // if (Env.isBrowser) {
        //     if (Type.exists(this.resizeObserver)) {
        //         this.stopResizeObserver();
        //     } else {
        //         Env.removeEvent(window, 'resize', this.resizeListener, this);
        //         this.stopIntersectionObserver();
        //     }
        //     Env.removeEvent(window, 'scroll', this.scrollListener, this);
        // }
    }
    /**
     * Add resize related event handlers
     *
     */
    addResizeEventHandlers() {
        // var that = this;
        this.resizeHandlers = [];
        if (Env.isBrowser) {
            try {
                // Supported by all new browsers
                // resizeObserver: triggered if size of the JSXGraph div changes.
                this.startResizeObserver();
                this.resizeHandlers.push('resizeobserver');
            }
            catch (err) {
                throw new Error('not supported safari ??');
            }
            // Scroll event: needs to be captured since on mobile devices
            // sometimes a header bar is displayed / hidden, which triggers a
            // resize event.
            Env.addEvent(window, 'scroll', this.scrollListener, this);
            this.resizeHandlers.push('scroll');
            // On browser print:
            // we need to call the listener when having @media: print.
            try {
                // window.matchMedia("print").addEventListener('change', this.printListenerMatch.apply(this, arguments));
                window.matchMedia("print").addEventListener('change', this.printListenerMatch.bind(this));
                window.matchMedia("screen").addEventListener('change', this.printListenerMatch.bind(this));
                this.resizeHandlers.push('print');
            }
            catch (err) {
                JXG.debug("Error adding printListener", err);
            }
            // if (Type.isFunction(MediaQueryList.prototype.addEventListener)) {
            //     window.matchMedia("print").addEventListener('change', function (mql) {
            //         if (mql.matches) {
            //             that.printListener();
            //         }
            //     });
            // } else if (Type.isFunction(MediaQueryList.prototype.addListener)) { // addListener might be deprecated
            //     window.matchMedia("print").addListener(function (mql, ev) {
            //         if (mql.matches) {
            //             that.printListener(ev);
            //         }
            //     });
            // }
            // When closing the print dialog we again have to resize.
            // Env.addEvent(window, 'afterprint', this.printListener, this);
            // this.resizeHandlers.push('afterprint');
        }
    }
    /**
     * Remove resize related event handlers
     *
     */
    removeResizeEventHandlers() {
        var i, e;
        if (this.resizeHandlers.length > 0 && Env.isBrowser) {
            for (i = 0; i < this.resizeHandlers.length; i++) {
                e = this.resizeHandlers[i];
                switch (e) {
                    case 'resizeobserver':
                        if (Type.exists(this.resizeObserver)) {
                            this.stopResizeObserver();
                        }
                        break;
                    case 'resize':
                        Env.removeEvent(window, 'resize', this.resizeListener, this);
                        if (Type.exists(this.intersectionObserver)) {
                            this.stopIntersectionObserver();
                        }
                        break;
                    case 'scroll':
                        Env.removeEvent(window, 'scroll', this.scrollListener, this);
                        break;
                    case 'print':
                        window.matchMedia("print").removeEventListener('change', this.printListenerMatch.bind(this), false);
                        window.matchMedia("screen").removeEventListener('change', this.printListenerMatch.bind(this), false);
                        break;
                    // case 'afterprint':
                    //     Env.removeEvent(window, 'afterprint', this.printListener, this);
                    //     break;
                }
            }
            this.resizeHandlers = [];
        }
    }
    /**
     * Registers pointer event handlers.
     */
    addPointerEventHandlers() {
        if (!this.hasPointerHandlers && Env.isBrowser) {
            var moveTarget = this.attr.movetarget || this.containerObj;
            // if (window.navigator.msPointerEnabled) {
            //     // IE10-
            //     Env.addEvent(this.containerObj, 'MSPointerDown', this.pointerDownListener, this);
            //     Env.addEvent(moveTarget, 'MSPointerMove', this.pointerMoveListener, this);
            // } else {
            Env.addEvent(this.containerObj, 'pointerdown', this.pointerDownListener, this);
            Env.addEvent(moveTarget, 'pointermove', this.pointerMoveListener, this);
            Env.addEvent(moveTarget, 'pointerleave', this.pointerLeaveListener, this);
            Env.addEvent(moveTarget, 'click', this.pointerClickListener, this);
            Env.addEvent(moveTarget, 'dblclick', this.pointerDblClickListener, this);
            // }
            if (this.containerObj !== null) {
                // This is needed for capturing touch events.
                // It is in jsxgraph.css, for ms-touch-action...
                this.containerObj.style.touchAction = 'none';
                // this.containerObj.style.touchAction = 'auto';
            }
            this.hasPointerHandlers = true;
        }
    }
    /**
     * Registers mouse move, down and wheel event handlers.
     */
    addMouseEventHandlers() {
        if (!this.hasMouseHandlers && Env.isBrowser) {
            var moveTarget = this.attr.movetarget || this.containerObj;
            Env.addEvent(this.containerObj, 'mousedown', this.mouseDownListener, this);
            Env.addEvent(moveTarget, 'mousemove', this.mouseMoveListener, this);
            Env.addEvent(moveTarget, 'click', this.mouseClickListener, this);
            Env.addEvent(moveTarget, 'dblclick', this.mouseDblClickListener, this);
            this.hasMouseHandlers = true;
        }
    }
    /**
     * Register touch start and move and gesture start and change event handlers.
     * @param {Boolean} appleGestures If set to false the gesturestart and gesturechange event handlers
     * will not be registered.
     *
     * Since iOS 13, touch events were abandoned in favour of pointer events
     */
    addTouchEventHandlers(appleGestures = true) {
        if (!this.hasTouchHandlers && Env.isBrowser) {
            var moveTarget = this.attr.movetarget || this.containerObj;
            Env.addEvent(this.containerObj, 'touchstart', this.touchStartListener, this);
            Env.addEvent(moveTarget, 'touchmove', this.touchMoveListener, this);
            /*
            if (!Type.exists(appleGestures) || appleGestures) {
                // Gesture listener are called in touchStart and touchMove.
                //Env.addEvent(this.containerObj, 'gesturestart', this.gestureStartListener, this);
                //Env.addEvent(this.containerObj, 'gesturechange', this.gestureChangeListener, this);
            }
            */
            this.hasTouchHandlers = true;
        }
    }
    /**
     * Registers pointer event handlers.
     */
    addWheelEventHandlers() {
        if (!this.hasWheelHandlers && Env.isBrowser) {
            Env.addEvent(this.containerObj, 'mousewheel', this.mouseWheelListener, this);
            Env.addEvent(this.containerObj, 'DOMMouseScroll', this.mouseWheelListener, this);
            this.hasWheelHandlers = true;
        }
    }
    /**
     * Add fullscreen events which update the CSS transformation matrix to correct
     * the mouse/touch/pointer positions in case of CSS transformations.
     */
    addFullscreenEventHandlers() {
        var i, 
        // standard/Edge, firefox, chrome/safari, IE11
        events = [
            'fullscreenchange',
            'mozfullscreenchange',
            'webkitfullscreenchange',
            'msfullscreenchange'
        ], le = events.length;
        if (!this.hasFullscreenEventHandlers && Env.isBrowser) {
            for (i = 0; i < le; i++) {
                Env.addEvent(this.document, events[i], this.fullscreenListener, this);
            }
            this.hasFullscreenEventHandlers = true;
        }
    }
    /**
     * Register keyboard event handlers.
     */
    addKeyboardEventHandlers() {
        if (this.attr.keyboard.enabled && !this.hasKeyboardHandlers && Env.isBrowser) {
            Env.addEvent(this.containerObj, 'keydown', this.keyDownListener, this);
            Env.addEvent(this.containerObj, 'focusin', this.keyFocusInListener, this);
            Env.addEvent(this.containerObj, 'focusout', this.keyFocusOutListener, this);
            this.hasKeyboardHandlers = true;
        }
    }
    /**
     * Remove all registered touch event handlers.
     */
    removeKeyboardEventHandlers() {
        if (this.hasKeyboardHandlers && Env.isBrowser) {
            Env.removeEvent(this.containerObj, 'keydown', this.keyDownListener, this);
            Env.removeEvent(this.containerObj, 'focusin', this.keyFocusInListener, this);
            Env.removeEvent(this.containerObj, 'focusout', this.keyFocusOutListener, this);
            this.hasKeyboardHandlers = false;
        }
    }
    /**
     * Remove all registered event handlers regarding fullscreen mode.
     */
    removeFullscreenEventHandlers() {
        var i, 
        // standard/Edge, firefox, chrome/safari, IE11
        events = [
            'fullscreenchange',
            'mozfullscreenchange',
            'webkitfullscreenchange',
            'msfullscreenchange'
        ], le = events.length;
        if (this.hasFullscreenEventHandlers && Env.isBrowser) {
            for (i = 0; i < le; i++) {
                Env.removeEvent(this.document, events[i], this.fullscreenListener, this);
            }
            this.hasFullscreenEventHandlers = false;
        }
    }
    /**
     * Remove MSPointer* Event handlers.
     */
    removePointerEventHandlers() {
        if (this.hasPointerHandlers && Env.isBrowser) {
            var moveTarget = this.attr.movetarget || this.containerObj;
            // if (window.navigator.msPointerEnabled) {
            //     // IE10-
            //     Env.removeEvent(this.containerObj, 'MSPointerDown', this.pointerDownListener, this);
            //     Env.removeEvent(moveTarget, 'MSPointerMove', this.pointerMoveListener, this);
            // } else {
            Env.removeEvent(this.containerObj, 'pointerdown', this.pointerDownListener, this);
            Env.removeEvent(moveTarget, 'pointermove', this.pointerMoveListener, this);
            Env.removeEvent(moveTarget, 'pointerleave', this.pointerLeaveListener, this);
            Env.removeEvent(moveTarget, 'click', this.pointerClickListener, this);
            Env.removeEvent(moveTarget, 'dblclick', this.pointerDblClickListener, this);
            // }
            if (this.hasWheelHandlers) {
                Env.removeEvent(this.containerObj, 'mousewheel', this.mouseWheelListener, this);
                Env.removeEvent(this.containerObj, 'DOMMouseScroll', this.mouseWheelListener, this);
            }
            if (this.hasPointerUp) {
                Env.removeEvent(this.document, 'pointerup', this.pointerUpListener, this);
                Env.removeEvent(this.document, 'pointercancel', this.pointerUpListener, this);
                this.hasPointerUp = false;
            }
            this.hasPointerHandlers = false;
        }
    }
    /**
     * De-register mouse event handlers.
     */
    removeMouseEventHandlers() {
        if (this.hasMouseHandlers && Env.isBrowser) {
            var moveTarget = this.attr.movetarget || this.containerObj;
            Env.removeEvent(this.containerObj, 'mousedown', this.mouseDownListener, this);
            Env.removeEvent(moveTarget, 'mousemove', this.mouseMoveListener, this);
            Env.removeEvent(moveTarget, 'click', this.mouseClickListener, this);
            Env.removeEvent(moveTarget, 'dblclick', this.mouseDblClickListener, this);
            if (this.hasMouseUp) {
                Env.removeEvent(this.document, 'mouseup', this.mouseUpListener, this);
                this.hasMouseUp = false;
            }
            if (this.hasWheelHandlers) {
                Env.removeEvent(this.containerObj, 'mousewheel', this.mouseWheelListener, this);
                Env.removeEvent(this.containerObj, 'DOMMouseScroll', this.mouseWheelListener, this);
            }
            this.hasMouseHandlers = false;
        }
    }
    /**
     * Remove all registered touch event handlers.
     */
    removeTouchEventHandlers() {
        if (this.hasTouchHandlers && Env.isBrowser) {
            var moveTarget = this.attr.movetarget || this.containerObj;
            Env.removeEvent(this.containerObj, 'touchstart', this.touchStartListener, this);
            Env.removeEvent(moveTarget, 'touchmove', this.touchMoveListener, this);
            if (this.hasTouchEnd) {
                Env.removeEvent(this.document, 'touchend', this.touchEndListener, this);
                this.hasTouchEnd = false;
            }
            this.hasTouchHandlers = false;
        }
    }
    /**
     * Handler for click on left arrow in the navigation bar
     * @returns {JXG.Board} Reference to the board
     */
    clickLeftArrow() {
        this.moveOrigin(this.origin.scrCoords[1] + this.canvasWidth * 0.1, this.origin.scrCoords[2]);
        return this;
    }
    /**
     * Handler for click on right arrow in the navigation bar
     * @returns {JXG.Board} Reference to the board
     */
    clickRightArrow() {
        this.moveOrigin(this.origin.scrCoords[1] - this.canvasWidth * 0.1, this.origin.scrCoords[2]);
        return this;
    }
    /**
     * Handler for click on up arrow in the navigation bar
     * @returns {JXG.Board} Reference to the board
     */
    clickUpArrow() {
        this.moveOrigin(this.origin.scrCoords[1], this.origin.scrCoords[2] - this.canvasHeight * 0.1);
        return this;
    }
    /**
     * Handler for click on down arrow in the navigation bar
     * @returns {JXG.Board} Reference to the board
     */
    clickDownArrow() {
        this.moveOrigin(this.origin.scrCoords[1], this.origin.scrCoords[2] + this.canvasHeight * 0.1);
        return this;
    }
    /**
     * Triggered on iOS/Safari while the user inputs a gesture (e.g. pinch) and is used to zoom into the board.
     * Works on iOS/Safari and Android.
     * @param {Event} evt Browser event object
     * @returns {Boolean}
     */
    gestureChangeListener(evt) {
        var c, dir1 = [], dir2 = [], angle, mi = 10, isPinch = false, 
        // Save zoomFactors
        zx = this.attr.zoom.factorx, zy = this.attr.zoom.factory, factor, dist, theta, bound, zoomCenter, doZoom = false, dx, dy, cx, cy;
        if (this.mode !== BOARD_MODE.ZOOM) {
            return true;
        }
        evt.preventDefault();
        dist = Geometry.distance([evt.touches[0].clientX, evt.touches[0].clientY], [evt.touches[1].clientX, evt.touches[1].clientY], 2);
        // Android pinch to zoom
        // evt.scale was available in iOS touch events (pre iOS 13)
        // evt.scale is undefined in Android
        if (evt.scale === undefined) {
            evt.scale = dist / this.prevDist;
        }
        if (!Type.exists(this.prevCoords)) {
            return false;
        }
        // Compute the angle of the two finger directions
        dir1 = [
            evt.touches[0].clientX - this.prevCoords[0][0],
            evt.touches[0].clientY - this.prevCoords[0][1]
        ];
        dir2 = [
            evt.touches[1].clientX - this.prevCoords[1][0],
            evt.touches[1].clientY - this.prevCoords[1][1]
        ];
        if (dir1[0] * dir1[0] + dir1[1] * dir1[1] < mi * mi &&
            dir2[0] * dir2[0] + dir2[1] * dir2[1] < mi * mi) {
            return false;
        }
        angle = Geometry.rad(dir1, [0, 0], dir2);
        if (this.isPreviousGesture !== 'pan' &&
            Math.abs(angle) > Math.PI * 0.2 &&
            Math.abs(angle) < Math.PI * 1.8) {
            isPinch = true;
        }
        if (this.isPreviousGesture !== 'pan' && !isPinch) {
            if (Math.abs(evt.scale) < 0.77 || Math.abs(evt.scale) > 1.3) {
                isPinch = true;
            }
        }
        factor = evt.scale / this.prevScale;
        this.prevScale = evt.scale;
        this.prevCoords = [
            [evt.touches[0].clientX, evt.touches[0].clientY],
            [evt.touches[1].clientX, evt.touches[1].clientY]
        ];
        c = new Coords$1(COORDS_BY.SCREEN, this.getMousePosition(evt, 0), this);
        if (this.attr.pan.enabled && this.attr.pan.needtwofingers && !isPinch) {
            // Pan detected
            this.isPreviousGesture = 'pan';
            this.moveOrigin(c.scrCoords[1], c.scrCoords[2], true);
        }
        else if (this.attr.zoom.enabled && Math.abs(factor - 1.0) < 0.5) {
            doZoom = false;
            zoomCenter = this.attr.zoom.center;
            // Pinch detected
            if (this.attr.zoom.pinchhorizontal || this.attr.zoom.pinchvertical) {
                dx = Math.abs(evt.touches[0].clientX - evt.touches[1].clientX);
                dy = Math.abs(evt.touches[0].clientY - evt.touches[1].clientY);
                theta = Math.abs(Math.atan2(dy, dx));
                bound = (Math.PI * this.attr.zoom.pinchsensitivity) / 90.0;
            }
            if (!this.keepaspectratio &&
                this.attr.zoom.pinchhorizontal &&
                theta < bound) {
                this.attr.zoom.factorx = factor;
                this.attr.zoom.factory = 1.0;
                cx = 0;
                cy = 0;
                doZoom = true;
            }
            else if (!this.keepaspectratio &&
                this.attr.zoom.pinchvertical &&
                Math.abs(theta - Math.PI * 0.5) < bound) {
                this.attr.zoom.factorx = 1.0;
                this.attr.zoom.factory = factor;
                cx = 0;
                cy = 0;
                doZoom = true;
            }
            else if (this.attr.zoom.pinch) {
                this.attr.zoom.factorx = factor;
                this.attr.zoom.factory = factor;
                cx = c.usrCoords[1];
                cy = c.usrCoords[2];
                doZoom = true;
            }
            if (doZoom) {
                if (zoomCenter === 'board') {
                    this.zoomIn();
                }
                else { // including zoomCenter === 'auto'
                    this.zoomIn(cx, cy);
                }
                // Restore zoomFactors
                this.attr.zoom.factorx = zx;
                this.attr.zoom.factory = zy;
            }
        }
        return false;
    }
    /**
     * Called by iOS/Safari as soon as the user starts a gesture. Works natively on iOS/Safari,
     * on Android we emulate it.
     * @param {Event} evt
     * @returns {Boolean}
     */
    gestureStartListener(evt) {
        var pos;
        evt.preventDefault();
        this.prevScale = 1.0;
        // Android pinch to zoom
        this.prevDist = Geometry.distance([evt.touches[0].clientX, evt.touches[0].clientY], [evt.touches[1].clientX, evt.touches[1].clientY], 2);
        this.prevCoords = [
            [evt.touches[0].clientX, evt.touches[0].clientY],
            [evt.touches[1].clientX, evt.touches[1].clientY]
        ];
        this.isPreviousGesture = 'none';
        // If pinch-to-zoom is interpreted as panning
        // we have to prepare move origin
        pos = this.getMousePosition(evt, 0);
        this.initMoveOrigin(pos[0], pos[1]);
        this.mode = BOARD_MODE.ZOOM;
        return false;
    }
    /**
     * Test if the required key combination is pressed for wheel zoom, move origin and
     * selection
     * @private
     * @param  {Object}  evt    Mouse or pen event
     * @param  {String}  action String containing the action: 'zoom', 'pan', 'selection'.
     * Corresponds to the attribute subobject.
     * @return {Boolean}        true or false.
     */
    _isRequiredKeyPressed(evt, action) {
        var obj = this.attr[action];
        if (!obj.enabled) {
            return false;
        }
        if (((obj.needshift && evt.shiftKey) || (!obj.needshift && !evt.shiftKey)) &&
            ((obj.needctrl && evt.ctrlKey) || (!obj.needctrl && !evt.ctrlKey))) {
            return true;
        }
        return false;
    }
    /*
     * Pointer events
     */
    /**
     *
     * Check if pointer event is already registered in {@link JXG.Board#_board_touches}.
     *
     * @param  {Object} evt Event object
     * @return {Boolean} true if down event has already been sent.
     * @private
     */
    _isPointerRegistered(evt) {
        var i, len = this._board_touches.length;
        for (i = 0; i < len; i++) {
            if (this._board_touches[i].pointerId === evt.pointerId) {
                return true;
            }
        }
        return false;
    }
    /**
     *
     * Store the position of a pointer event.
     * If not yet done, registers a pointer event in {@link JXG.Board#_board_touches}.
     * Allows to follow the path of that finger on the screen.
     * Only two simultaneous touches are supported.
     *
     * @param {Object} evt Event object
     * @returns {JXG.Board} Reference to the board
     * @private
     */
    _pointerStorePosition(evt) {
        var i, found;
        for (i = 0, found = false; i < this._board_touches.length; i++) {
            if (this._board_touches[i].pointerId === evt.pointerId) {
                this._board_touches[i].clientX = evt.clientX;
                this._board_touches[i].clientY = evt.clientY;
                found = true;
                break;
            }
        }
        // Restrict the number of simultaneous touches to 2
        if (!found && this._board_touches.length < 2) {
            this._board_touches.push({
                pointerId: evt.pointerId,
                clientX: evt.clientX,
                clientY: evt.clientY
            });
        }
        return this;
    }
    /**
     * Deregisters a pointer event in {@link JXG.Board#_board_touches}.
     * It happens if a finger has been lifted from the screen.
     *
     * @param {Object} evt Event object
     * @returns {JXG.Board} Reference to the board
     * @private
     */
    _pointerRemoveTouches(evt) {
        var i;
        for (i = 0; i < this._board_touches.length; i++) {
            if (this._board_touches[i].pointerId === evt.pointerId) {
                this._board_touches.splice(i, 1);
                break;
            }
        }
        return this;
    }
    /**
     * Remove all registered fingers from {@link JXG.Board#_board_touches}.
     * This might be necessary if too many fingers have been registered.
     * @returns {JXG.Board} Reference to the board
     * @private
     */
    _pointerClearTouches(pId) {
        // var i;
        // if (pId) {
        //     for (i = 0; i < this._board_touches.length; i++) {
        //         if (pId === this._board_touches[i].pointerId) {
        //             this._board_touches.splice(i, i);
        //             break;
        //         }
        //     }
        // } else {
        // }
        if (this._board_touches.length > 0) {
            this.dehighlightAll();
        }
        this.updateQuality = BOARD_QUALITY.HIGH;
        this.mode = BOARD_MODE.NONE;
        this._board_touches = [];
        this.touches = [];
    }
    /**
     * Determine which input device is used for this action.
     * Possible devices are 'touch', 'pen' and 'mouse'.
     * This affects the precision and certain events.
     * In case of no browser, 'mouse' is used.
     *
     * @see JXG.Board#pointerDownListener
     * @see JXG.Board#pointerMoveListener
     * @see JXG.Board#initMoveObject
     * @see JXG.Board#moveObject
     *
     * @param {Event} evt The browsers event object.
     * @returns {String} 'mouse', 'pen', or 'touch'
     * @private
     */
    _getPointerInputDevice(evt) {
        if (Env.isBrowser) {
            if (evt.pointerType === 'touch' || // New
                (window.navigator.maxTouchPoints && // Old
                    window.navigator.maxTouchPoints > 1)) {
                return 'touch';
            }
            if (evt.pointerType === 'mouse') {
                return 'mouse';
            }
            if (evt.pointerType === 'pen') {
                return 'pen';
            }
        }
        return 'mouse';
    }
    /**
     * This method is called by the browser when a pointing device is pressed on the screen.
     * @param {Event} evt The browsers event object.
     * @param {Object} object If the object to be dragged is already known, it can be submitted via this parameter
     * @param {Boolean} [allowDefaultEventHandling=false] If true event is not canceled, i.e. prevent call of evt.preventDefault()
     * @returns {Boolean} false if the first finger event is sent twice, or not a browser, or in selection mode. Otherwise returns true.
     */
    pointerDownListener(evt, object, allowDefaultEventHandling) {
        var i, j, k, pos, elements, sel, target_obj, type = 'mouse', // Used in case of no browser
        found, target, ta;
        // Fix for Firefox browser: When using a second finger, the
        // touch event for the first finger is sent again.
        if (!object && this._isPointerRegistered(evt)) {
            return false;
        }
        if (Type.evaluate(this.attr.movetarget) === null &&
            Type.exists(evt.target) && Type.exists(evt.target.releasePointerCapture)) {
            evt.target.releasePointerCapture(evt.pointerId);
        }
        if (!object && evt.isPrimary) ;
        if (!this.hasPointerUp) {
            // if (window.navigator.msPointerEnabled) {
            //     // IE10-
            //     Env.addEvent(this.document, 'MSPointerUp', this.pointerUpListener, this);
            // } else {
            // 'pointercancel' is fired e.g. if the finger leaves the browser and drags down the system menu on Android
            Env.addEvent(this.document, 'pointerup', this.pointerUpListener, this);
            Env.addEvent(this.document, 'pointercancel', this.pointerUpListener, this);
            // }
            this.hasPointerUp = true;
        }
        if (this.hasMouseHandlers) {
            this.removeMouseEventHandlers();
        }
        if (this.hasTouchHandlers) {
            this.removeTouchEventHandlers();
        }
        // Prevent accidental selection of text
        // TODO: selection doesn't exist
        // if (this.document.selection && Type.isFunction(this.document.selection.empty)) {
        //     this.document.selection.empty();
        // } else if (window.getSelection) {
        sel = window.getSelection();
        if (sel.removeAllRanges) {
            try {
                sel.removeAllRanges();
            }
            catch (e) { }
        }
        // }
        // Mouse, touch or pen device
        this._inputDevice = this._getPointerInputDevice(evt);
        type = this._inputDevice;
        Options.precision.hasPoint = Options.precision[type];
        // Handling of multi touch with pointer events should be easier than with touch events.
        // Every pointer device has its own pointerId, e.g. the mouse
        // always has id 1 or 0, fingers and pens get unique ids every time a pointerDown event is fired and they will
        // keep this id until a pointerUp event is fired. What we have to do here is:
        //  1. collect all elements under the current pointer
        //  2. run through the touches control structure
        //    a. look for the object collected in step 1.
        //    b. if an object is found, check the number of pointers. If appropriate, add the pointer.
        pos = this.getMousePosition(evt);
        // Handle selection rectangle
        this._testForSelection(evt);
        if (this.selectingMode) {
            this._startSelecting(pos);
            this.triggerEventHandlers(['touchstartselecting', 'pointerstartselecting', 'startselecting'], [evt]);
            return; // don't continue as a normal click
        }
        if (this.attr.drag.enabled && object) {
            elements = [object];
            this.mode = BOARD_MODE.DRAG;
        }
        else {
            elements = this.initMoveObject(pos[0], pos[1], evt, type);
        }
        target_obj = {
            num: evt.pointerId,
            X: pos[0],
            Y: pos[1],
            Xprev: NaN,
            Yprev: NaN,
            Xstart: [],
            Ystart: [],
            Zstart: []
        };
        // If no draggable object can be found, get out here immediately
        if (elements.length > 0) {
            // check touches structure
            target = elements[elements.length - 1];
            found = false;
            // Reminder: this.touches is the list of elements which
            // currently 'possess' a pointer (mouse, pen, finger)
            for (i = 0; i < this.touches.length; i++) {
                // An element receives a further touch, i.e.
                // the target is already in our touches array, add the pointer to the existing touch
                if (this.touches[i].obj === target) {
                    j = i;
                    k = this.touches[i].targets.push(target_obj) - 1;
                    found = true;
                    break;
                }
            }
            if (!found) {
                // A new element has been touched.
                k = 0;
                j =
                    this.touches.push({
                        obj: target,
                        targets: [target_obj]
                    }) - 1;
            }
            this.dehighlightAll();
            target.highlight(true);
            this.saveStartPos(target, this.touches[j].targets[k]);
            // Prevent accidental text selection
            // this could get us new trouble: input fields, links and drop down boxes placed as text
            // on the board don't work anymore.
            if (evt && evt.preventDefault && !allowDefaultEventHandling) {
                // All browser supporting pointer events know preventDefault()
                evt.preventDefault();
            }
        }
        if (this.touches.length > 0 && !allowDefaultEventHandling) {
            evt.preventDefault();
            evt.stopPropagation();
        }
        if (!Env.isBrowser) {
            return false;
        }
        if (this._getPointerInputDevice(evt) !== 'touch') {
            if (this.mode === BOARD_MODE.NONE) {
                this.mouseOriginMoveStart(evt);
            }
        }
        else {
            this._pointerStorePosition(evt);
            evt.touches = this._board_touches;
            // Touch events on empty areas of the board are handled here, see also touchStartListener
            // 1. case: one finger. If allowed, this triggers pan with one finger
            if (evt.touches.length === 1 &&
                this.mode === BOARD_MODE.NONE &&
                this.touchStartMoveOriginOneFinger(evt)) ;
            else if (evt.touches.length === 2 &&
                (this.mode === BOARD_MODE.NONE ||
                    this.mode === BOARD_MODE.MOVE_ORIGIN)) {
                // 2. case: two fingers: pinch to zoom or pan with two fingers needed.
                // This happens when the second finger hits the device. First, the
                // 'one finger pan mode' has to be cancelled.
                if (this.mode === BOARD_MODE.MOVE_ORIGIN) {
                    this.originMoveEnd();
                }
                this.gestureStartListener(evt);
            }
        }
        // Allow browser scrolling
        // For this: pan by one finger has to be disabled
        ta = 'none'; // JSXGraph catches all user touch events
        if (this.mode === BOARD_MODE.NONE &&
            (Type.evaluate(this.attr.browserpan) === true || Type.evaluate(this.attr.browserpan.enabled) === true) &&
            // One-finger pan has priority over browserPan
            (Type.evaluate(this.attr.pan.enabled) === false || Type.evaluate(this.attr.pan.needtwofingers) === true)) {
            // ta = 'pan-x pan-y';  // JSXGraph allows browser scrolling
            ta = 'auto'; // JSXGraph allows browser scrolling
        }
        this.containerObj.style.touchAction = ta;
        this.triggerEventHandlers(['touchstart', 'down', 'pointerdown', 'MSPointerDown'], [evt]);
        return true;
    }
    /**
     * Internal handling of click events for pointers and mouse.
     *
     * @param {Event} evt The browsers event object.
     * @param {Array} evtArray list of event names
     * @private
     */
    _handleClicks(evt, evtArray) {
        var that = this, el, delay, suppress;
        if (this.selectingMode) {
            evt.stopPropagation();
            return;
        }
        delay = Type.evaluate(this.attr.clickdelay);
        suppress = Type.evaluate(this.attr.dblclicksuppressclick);
        if (suppress) {
            // dblclick suppresses previous click events
            this._preventSingleClick = false;
            // Wait if there is a dblclick event.
            // If not fire a click event
            this._singleClickTimer = setTimeout(function () {
                if (!that._preventSingleClick) {
                    // Fire click event and remove element from click list
                    that.triggerEventHandlers(evtArray, [evt]);
                    for (el in that.clickObjects) {
                        if (that.clickObjects.hasOwnProperty(el)) {
                            that.clickObjects[el].triggerEventHandlers(evtArray, [evt]);
                            delete that.clickObjects[el];
                        }
                    }
                }
            }, delay);
        }
        else {
            // dblclick is preceded by two click events
            // Fire click events
            that.triggerEventHandlers(evtArray, [evt]);
            for (el in that.clickObjects) {
                if (that.clickObjects.hasOwnProperty(el)) {
                    that.clickObjects[el].triggerEventHandlers(evtArray, [evt]);
                }
            }
            // Clear list of clicked elements with a delay
            setTimeout(function () {
                for (el in that.clickObjects) {
                    if (that.clickObjects.hasOwnProperty(el)) {
                        delete that.clickObjects[el];
                    }
                }
            }, delay);
        }
        evt.stopPropagation();
    }
    /**
     * Internal handling of dblclick events for pointers and mouse.
     *
     * @param {Event} evt The browsers event object.
     * @param {Array} evtArray list of event names
     * @private
     */
    _handleDblClicks(evt, evtArray) {
        var el;
        if (this.selectingMode) {
            evt.stopPropagation();
            return;
        }
        // Notify that a dblclick has happened
        this._preventSingleClick = true;
        clearTimeout(this._singleClickTimer);
        // Fire dblclick event
        this.triggerEventHandlers(evtArray, [evt]);
        for (el in this.clickObjects) {
            if (this.clickObjects.hasOwnProperty(el)) {
                this.clickObjects[el].triggerEventHandlers(evtArray, [evt]);
                delete this.clickObjects[el];
            }
        }
        evt.stopPropagation();
    }
    /**
     * This method is called by the browser when a pointer device clicks on the screen.
     * @param {Event} evt The browsers event object.
     */
    pointerClickListener(evt) {
        this._handleClicks(evt, ['click', 'pointerclick']);
    }
    /**
     * This method is called by the browser when a pointer device double clicks on the screen.
     * @param {Event} evt The browsers event object.
     */
    pointerDblClickListener(evt) {
        this._handleDblClicks(evt, ['dblclick', 'pointerdblclick']);
    }
    /**
     * This method is called by the browser when the mouse device clicks on the screen.
     * @param {Event} evt The browsers event object.
     */
    mouseClickListener(evt) {
        this._handleClicks(evt, ['click', 'mouseclick']);
    }
    /**
     * This method is called by the browser when the mouse device double clicks on the screen.
     * @param {Event} evt The browsers event object.
     */
    mouseDblClickListener(evt) {
        this._handleDblClicks(evt, ['dblclick', 'mousedblclick']);
    }
    // /**
    //  * Called if pointer leaves an HTML tag. It is called by the inner-most tag.
    //  * That means, if a JSXGraph text, i.e. an HTML div, is placed close
    //  * to the border of the board, this pointerout event will be ignored.
    //  * @param  {Event} evt
    //  * @return {Boolean}
    //  */
    // pointerOutListener (evt) {
    //     if (evt.target === this.containerObj ||
    //         (this.renderer.type === 'svg' && evt.target === this.renderer.foreignObjLayer)) {
    //         this.pointerUpListener(evt);
    //     }
    //     return this.mode === BOARD_MODE.NONE;
    // }
    /**
     * Called periodically by the browser while the user moves a pointing device across the screen.
     * @param {Event} evt
     * @returns {Boolean}
     */
    pointerMoveListener(evt) {
        var i, j, pos, eps, touchTargets, type = 'mouse'; // in case of no browser
        if (this._getPointerInputDevice(evt) === 'touch' &&
            !this._isPointerRegistered(evt)) {
            // Test, if there was a previous down event of this _getPointerId
            // (in case it is a touch event).
            // Otherwise this move event is ignored. This is necessary e.g. for sketchometry.
            return BOARD_MODE.NONE;
        }
        if (!this.checkFrameRate(evt)) {
            return false;
        }
        if (this.mode !== BOARD_MODE.DRAG) {
            this.dehighlightAll();
            this.displayInfobox(false);
        }
        if (this.mode !== BOARD_MODE.NONE) {
            evt.preventDefault();
            evt.stopPropagation();
        }
        this.updateQuality = BOARD_QUALITY.HIGHLOW;
        // Mouse, touch or pen device
        this._inputDevice = this._getPointerInputDevice(evt);
        type = this._inputDevice;
        Options.precision.hasPoint = Options.precision[type];
        eps = Options.precision.hasPoint * 0.3333;
        pos = this.getMousePosition(evt);
        // Ignore pointer move event if too close at the border
        // and setPointerCapture is off
        if (Type.evaluate(this.attr.movetarget) === null &&
            pos[0] <= eps || pos[1] <= eps ||
            pos[0] >= this.canvasWidth - eps ||
            pos[1] >= this.canvasHeight - eps) {
            return this.mode === BOARD_MODE.NONE;
        }
        // selection
        if (this.selectingMode) {
            this._moveSelecting(pos);
            this.triggerEventHandlers(['touchmoveselecting', 'moveselecting', 'pointermoveselecting'], [evt, this.mode]);
        }
        else if (!this.mouseOriginMove(evt)) {
            if (this.mode === BOARD_MODE.DRAG) {
                // Run through all jsxgraph elements which are touched by at least one finger.
                for (i = 0; i < this.touches.length; i++) {
                    touchTargets = this.touches[i].targets;
                    // Run through all touch events which have been started on this jsxgraph element.
                    for (j = 0; j < touchTargets.length; j++) {
                        if (touchTargets[j].num === evt.pointerId) {
                            touchTargets[j].X = pos[0];
                            touchTargets[j].Y = pos[1];
                            if (touchTargets.length === 1) {
                                // Touch by one finger: this is possible for all elements that can be dragged
                                this.moveObject(pos[0], pos[1], this.touches[i], evt, type);
                            }
                            else if (touchTargets.length === 2) {
                                // Touch by two fingers: e.g. moving lines
                                this.twoFingerMove(this.touches[i], evt.pointerId, evt);
                                touchTargets[j].Xprev = pos[0];
                                touchTargets[j].Yprev = pos[1];
                            }
                            // There is only one pointer in the evt object, so there's no point in looking further
                            break;
                        }
                    }
                }
            }
            else {
                if (this._getPointerInputDevice(evt) === 'touch') {
                    this._pointerStorePosition(evt);
                    if (this._board_touches.length === 2) {
                        evt.touches = this._board_touches;
                        this.gestureChangeListener(evt);
                    }
                }
                // Move event without dragging an element
                this.highlightElements(pos[0], pos[1], evt, -1);
            }
        }
        // Hiding the infobox is commented out, since it prevents showing the infobox
        // on IE 11+ on 'over'
        //if (this.mode !== BOARD_MODE.DRAG) {
        //this.displayInfobox(false);
        //}
        this.triggerEventHandlers(['pointermove', 'MSPointerMove', 'move'], [evt, this.mode]);
        this.updateQuality = BOARD_QUALITY.HIGH;
        return this.mode === BOARD_MODE.NONE;
    }
    /**
     * Triggered as soon as the user stops touching the device with at least one finger.
     *
     * @param {Event} evt
     * @returns {Boolean}
     */
    pointerUpListener(evt) {
        var i, j, found, eh, touchTargets, updateNeeded = false;
        this.triggerEventHandlers(['touchend', 'up', 'pointerup', 'MSPointerUp'], [evt]);
        this.displayInfobox(false);
        if (evt) {
            for (i = 0; i < this.touches.length; i++) {
                touchTargets = this.touches[i].targets;
                for (j = 0; j < touchTargets.length; j++) {
                    if (touchTargets[j].num === evt.pointerId) {
                        touchTargets.splice(j, 1);
                        if (touchTargets.length === 0) {
                            this.touches.splice(i, 1);
                        }
                        break;
                    }
                }
            }
        }
        this.originMoveEnd();
        this.update();
        // selection
        if (this.selectingMode) {
            this._stopSelecting(evt);
            this.triggerEventHandlers(['touchstopselecting', 'pointerstopselecting', 'stopselecting'], [evt]);
            this.stopSelectionMode();
        }
        else {
            for (i = this.downObjects.length - 1; i > -1; i--) {
                found = false;
                for (j = 0; j < this.touches.length; j++) {
                    if (this.touches[j].obj.id === this.downObjects[i].id) {
                        found = true;
                    }
                }
                if (!found) {
                    this.downObjects[i].triggerEventHandlers(['touchend', 'up', 'pointerup', 'MSPointerUp'], [evt]);
                    if (!Type.exists(this.downObjects[i].coords)) {
                        // snapTo methods have to be called e.g. for line elements here.
                        // For coordsElements there might be a conflict with
                        // attractors, see commit from 2022.04.08, 11:12:18.
                        this.downObjects[i].snapToGrid();
                        this.downObjects[i].snapToPoints();
                        updateNeeded = true;
                    }
                    // Check if we have to keep the element for a click or dblclick event
                    // Otherwise remove it from downObjects
                    eh = this.downObjects[i].eventHandlers;
                    if ((Type.exists(eh.click) && eh.click.length > 0) ||
                        (Type.exists(eh.pointerclick) && eh.pointerclick.length > 0) ||
                        (Type.exists(eh.dblclick) && eh.dblclick.length > 0) ||
                        (Type.exists(eh.pointerdblclick) && eh.pointerdblclick.length > 0)) {
                        this.clickObjects[this.downObjects[i].id] = this.downObjects[i];
                    }
                    this.downObjects.splice(i, 1);
                }
            }
        }
        if (this.hasPointerUp) {
            Env.removeEvent(this.document, 'pointerup', this.pointerUpListener, this);
            Env.removeEvent(this.document, 'pointercancel', this.pointerUpListener, this);
            this.hasPointerUp = false;
        }
        // After one finger leaves the screen the gesture is stopped.
        this._pointerClearTouches(evt.pointerId);
        if (this._getPointerInputDevice(evt) !== 'touch') {
            this.dehighlightAll();
        }
        if (updateNeeded) {
            this.update();
        }
        return true;
    }
    /**
     * Triggered by the pointerleave event. This is needed in addition to
     * {@link JXG.Board#pointerUpListener} in the situation that a pen is used
     * and after an up event the pen leaves the hover range vertically. Here, it happens that
     * after the pointerup event further pointermove events are fired and elements get highlighted.
     * This highlighting has to be cancelled.
     *
     * @param {Event} evt
     * @returns {Boolean}
     */
    pointerLeaveListener(evt) {
        this.displayInfobox(false);
        this.dehighlightAll();
        return true;
    }
    /**
     * Touch-Events
     */
    /**
     * This method is called by the browser when a finger touches the surface of the touch-device.
     * @param {Event} evt The browsers event object.
     * @returns {Boolean} ...
     */
    touchStartListener(evt) {
        var i, j, k, pos, elements, obj, eps = Options.precision.touch, evtTouches = evt['touches'], found, targets, target, touchTargets;
        if (!this.hasTouchEnd) {
            Env.addEvent(this.document, 'touchend', this.touchEndListener, this);
            this.hasTouchEnd = true;
        }
        // Do not remove mouseHandlers, since Chrome on win tablets sends mouseevents if used with pen.
        //if (this.hasMouseHandlers) { this.removeMouseEventHandlers(); }
        // prevent accidental selection of text
        // TODO: document.selection isn't a thing (multiple places)
        // if (this.document.selection && Type.isFunction(this.document.selection.empty)) {
        //     this.document.selection.empty();
        // } else if (window.getSelection) {
        //     window.getSelection().removeAllRanges();
        // }
        // multitouch
        this._inputDevice = 'touch';
        Options.precision.hasPoint = Options.precision.touch;
        // This is the most critical part. first we should run through the existing touches and collect all targettouches that don't belong to our
        // previous touches. once this is done we run through the existing touches again and watch out for free touches that can be attached to our existing
        // touches, e.g. we translate (parallel translation) a line with one finger, now a second finger is over this line. this should change the operation to
        // a rotational translation. or one finger moves a circle, a second finger can be attached to the circle: this now changes the operation from translation to
        // stretching. as a last step we're going through the rest of the targettouches and initiate new move operations:
        //  * points have higher priority over other elements.
        //  * if we find a targettouch over an element that could be transformed with more than one finger, we search the rest of the targettouches, if they are over
        //    this element and add them.
        // ADDENDUM 11/10/11:
        //  (1) run through the touches control object,
        //  (2) try to find the targetTouches for every touch. on touchstart only new touches are added, hence we can find a targettouch
        //      for every target in our touches objects
        //  (3) if one of the targettouches was bound to a touches targets array, mark it
        //  (4) run through the targettouches. if the targettouch is marked, continue. otherwise check for elements below the targettouch:
        //      (a) if no element could be found: mark the target touches and continue
        //      --- in the following cases, 'init' means:
        //           (i) check if the element is already used in another touches element, if so, mark the targettouch and continue
        //          (ii) if not, init a new touches element, add the targettouch to the touches property and mark it
        //      (b) if the element is a point, init
        //      (c) if the element is a line, init and try to find a second targettouch on that line. if a second one is found, add and mark it
        //      (d) if the element is a circle, init and try to find TWO other targettouches on that circle. if only one is found, mark it and continue. otherwise
        //          add both to the touches array and mark them.
        for (i = 0; i < evtTouches.length; i++) {
            evtTouches[i].jxg_isused = false;
        }
        for (i = 0; i < this.touches.length; i++) {
            touchTargets = this.touches[i].targets;
            for (j = 0; j < touchTargets.length; j++) {
                touchTargets[j].num = -1;
                eps = Options.precision.touch;
                do {
                    for (k = 0; k < evtTouches.length; k++) {
                        // find the new targettouches
                        if (Math.abs(Math.pow(evtTouches[k].screenX - touchTargets[j].X, 2) +
                            Math.pow(evtTouches[k].screenY - touchTargets[j].Y, 2)) <
                            eps * eps) {
                            touchTargets[j].num = k;
                            touchTargets[j].X = evtTouches[k].screenX;
                            touchTargets[j].Y = evtTouches[k].screenY;
                            evtTouches[k].jxg_isused = true;
                            break;
                        }
                    }
                    eps *= 2;
                } while (touchTargets[j].num === -1 &&
                    eps < Options.precision.touchMax);
                if (touchTargets[j].num === -1) {
                    JXG.debug("i couldn't find a targettouches for target no " +
                        j +
                        ' on ' +
                        this.touches[i].obj.name +
                        ' (' +
                        this.touches[i].obj.id +
                        '). Removed the target.');
                    JXG.debug('eps = ' + eps + ', touchMax = ' + Options.precision.touchMax);
                    touchTargets.splice(i, 1);
                }
            }
        }
        // we just re-mapped the targettouches to our existing touches list.
        // now we have to initialize some touches from additional targettouches
        for (i = 0; i < evtTouches.length; i++) {
            if (!evtTouches[i].jxg_isused) {
                pos = this.getMousePosition(evt, i);
                // selection
                // this._testForSelection(evt); // we do not have shift or ctrl keys yet.
                if (this.selectingMode) {
                    this._startSelecting(pos);
                    this.triggerEventHandlers(['touchstartselecting', 'startselecting'], [evt]);
                    evt.preventDefault();
                    evt.stopPropagation();
                    Options.precision.hasPoint = Options.precision.mouse;
                    return this.touches.length > 0; // don't continue as a normal click
                }
                elements = this.initMoveObject(pos[0], pos[1], evt, 'touch');
                if (elements.length !== 0) {
                    obj = elements[elements.length - 1];
                    target = {
                        num: i,
                        X: evtTouches[i].screenX,
                        Y: evtTouches[i].screenY,
                        Xprev: NaN,
                        Yprev: NaN,
                        Xstart: [],
                        Ystart: [],
                        Zstart: []
                    };
                    if (Type.isPoint(obj) ||
                        obj.elementClass === OBJECT_CLASS.TEXT ||
                        obj.type === OBJECT_TYPE.TICKS ||
                        obj.type === OBJECT_TYPE.IMAGE) {
                        // It's a point, so it's single touch, so we just push it to our touches
                        targets = [target];
                        // For the UNDO/REDO of object moves
                        this.saveStartPos(obj, targets[0]);
                        this.touches.push({ obj: obj, targets: targets });
                        obj.highlight(true);
                    }
                    else if (obj.elementClass === OBJECT_CLASS.LINE ||
                        obj.elementClass === OBJECT_CLASS.CIRCLE ||
                        obj.elementClass === OBJECT_CLASS.CURVE ||
                        obj.type === OBJECT_TYPE.POLYGON) {
                        found = false;
                        // first check if this geometric object is already captured in this.touches
                        for (j = 0; j < this.touches.length; j++) {
                            if (obj.id === this.touches[j].obj.id) {
                                found = true;
                                // only add it, if we don't have two targets in there already
                                if (this.touches[j].targets.length === 1) {
                                    // For the UNDO/REDO of object moves
                                    this.saveStartPos(obj, target);
                                    this.touches[j].targets.push(target);
                                }
                                evtTouches[i].jxg_isused = true;
                            }
                        }
                        // we couldn't find it in touches, so we just init a new touches
                        // IF there is a second touch targetting this line, we will find it later on, and then add it to
                        // the touches control object.
                        if (!found) {
                            targets = [target];
                            // For the UNDO/REDO of object moves
                            this.saveStartPos(obj, targets[0]);
                            this.touches.push({ obj: obj, targets: targets });
                            obj.highlight(true);
                        }
                    }
                }
                evtTouches[i].jxg_isused = true;
            }
        }
        if (this.touches.length > 0) {
            evt.preventDefault();
            evt.stopPropagation();
        }
        // Touch events on empty areas of the board are handled here:
        // 1. case: one finger. If allowed, this triggers pan with one finger
        if (evtTouches.length === 1 &&
            this.mode === BOARD_MODE.NONE &&
            this.touchStartMoveOriginOneFinger(evt)) ;
        else if (evtTouches.length === 2 &&
            (this.mode === BOARD_MODE.NONE ||
                this.mode === BOARD_MODE.MOVE_ORIGIN)) {
            // 2. case: two fingers: pinch to zoom or pan with two fingers needed.
            // This happens when the second finger hits the device. First, the
            // 'one finger pan mode' has to be cancelled.
            if (this.mode === BOARD_MODE.MOVE_ORIGIN) {
                this.originMoveEnd();
            }
            this.gestureStartListener(evt);
        }
        Options.precision.hasPoint = Options.precision.mouse;
        this.triggerEventHandlers(['touchstart', 'down'], [evt]);
        return false;
        //return this.touches.length > 0;
    }
    /**
     * Called periodically by the browser while the user moves his fingers across the device.
     * @param {Event} evt
     * @returns {Boolean}
     */
    touchMoveListener(evt) {
        var i, pos1, pos2, touchTargets, evtTouches = evt['touches'];
        if (!this.checkFrameRate(evt)) {
            return false;
        }
        if (this.mode !== BOARD_MODE.NONE) {
            evt.preventDefault();
            evt.stopPropagation();
        }
        if (this.mode !== BOARD_MODE.DRAG) {
            this.dehighlightAll();
            this.displayInfobox(false);
        }
        this._inputDevice = 'touch';
        Options.precision.hasPoint = Options.precision.touch;
        this.updateQuality = BOARD_QUALITY.HIGHLOW;
        // selection
        if (this.selectingMode) {
            for (i = 0; i < evtTouches.length; i++) {
                if (!evtTouches[i].jxg_isused) {
                    pos1 = this.getMousePosition(evt, i);
                    this._moveSelecting(pos1);
                    this.triggerEventHandlers(['touchmoves', 'moveselecting'], [evt, this.mode]);
                    break;
                }
            }
        }
        else {
            if (!this.touchOriginMove(evt)) {
                if (this.mode === BOARD_MODE.DRAG) {
                    // Runs over through all elements which are touched
                    // by at least one finger.
                    for (i = 0; i < this.touches.length; i++) {
                        touchTargets = this.touches[i].targets;
                        if (touchTargets.length === 1) {
                            // Touch by one finger:  this is possible for all elements that can be dragged
                            if (evtTouches[touchTargets[0].num]) {
                                pos1 = this.getMousePosition(evt, touchTargets[0].num);
                                if (pos1[0] < 0 ||
                                    pos1[0] > this.canvasWidth ||
                                    pos1[1] < 0 ||
                                    pos1[1] > this.canvasHeight) {
                                    return;
                                }
                                touchTargets[0].X = pos1[0];
                                touchTargets[0].Y = pos1[1];
                                this.moveObject(pos1[0], pos1[1], this.touches[i], evt, 'touch');
                            }
                        }
                        else if (touchTargets.length === 2 &&
                            touchTargets[0].num > -1 &&
                            touchTargets[1].num > -1) {
                            // Touch by two fingers: moving lines, ...
                            if (evtTouches[touchTargets[0].num] &&
                                evtTouches[touchTargets[1].num]) {
                                // Get coordinates of the two touches
                                pos1 = this.getMousePosition(evt, touchTargets[0].num);
                                pos2 = this.getMousePosition(evt, touchTargets[1].num);
                                if (pos1[0] < 0 ||
                                    pos1[0] > this.canvasWidth ||
                                    pos1[1] < 0 ||
                                    pos1[1] > this.canvasHeight ||
                                    pos2[0] < 0 ||
                                    pos2[0] > this.canvasWidth ||
                                    pos2[1] < 0 ||
                                    pos2[1] > this.canvasHeight) {
                                    return;
                                }
                                touchTargets[0].X = pos1[0];
                                touchTargets[0].Y = pos1[1];
                                touchTargets[1].X = pos2[0];
                                touchTargets[1].Y = pos2[1];
                                this.twoFingerMove(this.touches[i], touchTargets[0].num, evt);
                                touchTargets[0].Xprev = pos1[0];
                                touchTargets[0].Yprev = pos1[1];
                                touchTargets[1].Xprev = pos2[0];
                                touchTargets[1].Yprev = pos2[1];
                            }
                        }
                    }
                }
                else {
                    if (evtTouches.length === 2) {
                        this.gestureChangeListener(evt);
                    }
                    // Move event without dragging an element
                    pos1 = this.getMousePosition(evt, 0);
                    this.highlightElements(pos1[0], pos1[1], evt, -1);
                }
            }
        }
        if (this.mode !== BOARD_MODE.DRAG) {
            this.displayInfobox(false);
        }
        this.triggerEventHandlers(['touchmove', 'move'], [evt, this.mode]);
        Options.precision.hasPoint = Options.precision.mouse;
        this.updateQuality = BOARD_QUALITY.HIGH;
        return this.mode === BOARD_MODE.NONE;
    }
    /**
     * Triggered as soon as the user stops touching the device with at least one finger.
     * @param {Event} evt
     * @returns {Boolean}
     */
    touchEndListener(evt) {
        var i, j, k, eps = Options.precision.touch, tmpTouches = [], found, foundNumber, evtTouches = evt && evt['touches'], touchTargets, updateNeeded = false;
        this.triggerEventHandlers(['touchend', 'up'], [evt]);
        this.displayInfobox(false);
        // selection
        if (this.selectingMode) {
            this._stopSelecting(evt);
            this.triggerEventHandlers(['touchstopselecting', 'stopselecting'], [evt]);
            this.stopSelectionMode();
        }
        else if (evtTouches && evtTouches.length > 0) {
            for (i = 0; i < this.touches.length; i++) {
                tmpTouches[i] = this.touches[i];
            }
            this.touches.length = 0;
            // try to convert the operation, e.g. if a lines is rotated and translated with two fingers and one finger is lifted,
            // convert the operation to a simple one-finger-translation.
            // ADDENDUM 11/10/11:
            // see addendum to touchStartListener from 11/10/11
            // (1) run through the tmptouches
            // (2) check the touches.obj, if it is a
            //     (a) point, try to find the targettouch, if found keep it and mark the targettouch, else drop the touch.
            //     (b) line with
            //          (i) one target: try to find it, if found keep it mark the targettouch, else drop the touch.
            //         (ii) two targets: if none can be found, drop the touch. if one can be found, remove the other target. mark all found targettouches
            //     (c) circle with [proceed like in line]
            // init the targettouches marker
            for (i = 0; i < evtTouches.length; i++) {
                evtTouches[i].jxg_isused = false;
            }
            for (i = 0; i < tmpTouches.length; i++) {
                // could all targets of the current this.touches.obj be assigned to targettouches?
                found = false;
                foundNumber = 0;
                touchTargets = tmpTouches[i].targets;
                for (j = 0; j < touchTargets.length; j++) {
                    touchTargets[j].found = false;
                    for (k = 0; k < evtTouches.length; k++) {
                        if (Math.abs(Math.pow(evtTouches[k].screenX - touchTargets[j].X, 2) +
                            Math.pow(evtTouches[k].screenY - touchTargets[j].Y, 2)) <
                            eps * eps) {
                            touchTargets[j].found = true;
                            touchTargets[j].num = k;
                            touchTargets[j].X = evtTouches[k].screenX;
                            touchTargets[j].Y = evtTouches[k].screenY;
                            foundNumber += 1;
                            break;
                        }
                    }
                }
                if (Type.isPoint(tmpTouches[i].obj)) {
                    found = touchTargets[0] && touchTargets[0].found;
                }
                else if (tmpTouches[i].obj.elementClass === OBJECT_CLASS.LINE) {
                    found =
                        (touchTargets[0] && touchTargets[0].found) ||
                            (touchTargets[1] && touchTargets[1].found);
                }
                else if (tmpTouches[i].obj.elementClass === OBJECT_CLASS.CIRCLE) {
                    found = foundNumber === 1 || foundNumber === 3;
                }
                // if we found this object to be still dragged by the user, add it back to this.touches
                if (found) {
                    this.touches.push({
                        obj: tmpTouches[i].obj,
                        targets: []
                    });
                    for (j = 0; j < touchTargets.length; j++) {
                        if (touchTargets[j].found) {
                            this.touches[this.touches.length - 1].targets.push({
                                num: touchTargets[j].num,
                                X: touchTargets[j].screenX,
                                Y: touchTargets[j].screenY,
                                Xprev: NaN,
                                Yprev: NaN,
                                Xstart: touchTargets[j].Xstart,
                                Ystart: touchTargets[j].Ystart,
                                Zstart: touchTargets[j].Zstart
                            });
                        }
                    }
                }
                else {
                    tmpTouches[i].obj.noHighlight();
                }
            }
        }
        else {
            this.touches.length = 0;
        }
        for (i = this.downObjects.length - 1; i > -1; i--) {
            found = false;
            for (j = 0; j < this.touches.length; j++) {
                if (this.touches[j].obj.id === this.downObjects[i].id) {
                    found = true;
                }
            }
            if (!found) {
                this.downObjects[i].triggerEventHandlers(['touchup', 'up'], [evt]);
                if (!Type.exists(this.downObjects[i].coords)) {
                    // snapTo methods have to be called e.g. for line elements here.
                    // For coordsElements there might be a conflict with
                    // attractors, see commit from 2022.04.08, 11:12:18.
                    this.downObjects[i].snapToGrid();
                    this.downObjects[i].snapToPoints();
                    updateNeeded = true;
                }
                this.downObjects.splice(i, 1);
            }
        }
        if (!evtTouches || evtTouches.length === 0) {
            if (this.hasTouchEnd) {
                Env.removeEvent(this.document, 'touchend', this.touchEndListener, this);
                this.hasTouchEnd = false;
            }
            this.dehighlightAll();
            this.updateQuality = BOARD_QUALITY.HIGH;
            this.originMoveEnd();
            if (updateNeeded) {
                this.update();
            }
        }
        return true;
    }
    /**
     * This method is called by the browser when the mouse button is clicked.
     * @param {Event} evt The browsers event object.
     * @returns {Boolean} True if no element is found under the current mouse pointer, false otherwise.
     */
    mouseDownListener(evt) {
        var pos, elements, result;
        // TODO: document.selection isn't a thing
        // // prevent accidental selection of text
        // if (this.document.selection && Type.isFunction(this.document.selection.empty)) {
        //     this.document.selection.empty();
        // } else if (window.getSelection) {
        //     window.getSelection().removeAllRanges();
        // }
        if (!this.hasMouseUp) {
            Env.addEvent(this.document, 'mouseup', this.mouseUpListener, this);
            this.hasMouseUp = true;
        }
        else {
            // In case this.hasMouseUp==true, it may be that there was a
            // mousedown event before which was not followed by an mouseup event.
            // This seems to happen with interactive whiteboard pens sometimes.
            return;
        }
        this._inputDevice = 'mouse';
        Options.precision.hasPoint = Options.precision.mouse;
        pos = this.getMousePosition(evt);
        // selection
        this._testForSelection(evt);
        if (this.selectingMode) {
            this._startSelecting(pos);
            this.triggerEventHandlers(['mousestartselecting', 'startselecting'], [evt]);
            return; // don't continue as a normal click
        }
        elements = this.initMoveObject(pos[0], pos[1], evt, 'mouse');
        // if no draggable object can be found, get out here immediately
        if (elements.length === 0) {
            this.mode = BOARD_MODE.NONE;
            result = true;
        }
        else {
            this.mouse = {
                obj: null,
                targets: [
                    {
                        X: pos[0],
                        Y: pos[1],
                        Xprev: NaN,
                        Yprev: NaN
                    }
                ]
            };
            this.mouse.obj = elements[elements.length - 1];
            this.dehighlightAll();
            this.mouse.obj.highlight(true);
            this.mouse.targets[0].Xstart = [];
            this.mouse.targets[0].Ystart = [];
            this.mouse.targets[0].Zstart = [];
            this.saveStartPos(this.mouse.obj, this.mouse.targets[0]);
            // prevent accidental text selection
            // this could get us new trouble: input fields, links and drop down boxes placed as text
            // on the board don't work anymore.
            if (evt && evt.preventDefault) {
                evt.preventDefault();
            }
            else if (window.event) {
                window.event.returnValue = false;
            }
        }
        if (this.mode === BOARD_MODE.NONE) {
            result = this.mouseOriginMoveStart(evt);
        }
        this.triggerEventHandlers(['mousedown', 'down'], [evt]);
        return result;
    }
    /**
     * This method is called by the browser when the mouse is moved.
     * @param {Event} evt The browsers event object.
     */
    mouseMoveListener(evt) {
        var pos;
        if (!this.checkFrameRate(evt)) {
            return false;
        }
        pos = this.getMousePosition(evt);
        this.updateQuality = BOARD_QUALITY.HIGHLOW;
        if (this.mode !== BOARD_MODE.DRAG) {
            this.dehighlightAll();
            this.displayInfobox(false);
        }
        // we have to check for four cases:
        //   * user moves origin
        //   * user drags an object
        //   * user just moves the mouse, here highlight all elements at
        //     the current mouse position
        //   * the user is selecting
        // selection
        if (this.selectingMode) {
            this._moveSelecting(pos);
            this.triggerEventHandlers(['mousemoveselecting', 'moveselecting'], [evt, this.mode]);
        }
        else if (!this.mouseOriginMove(evt)) {
            if (this.mode === BOARD_MODE.DRAG) {
                this.moveObject(pos[0], pos[1], this.mouse, evt, 'mouse');
            }
            else {
                // BOARD_MODE_NONE
                // Move event without dragging an element
                this.highlightElements(pos[0], pos[1], evt, -1);
            }
            this.triggerEventHandlers(['mousemove', 'move'], [evt, this.mode]);
        }
        this.updateQuality = BOARD_QUALITY.HIGH;
    }
    /**
     * This method is called by the browser when the mouse button is released.
     * @param {Event} evt
     */
    mouseUpListener(evt) {
        var i;
        if (this.selectingMode === false) {
            this.triggerEventHandlers(['mouseup', 'up'], [evt]);
        }
        // redraw with high precision
        this.updateQuality = BOARD_QUALITY.HIGH;
        if (this.mouse && this.mouse.obj) {
            if (!Type.exists(this.mouse.obj.coords)) {
                // snapTo methods have to be called e.g. for line elements here.
                // For coordsElements there might be a conflict with
                // attractors, see commit from 2022.04.08, 11:12:18.
                // The parameter is needed for lines with snapToGrid enabled
                this.mouse.obj.snapToGrid(this.mouse.targets[0]);
                this.mouse.obj.snapToPoints();
            }
        }
        this.originMoveEnd();
        this.dehighlightAll();
        this.update();
        // selection
        if (this.selectingMode) {
            this._stopSelecting(evt);
            this.triggerEventHandlers(['mousestopselecting', 'stopselecting'], [evt]);
            this.stopSelectionMode();
        }
        else {
            for (i = 0; i < this.downObjects.length; i++) {
                this.downObjects[i].triggerEventHandlers(['mouseup', 'up'], [evt]);
            }
        }
        this.downObjects.length = 0;
        if (this.hasMouseUp) {
            Env.removeEvent(this.document, 'mouseup', this.mouseUpListener, this);
            this.hasMouseUp = false;
        }
        // release dragged mouse object
        this.mouse = null;
    }
    /**
     * Handler for mouse wheel events. Used to zoom in and out of the board.
     * @param {Event} evt
     * @returns {Boolean}
     */
    mouseWheelListener(evt) {
        var wd, zoomCenter, pos;
        if (!this.attr.zoom.enabled ||
            !this.attr.zoom.wheel ||
            !this._isRequiredKeyPressed(evt, 'zoom')) {
            return true;
        }
        evt = evt || window.event;
        wd = evt.detail ? -evt.detail : evt.wheelDelta / 40;
        zoomCenter = this.attr.zoom.center;
        if (zoomCenter === 'board') {
            pos = [];
        }
        else { // including zoomCenter === 'auto'
            pos = new Coords$1(COORDS_BY.SCREEN, this.getMousePosition(evt), this).usrCoords;
        }
        // pos == [] does not throw an error
        if (wd > 0) {
            this.zoomIn(pos[1], pos[2]);
        }
        else {
            this.zoomOut(pos[1], pos[2]);
        }
        this.triggerEventHandlers(['mousewheel'], [evt]);
        evt.preventDefault();
        return false;
    }
    /**
     * Allow moving of JSXGraph elements with arrow keys.
     * The selection of the element is done with the tab key. For this,
     * the attribute 'tabindex' of the element has to be set to some number (default=0).
     * tabindex corresponds to the HTML and SVG attribute of the same name.
     * <p>
     * Panning of the construction is done with arrow keys
     * if the pan key (shift or ctrl - depending on the board attributes) is pressed.
     * <p>
     * Zooming is triggered with the keys +, o, -, if
     * the pan key (shift or ctrl - depending on the board attributes) is pressed.
     * <p>
     * Keyboard control (move, pan, and zoom) is disabled if an HTML element of type input or textarea has received focus.
     *
     * @param  {Event} evt The browser's event object
     *
     * @see JXG.Board#keyboard
     * @see JXG.Board#keyFocusInListener
     * @see JXG.Board#keyFocusOutListener
     *
     */
    keyDownListener(evt) {
        var id_node = evt.target.id, id, el, res, doc, sX = 0, sY = 0, 
        // dx, dy are provided in screen units and
        // are converted to user coordinates
        dx = Type.evaluate(this.attr.keyboard.dx) / this.unitX, dy = Type.evaluate(this.attr.keyboard.dy) / this.unitY, 
        // u = 100,
        doZoom = false, done = true, dir, actPos;
        if (!this.attr.keyboard.enabled || id_node === '') {
            return false;
        }
        // dx = Math.round(dx * u) / u;
        // dy = Math.round(dy * u) / u;
        // An element of type input or textarea has focus, get out of here.
        doc = this.containerObj.shadowRoot || document;
        if (doc.activeElement) {
            el = doc.activeElement;
            if (el.tagName === 'INPUT' || el.tagName === 'textarea') {
                return false;
            }
        }
        // Get the JSXGraph id from the id of the SVG node.
        id = id_node.replace(this.containerObj.id + '_', '');
        el = this.select(id);
        if (Type.exists(el.coords)) {
            actPos = el.coords.usrCoords.slice(1);
        }
        if ((Type.evaluate(this.attr.keyboard.panshift) && evt.shiftKey) ||
            (Type.evaluate(this.attr.keyboard.panctrl) && evt.ctrlKey)) {
            // Pan key has been pressed
            if (Type.evaluate(this.attr.zoom.enabled) === true) {
                doZoom = true;
            }
            // Arrow keys
            if (evt.keyCode === 38) {
                // up
                this.clickUpArrow();
            }
            else if (evt.keyCode === 40) {
                // down
                this.clickDownArrow();
            }
            else if (evt.keyCode === 37) {
                // left
                this.clickLeftArrow();
            }
            else if (evt.keyCode === 39) {
                // right
                this.clickRightArrow();
                // Zoom keys
            }
            else if (doZoom && evt.keyCode === 171) {
                // +
                this.zoomIn();
            }
            else if (doZoom && evt.keyCode === 173) {
                // -
                this.zoomOut();
            }
            else if (doZoom && evt.keyCode === 79) {
                // o
                this.zoom100();
            }
            else {
                done = false;
            }
        }
        else if (!evt.shiftKey && !evt.ctrlKey) { // Move an element if neither shift or ctrl are pressed
            // Adapt dx, dy to snapToGrid and attractToGrid.
            // snapToGrid has priority.
            if (Type.exists(el.visProp)) {
                if (Type.exists(el.visProp.snaptogrid) &&
                    el.visProp.snaptogrid &&
                    el.evalVisProp('snapsizex') &&
                    el.evalVisProp('snapsizey')) {
                    // Adapt dx, dy such that snapToGrid is possible
                    res = el.getSnapSizes();
                    sX = res[0];
                    sY = res[1];
                    // If snaptogrid is true,
                    // we can only jump from grid point to grid point.
                    dx = sX;
                    dy = sY;
                }
                else if (Type.exists(el.visProp.attracttogrid) &&
                    el.visProp.attracttogrid &&
                    el.evalVisProp('attractordistance') &&
                    el.evalVisProp('attractorunit')) {
                    // Adapt dx, dy such that attractToGrid is possible
                    sX = 1.1 * el.evalVisProp('attractordistance');
                    sY = sX;
                    if (el.evalVisProp('attractorunit') === 'screen') {
                        sX /= this.unitX;
                        sY /= this.unitX;
                    }
                    dx = Math.max(sX, dx);
                    dy = Math.max(sY, dy);
                }
            }
            if (evt.keyCode === 38) {
                // up
                dir = [0, dy];
            }
            else if (evt.keyCode === 40) {
                // down
                dir = [0, -dy];
            }
            else if (evt.keyCode === 37) {
                // left
                dir = [-dx, 0];
            }
            else if (evt.keyCode === 39) {
                // right
                dir = [dx, 0];
            }
            else {
                done = false;
            }
            if (dir && el.isDraggable &&
                el.visPropCalc.visible &&
                ((this.geonextCompatibilityMode &&
                    (Type.isPoint(el) ||
                        el.elementClass === OBJECT_CLASS.TEXT)) || !this.geonextCompatibilityMode) &&
                !el.evalVisProp('fixed')) {
                this.mode = BOARD_MODE.DRAG;
                if (Type.exists(el.coords)) {
                    dir[0] += actPos[0];
                    dir[1] += actPos[1];
                }
                // For coordsElement setPosition has to call setPositionDirectly.
                // Otherwise the position is set by a translation.
                if (Type.exists(el.coords)) {
                    el.setPosition(COORDS_BY.USER, dir);
                    this.updateInfobox(el);
                }
                else {
                    this.displayInfobox(false);
                    el.setPositionDirectly(COORDS_BY.USER, dir, [0, 0]);
                }
                this.triggerEventHandlers(['keymove', 'move'], [evt, this.mode]);
                el.triggerEventHandlers(['keydrag', 'drag'], [evt]);
                this.mode = BOARD_MODE.NONE;
            }
        }
        this.update();
        if (done && Type.exists(evt.preventDefault)) {
            evt.preventDefault();
        }
        return done;
    }
    /**
     * Event listener for SVG elements getting focus.
     * This is needed for highlighting when using keyboard control.
     * Only elements having the attribute 'tabindex' can receive focus.
     *
     * @see JXG.Board#keyFocusOutListener
     * @see JXG.Board#keyDownListener
     * @see JXG.Board#keyboard
     *
     * @param  {Event} evt The browser's event object
     */
    keyFocusInListener(evt) {
        var id_node = evt.target.id, id, el;
        if (!this.attr.keyboard.enabled || id_node === '') {
            return false;
        }
        // Get JSXGraph id from node id
        id = id_node.replace(this.containerObj.id + '_', '');
        el = this.select(id);
        if (Type.exists(el.highlight)) {
            el.highlight(true);
            this.focusObjects = [id];
            el.triggerEventHandlers(['hit'], [evt]);
        }
        if (Type.exists(el.coords)) {
            this.updateInfobox(el);
        }
    }
    /**
     * Event listener for SVG elements losing focus.
     * This is needed for dehighlighting when using keyboard control.
     * Only elements having the attribute 'tabindex' can receive focus.
     *
     * @see JXG.Board#keyFocusInListener
     * @see JXG.Board#keyDownListener
     * @see JXG.Board#keyboard
     *
     * @param  {Event} evt The browser's event object
     */
    keyFocusOutListener(evt) {
        if (!this.attr.keyboard.enabled) {
            return false;
        }
        this.focusObjects = []; // This has to be before displayInfobox(false)
        this.dehighlightAll();
        this.displayInfobox(false);
    }
    /**
     * Update the width and height of the JSXGraph container div element.
     * If width and height are not supplied, read actual values with offsetWidth/Height,
     * and call board.resizeContainer() with this values.
     * <p>
     * If necessary, also call setBoundingBox().
     * @param {Number} [width=this.containerObj.offsetWidth] Width of the container element
     * @param {Number} [height=this.containerObj.offsetHeight] Height of the container element
     * @returns {JXG.Board} Reference to the board
     *
     * @see JXG.Board#startResizeObserver
     * @see JXG.Board#resizeListener
     * @see JXG.Board#resizeContainer
     * @see JXG.Board#setBoundingBox
     *
     */
    updateContainerDims(width, height) {
        var w = width, h = height, 
        // bb,
        css, width_adjustment, height_adjustment;
        if (width === undefined) {
            // Get size of the board's container div
            //
            // offsetWidth/Height ignores CSS transforms,
            // getBoundingClientRect includes CSS transforms
            //
            // bb = this.containerObj.getBoundingClientRect();
            // w = bb.width;
            // h = bb.height;
            w = this.containerObj.offsetWidth;
            h = this.containerObj.offsetHeight;
        }
        if (width === undefined && window && window.getComputedStyle) {
            // Subtract the border size
            css = window.getComputedStyle(this.containerObj, null);
            width_adjustment = parseFloat(css.getPropertyValue('border-left-width')) + parseFloat(css.getPropertyValue('border-right-width'));
            if (!isNaN(width_adjustment)) {
                w -= width_adjustment;
            }
            height_adjustment = parseFloat(css.getPropertyValue('border-top-width')) + parseFloat(css.getPropertyValue('border-bottom-width'));
            if (!isNaN(height_adjustment)) {
                h -= height_adjustment;
            }
        }
        // If div is invisible - do nothing
        if (w <= 0 || h <= 0 || isNaN(w) || isNaN(h)) {
            return this;
        }
        // If bounding box is not yet initialized, do it now.
        if (isNaN(this.getBoundingBox()[0])) {
            this.setBoundingBox(this.attr.boundingbox, this.keepaspectratio, 'keep');
        }
        // Do nothing if the dimension did not change since being visible
        // the last time. Note that if the div had display:none in the mean time,
        // we did not store this._prevDim.
        if (Type.exists(this._prevDim) && this._prevDim.w === w && this._prevDim.h === h) {
            return this;
        }
        // Set the size of the SVG or canvas element
        this.resizeContainer(w, h, true);
        this._prevDim = {
            w: w,
            h: h
        };
        return this;
    }
    /**
     * Start observer which reacts to size changes of the JSXGraph
     * container div element. Calls updateContainerDims().
     * If not available, an event listener for the window-resize event is started.
     * On mobile devices also scrolling might trigger resizes.
     * However, resize events triggered by scrolling events should be ignored.
     * Therefore, also a scrollListener is started.
     * Resize can be controlled with the board attribute resize.
     *
     * @see JXG.Board#updateContainerDims
     * @see JXG.Board#resizeListener
     * @see JXG.Board#scrollListener
     * @see JXG.Board#resize
     *
     */
    startResizeObserver() {
        var that = this;
        if (!Env.isBrowser || !this.attr.resize || !this.attr.resize.enabled) {
            return;
        }
        this.resizeObserver = new ResizeObserver(function (entries) {
            var bb;
            if (!that._isResizing) {
                that._isResizing = true;
                bb = entries[0].contentRect;
                window.setTimeout(function () {
                    try {
                        that.updateContainerDims(bb.width, bb.height);
                    }
                    catch (e) {
                        JXG.debug(e); // Used to log errors during board.update()
                        that.stopResizeObserver();
                    }
                    finally {
                        that._isResizing = false;
                    }
                }, that.attr.resize.throttle);
            }
        });
        this.resizeObserver.observe(this.containerObj);
    }
    /**
     * Stops the resize observer.
     * @see JXG.Board#startResizeObserver
     *
     */
    stopResizeObserver() {
        if (!Env.isBrowser || !this.attr.resize || !this.attr.resize.enabled) {
            return;
        }
        if (Type.exists(this.resizeObserver)) {
            this.resizeObserver.unobserve(this.containerObj);
        }
    }
    /**
     * Fallback solutions if there is no resizeObserver available in the browser.
     * Reacts to resize events of the window (only). Otherwise similar to
     * startResizeObserver(). To handle changes of the visibility
     * of the JSXGraph container element, additionally an intersection observer is used.
     * which watches changes in the visibility of the JSXGraph container element.
     * This is necessary e.g. for register tabs or dia shows.
     *
     * @see JXG.Board#startResizeObserver
     * @see JXG.Board#startIntersectionObserver
     */
    resizeListener() {
        var that = this;
        if (!Env.isBrowser || !this.attr.resize || !this.attr.resize.enabled) {
            return;
        }
        if (!this._isScrolling && !this._isResizing) {
            this._isResizing = true;
            window.setTimeout(function () {
                that.updateContainerDims();
                that._isResizing = false;
            }, this.attr.resize.throttle);
        }
    }
    /**
     * Listener to watch for scroll events. Sets board._isScrolling = true
     * @param  {Event} evt The browser's event object
     *
     * @see JXG.Board#startResizeObserver
     * @see JXG.Board#resizeListener
     *
     */
    scrollListener(evt) {
        var that = this;
        if (!Env.isBrowser) {
            return;
        }
        if (!this._isScrolling) {
            this._isScrolling = true;
            window.setTimeout(function () {
                that._isScrolling = false;
            }, 66);
        }
    }
    /**
     * Watch for changes of the visibility of the JSXGraph container element.
     *
     * @see JXG.Board#startResizeObserver
     * @see JXG.Board#resizeListener
     *
     */
    startIntersectionObserver() {
        var that = this, options = {
            root: null,
            rootMargin: '0px',
            threshold: 0.8
        };
        try {
            this.intersectionObserver = new IntersectionObserver(function (entries) {
                // If bounding box is not yet initialized, do it now.
                if (isNaN(that.getBoundingBox()[0])) {
                    that.updateContainerDims();
                }
            }, options);
            this.intersectionObserver.observe(that.containerObj);
        }
        catch (err) {
            JXG.debug('JSXGraph: IntersectionObserver not available in this browser.');
        }
    }
    /**
     * Stop the intersection observer
     *
     * @see JXG.Board#startIntersectionObserver
     *
     */
    stopIntersectionObserver() {
        if (Type.exists(this.intersectionObserver)) {
            this.intersectionObserver.unobserve(this.containerObj);
        }
    }
    /**
     * Update the container before and after printing.
     * @param {Event} [evt]
     */
    printListener(evt) {
        this.updateContainerDims();
    }
    /**
     * Wrapper for printListener to be used in mediaQuery matches.
     * @param {MediaQueryList} mql
     */
    printListenerMatch(mql) {
        console.warn('printListenerMatch - ???');
        // if (mql.matches) {
        //     this.printListener();
        // }
    }
    /**********************************************************
     *
     * End of Event Handlers
     *
     **********************************************************/
    /**
     * Initialize the info box object which is used to display
     * the coordinates of points near the mouse pointer,
     * @returns {JXG.Board} Reference to the board
     */
    initInfobox(attributes) {
        var attr = Type.copyAttributes(attributes, this.options, 'infobox');
        attr.id = this.id + '_infobox';
        /**
         * Infobox close to points in which the points' coordinates are displayed.
         * This is simply a JXG.Text element. Access through board.infobox.
         * Uses CSS class .JXGinfobox.
         *
         * @namespace
         * @name JXG.Board.infobox
         * @type JXG.Text
         *
         * @example
         * const board = JXG.JSXGraph.initBoard(BOARDID, {
         *     boundingbox: [-0.5, 0.5, 0.5, -0.5],
         *     intl: {
         *         enabled: false,
         *         locale: 'de-DE'
         *     }
         *     keepaspectratio: true,
         *     axis: true,
         *     infobox: {
         *         distanceY: 40,
         *         intl: {
         *             enabled: true,
         *             options: {
         *                 minimumFractionDigits: 1,
         *                 maximumFractionDigits: 2
         *             }
         *         }
         *     }
         * });
         * var p = board.create('point', [0.1, 0.1], {});
         *
         * </pre><div id="JXG822161af-fe77-4769-850f-cdf69935eab0" class="jxgbox" style="width: 300px; height: 300px;"></div>
         * <script type="text/javascript">
         *     (function() {
         *     const board = JXG.JSXGraph.initBoard('JXG822161af-fe77-4769-850f-cdf69935eab0', {
         *         boundingbox: [-0.5, 0.5, 0.5, -0.5], showcopyright: false, shownavigation: false,
         *         intl: {
         *             enabled: false,
         *             locale: 'de-DE'
         *         }
         *         keepaspectratio: true,
         *         axis: true,
         *         infobox: {
         *             distanceY: 40,
         *             intl: {
         *                 enabled: true,
         *                 options: {
         *                     minimumFractionDigits: 1,
         *                     maximumFractionDigits: 2
         *                 }
         *             }
         *         }
         *     });
         *     var p = board.create('point', [0.1, 0.1], {});
         *     })();
         *
         * </script><pre>
         *
         */
        this.infobox = this.create('text', [0, 0, '0,0'], attr);
        // this.infobox.needsUpdateSize = false;  // That is not true, but it speeds drawing up.
        this.infobox.dump = false;
        this.displayInfobox(false);
        return this;
    }
    /**
     * Updates and displays a little info box to show coordinates of current selected points.
     * @param {JXG.GeometryElement} el A GeometryElement
     * @returns {JXG.Board} Reference to the board
     * @see JXG.Board#displayInfobox
     * @see JXG.Board#showInfobox
     * @see Point#showInfobox
     *
     */
    updateInfobox(el) {
        var x, y, xc, yc, vpinfoboxdigits, distX, distY, vpsi = el.evalVisProp('showinfobox');
        if ((!Type.evaluate(this.attr.showinfobox) && vpsi === 'inherit') || !vpsi) {
            return this;
        }
        if (Type.isPoint(el)) {
            xc = el.coords.usrCoords[1];
            yc = el.coords.usrCoords[2];
            distX = this.infobox.evalVisProp('distancex');
            distY = this.infobox.evalVisProp('distancey');
            this.infobox.setCoords(xc + distX / this.unitX, yc + distY / this.unitY);
            vpinfoboxdigits = el.evalVisProp('infoboxdigits');
            if (typeof el.infoboxText !== 'string') {
                if (vpinfoboxdigits === 'auto') {
                    if (this.infobox.useLocale()) {
                        x = this.infobox.formatNumberLocale(xc);
                        y = this.infobox.formatNumberLocale(yc);
                    }
                    else {
                        x = Type.autoDigits(xc);
                        y = Type.autoDigits(yc);
                    }
                }
                else if (Type.isNumber(vpinfoboxdigits)) {
                    if (this.infobox.useLocale()) {
                        x = this.infobox.formatNumberLocale(xc, vpinfoboxdigits);
                        y = this.infobox.formatNumberLocale(yc, vpinfoboxdigits);
                    }
                    else {
                        x = Type.toFixed(xc, vpinfoboxdigits);
                        y = Type.toFixed(yc, vpinfoboxdigits);
                    }
                }
                else {
                    x = xc;
                    y = yc;
                }
                this.highlightInfobox(x, y, el);
            }
            else {
                this.highlightCustomInfobox(el.infoboxText, el);
            }
            this.displayInfobox(true);
        }
        return this;
    }
    /**
     * Set infobox visible / invisible.
     *
     * It uses its property hiddenByParent to memorize its status.
     * In this way, many DOM access can be avoided.
     *
     * @param  {Boolean} val true for visible, false for invisible
     * @returns {JXG.Board} Reference to the board.
     * @see JXG.Board#updateInfobox
     *
     */
    displayInfobox(val) {
        if (!val && this.focusObjects.length > 0 &&
            this.select(this.focusObjects[0]).elementClass === OBJECT_CLASS.POINT) {
            // If an element has focus we do not hide its infobox
            return this;
        }
        if (this.infobox.hiddenByParent === val) {
            this.infobox.hiddenByParent = !val;
            this.infobox.prepareUpdate().updateVisibility(val).updateRenderer();
        }
        return this;
    }
    // Alias for displayInfobox to be backwards compatible.
    // The method showInfobox clashes with the board attribute showInfobox
    showInfobox(val) {
        return this.displayInfobox(val);
    }
    /**
     * Changes the text of the info box to show the given coordinates.
     * @param {Number} x
     * @param {Number} y
     * @param {JXG.GeometryElement} [el] The element the mouse is pointing at
     * @returns {JXG.Board} Reference to the board.
     */
    highlightInfobox(x, y, el) {
        this.highlightCustomInfobox('(' + x + ', ' + y + ')', el);
        return this;
    }
    /**
     * Changes the text of the info box to what is provided via text.
     * @param {String} text
     * @param {JXG.GeometryElement} [el]
     * @returns {JXG.Board} Reference to the board.
     */
    highlightCustomInfobox(text, el) {
        this.infobox.setText(text);
        return this;
    }
    /**
     * Remove highlighting of all elements.
     * @returns {JXG.Board} Reference to the board.
     */
    dehighlightAll() {
        var el, pEl, stillHighlighted = {}, needsDeHighlight = false;
        for (el in this.highlightedObjects) {
            if (this.highlightedObjects.hasOwnProperty(el)) {
                pEl = this.highlightedObjects[el];
                if (this.focusObjects.indexOf(el) < 0) { // Element does not have focus
                    if (this.hasMouseHandlers || this.hasPointerHandlers) {
                        pEl.noHighlight();
                    }
                    needsDeHighlight = true;
                }
                else {
                    stillHighlighted[el] = pEl;
                }
                // In highlightedObjects should only be objects which fulfill all these conditions
                // And in case of complex elements, like a turtle based fractal, it should be faster to
                // just de-highlight the element instead of checking hasPoint...
                // if ((!Type.exists(pEl.hasPoint)) || !pEl.hasPoint(x, y) || !pEl.visPropCalc.visible)
            }
        }
        this.highlightedObjects = stillHighlighted;
        // We do not need to redraw during dehighlighting in CanvasRenderer
        // because we are redrawing anyhow
        //  -- We do need to redraw during dehighlighting. Otherwise objects won't be dehighlighted until
        // another object is highlighted.
        if (this.renderer.type === 'canvas' && needsDeHighlight) {
            this.prepareUpdate(true);
            this.renderer.suspendRedraw();
            this.updateRenderer();
            this.renderer.unsuspendRedraw();
        }
        return this;
    }
    /**
     * Returns the input parameters in an array. This method looks pointless and it really is, but it had a purpose
     * once.
     * @private
     * @param {Number} x X coordinate in screen coordinates
     * @param {Number} y Y coordinate in screen coordinates
     * @returns {Array} Coordinates [x, y] of the mouse in screen coordinates.
     * @see JXG.Board#getUsrCoordsOfMouse
     */
    getScrCoordsOfMouse(x, y) {
        return [x, y];
    }
    /**
     * This method calculates the user coords of the current mouse coordinates.
     * @param {Event} evt Event object containing the mouse coordinates.
     * @returns {Array} Coordinates [x, y] of the mouse in user coordinates.
     * @example
     * board.on('up', function (evt) {
     *         var a = board.getUsrCoordsOfMouse(evt),
     *             x = a[0],
     *             y = a[1],
     *             somePoint = board.create('point', [x,y], {name:'SomePoint',size:4});
     *             // Shorter version:
     *             //somePoint = board.create('point', a, {name:'SomePoint',size:4});
     *         });
     *
     * </pre><div id='JXG48d5066b-16ba-4920-b8ea-a4f8eff6b746' class='jxgbox' style='width: 300px; height: 300px;'></div>
     * <script type='text/javascript'>
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG48d5066b-16ba-4920-b8ea-a4f8eff6b746',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     board.on('up', function (evt) {
     *             var a = board.getUsrCoordsOfMouse(evt),
     *                 x = a[0],
     *                 y = a[1],
     *                 somePoint = board.create('point', [x,y], {name:'SomePoint',size:4});
     *                 // Shorter version:
     *                 //somePoint = board.create('point', a, {name:'SomePoint',size:4});
     *             });
     *
     *     })();
     *
     * </script><pre>
     *
     * @see JXG.Board#getScrCoordsOfMouse
     * @see JXG.Board#getAllUnderMouse
     */
    getUsrCoordsOfMouse(evt) {
        var cPos = this.getCoordsTopLeftCorner(), absPos = Env.getPosition(evt, null, this.document), x = absPos[0] - cPos[0], y = absPos[1] - cPos[1], newCoords = new Coords$1(COORDS_BY.SCREEN, [x, y], this);
        return newCoords.usrCoords.slice(1);
    }
    /**
     * Collects all elements under current mouse position plus current user coordinates of mouse cursor.
     * @param {Event} evt Event object containing the mouse coordinates.
     * @returns {Array} Array of elements at the current mouse position plus current user coordinates of mouse.
     * @see JXG.Board#getUsrCoordsOfMouse
     * @see JXG.Board#getAllObjectsUnderMouse
     */
    getAllUnderMouse(evt) {
        var elList = this.getAllObjectsUnderMouse(evt);
        elList.push(this.getUsrCoordsOfMouse(evt));
        return elList;
    }
    /**
     * Collects all elements under current mouse position.
     * @param {Event} evt Event object containing the mouse coordinates.
     * @returns {Array} Array of elements at the current mouse position.
     * @see JXG.Board#getAllUnderMouse
     */
    getAllObjectsUnderMouse(evt) {
        var cPos = this.getCoordsTopLeftCorner(), absPos = Env.getPosition(evt, null, this.document), dx = absPos[0] - cPos[0], dy = absPos[1] - cPos[1], elList = [], el, pEl, len = this.objectsList.length;
        for (el = 0; el < len; el++) {
            pEl = this.objectsList[el];
            if (pEl.visPropCalc.visible && pEl.hasPoint && pEl.hasPoint(dx, dy)) {
                elList[elList.length] = pEl;
            }
        }
        return elList;
    }
    /**
     * Update the coords object of all elements which possess this
     * property. This is necessary after changing the viewport.
     * @returns {JXG.Board} Reference to this board.
     **/
    updateCoords() {
        var el, ob, froz, e, o, f, len = this.objectsList.length;
        for (ob = 0; ob < len; ob++) {
            el = this.objectsList[ob];
            if (Type.exists(el.coords)) {
                froz = el.evalVisProp('frozen');
                if (froz === 'inherit') {
                    // Search if a descendant of 'el' is set to 'frozen'.
                    // If yes, set element 'el' as frozen, too.
                    for (e in el.descendants /*el.childElements*/) {
                        if (el.descendants.hasOwnProperty(e)) {
                            o = el.descendants[e];
                            f = o.evalVisProp('frozen');
                            if (f === true || f === false) {
                                froz = f;
                                break;
                            }
                        }
                    }
                }
                if (froz === true) {
                    if (el.is3D) {
                        el.element2D.coords.screen2usr();
                    }
                    else {
                        el.coords.screen2usr();
                    }
                }
                else {
                    if (el.is3D) {
                        el.element2D.coords.usr2screen();
                    }
                    else {
                        el.coords.usr2screen();
                        if (Type.exists(el.actualCoords)) {
                            el.actualCoords.usr2screen();
                        }
                    }
                }
            }
        }
        return this;
    }
    /**
     * Moves the origin and initializes an update of all elements.
     * @param {Number} x
     * @param {Number} y
     * @param {Boolean} [diff=false]
     * @returns {JXG.Board} Reference to this board.
     */
    moveOrigin(x, y, diff = false) {
        var ox, oy, ul, lr;
        if (Type.exists(x) && Type.exists(y)) {
            ox = this.origin.scrCoords[1];
            oy = this.origin.scrCoords[2];
            this.origin.scrCoords[1] = x;
            this.origin.scrCoords[2] = y;
            if (diff) {
                this.origin.scrCoords[1] -= this.drag_dx;
                this.origin.scrCoords[2] -= this.drag_dy;
            }
            ul = new Coords$1(COORDS_BY.SCREEN, [0, 0], this).usrCoords;
            lr = new Coords$1(COORDS_BY.SCREEN, [this.canvasWidth, this.canvasHeight], this).usrCoords;
            if (ul[1] < Options.board.maxBoundingBox[0] - JSXMath.eps ||
                ul[2] > Options.board.maxBoundingBox[1] + JSXMath.eps ||
                lr[1] > Options.board.maxBoundingBox[2] + JSXMath.eps ||
                lr[2] < Options.board.maxBoundingBox[3] - JSXMath.eps) {
                this.origin.scrCoords[1] = ox;
                this.origin.scrCoords[2] = oy;
            }
        }
        this.updateCoords().clearTraces().fullUpdate();
        this.triggerEventHandlers(['boundingbox']);
        return this;
    }
    /**
     * Add conditional updates to the elements.
     * @param {String} str String containing conditional update in geonext syntax
     */
    addConditions(str) {
        var term, m, left, right, name, el, property, functions = [], 
        // plaintext = 'var el, x, y, c, rgbo;\n',
        i = str.indexOf('<data>'), j = str.indexOf('<' + '/data>');
        let xyFun = function (board, el, f, what) {
            return function () {
                var e, t;
                e = board.select(el.id);
                t = e.coords.usrCoords[what];
                if (what === 2) {
                    e.setPositionDirectly(COORDS_BY.USER, [f(), t]);
                }
                else {
                    e.setPositionDirectly(COORDS_BY.USER, [t, f()]);
                }
                e.prepareUpdate().update();
            };
        };
        let visFun = function (board, el, f) {
            return function () {
                var e, v;
                e = board.select(el.id);
                v = f();
                e.setAttribute({ visible: v });
            };
        };
        let colFun = function (board, el, f, what) {
            return function () {
                var e, v;
                e = board.select(el.id);
                v = f();
                if (what === 'strokewidth') {
                    e.visProp.strokewidth = v;
                }
                else {
                    v = Color.rgba2rgbo(v);
                    e.visProp[what + 'color'] = v[0];
                    e.visProp[what + 'opacity'] = v[1];
                }
            };
        };
        let posFun = function (board, el, f) {
            return function () {
                var e = board.select(el.id);
                e.position = f();
            };
        };
        let styleFun = function (board, el, f) {
            return function () {
                var e = board.select(el.id);
                e.setStyle(f());
            };
        };
        if (i < 0) {
            return;
        }
        while (i >= 0) {
            term = str.slice(i + 6, j); // throw away <data>
            m = term.indexOf('=');
            left = term.slice(0, m);
            right = term.slice(m + 1);
            m = left.indexOf('.'); // Resulting variable names must not contain dots, e.g. ' Steuern akt.'
            name = left.slice(0, m); //.replace(/\s+$/,''); // do NOT cut out name (with whitespace)
            el = this.elementsByName[Type.unescapeHTML(name)];
            property = left
                .slice(m + 1)
                .replace(/\s+/g, '')
                .toLowerCase(); // remove whitespace in property
            right = Type.createFunction(right, this, '');
            // Debug
            if (!Type.exists(this.elementsByName[name])) {
                JXG.debug('debug conditions: |' + name + '| undefined');
            }
            else {
                // plaintext += 'el = this.objects[\'' + el.id + '\'];\n';
                switch (property) {
                    case 'x':
                        functions.push(xyFun(this, el, right, 2));
                        break;
                    case 'y':
                        functions.push(xyFun(this, el, right, 1));
                        break;
                    case 'visible':
                        functions.push(visFun(this, el, right));
                        break;
                    case 'position':
                        functions.push(posFun(this, el, right));
                        break;
                    case 'stroke':
                        functions.push(colFun(this, el, right, 'stroke'));
                        break;
                    case 'style':
                        functions.push(styleFun(this, el, right));
                        break;
                    case 'strokewidth':
                        functions.push(colFun(this, el, right, 'strokewidth'));
                        break;
                    case 'fill':
                        functions.push(colFun(this, el, right, 'fill'));
                        break;
                    case 'label':
                        break;
                    default:
                        JXG.debug('property "' +
                            property +
                            '" in conditions not yet implemented:' +
                            right);
                        break;
                }
            }
            str = str.slice(j + 7); // cut off '</data>'
            i = str.indexOf('<data>');
            j = str.indexOf('<' + '/data>');
        }
        this.updateConditions = function () {
            var i;
            for (i = 0; i < functions.length; i++) {
                functions[i]();
            }
            this.prepareUpdate().updateElements();
            return true;
        };
        this.updateConditions();
    }
    /**
     * Computes the commands in the conditions-section of the gxt file.
     * It is evaluated after an update, before the unsuspendRedraw.
     * The function is generated in
     * @see JXG.Board#addConditions
     * @private
     */
    updateConditions() {
        return false;
    }
    /**
     * Calculates adequate snap sizes.
     * @returns {JXG.Board} Reference to the board.
     */
    calculateSnapSizes() {
        var p1, p2, bbox = this.getBoundingBox(), gridStep = Type.evaluate(Options.grid.majorStep), gridX = Type.evaluate(Options.grid.gridX), gridY = Type.evaluate(Options.grid.gridY);
        if (!Array.isArray(gridStep)) {
            gridStep = [gridStep, gridStep];
        }
        if (gridStep.length < 2) {
            gridStep = [gridStep[0], gridStep[0]];
        }
        if (Type.exists(gridX)) {
            gridStep[0] = gridX;
        }
        if (Type.exists(gridY)) {
            gridStep[1] = gridY;
        }
        if (gridStep[0] === 'auto') {
            gridStep[0] = 1;
        }
        else {
            gridStep[0] = Type.parseNumber(gridStep[0], Math.abs(bbox[1] - bbox[3]), 1 / this.unitX);
        }
        if (gridStep[1] === 'auto') {
            gridStep[1] = 1;
        }
        else {
            gridStep[1] = Type.parseNumber(gridStep[1], Math.abs(bbox[0] - bbox[2]), 1 / this.unitY);
        }
        p1 = new Coords$1(COORDS_BY.USER, [0, 0], this);
        p2 = new Coords$1(COORDS_BY.USER, [gridStep[0], gridStep[1]], this);
        p1.scrCoords[1] - p2.scrCoords[1];
        p1.scrCoords[2] - p2.scrCoords[2];
        // TODO: move upwards?
        // this.options.grid.snapSizeX = gridStep[0];
        // while (Math.abs(x) > 25) {
        //     this.options.grid.snapSizeX *= 2;
        //     x /= 2;
        // }
        // this.options.grid.snapSizeY = gridStep[1];
        // while (Math.abs(y) > 25) {
        //     this.options.grid.snapSizeY *= 2;
        //     y /= 2;
        // }
        return this;
    }
    /**
     * Apply update on all objects with the new zoom-factors. Clears all traces.
     * @returns {JXG.Board} Reference to the board.
     */
    applyZoom() {
        this.updateCoords().calculateSnapSizes().clearTraces().fullUpdate();
        return this;
    }
    /**
     * Zooms into the board by the factors board.attr.zoom.factorX and board.attr.zoom.factorY and applies the zoom.
     * The zoom operation is centered at x, y.
     * @param {Number} [x]
     * @param {Number} [y]
     * @returns {JXG.Board} Reference to the board
     */
    zoomIn(x, y) {
        var bb = this.getBoundingBox(), zX = Type.evaluate(this.attr.zoom.factorx), zY = Type.evaluate(this.attr.zoom.factory), dX = (bb[2] - bb[0]) * (1.0 - 1.0 / zX), dY = (bb[1] - bb[3]) * (1.0 - 1.0 / zY), lr = 0.5, tr = 0.5, ma = Type.evaluate(this.attr.zoom.max), mi = Type.evaluate(this.attr.zoom.eps) || Type.evaluate(this.attr.zoom.min) || 0.001; // this.attr.zoom.eps is deprecated
        if ((this.zoomX > ma && zX > 1.0) ||
            (this.zoomY > ma && zY > 1.0) ||
            (this.zoomX < mi && zX < 1.0) || // zoomIn is used for all zooms on touch devices
            (this.zoomY < mi && zY < 1.0)) {
            return this;
        }
        if (Type.isNumber(x) && Type.isNumber(y)) {
            lr = (x - bb[0]) / (bb[2] - bb[0]);
            tr = (bb[1] - y) / (bb[1] - bb[3]);
        }
        this.setBoundingBox([
            bb[0] + dX * lr,
            bb[1] - dY * tr,
            bb[2] - dX * (1 - lr),
            bb[3] + dY * (1 - tr)
        ], this.keepaspectratio, 'update');
        return this.applyZoom();
    }
    /**
     * Zooms out of the board by the factors board.attr.zoom.factorX and board.attr.zoom.factorY and applies the zoom.
     * The zoom operation is centered at x, y.
     *
     * @param {Number} [x]
     * @param {Number} [y]
     * @returns {JXG.Board} Reference to the board
     */
    zoomOut(x = 0, y = 0) {
        var bb = this.getBoundingBox(), zX = Type.evaluate(this.attr.zoom.factorx), zY = Type.evaluate(this.attr.zoom.factory), dX = (bb[2] - bb[0]) * (1.0 - zX), dY = (bb[1] - bb[3]) * (1.0 - zY), lr = 0.5, tr = 0.5, mi = Type.evaluate(this.attr.zoom.eps) || Type.evaluate(this.attr.zoom.min) || 0.001; // this.attr.zoom.eps is deprecated
        if (this.zoomX < mi || this.zoomY < mi) {
            return this;
        }
        if (Type.isNumber(x) && Type.isNumber(y)) {
            lr = (x - bb[0]) / (bb[2] - bb[0]);
            tr = (bb[1] - y) / (bb[1] - bb[3]);
        }
        this.setBoundingBox([
            bb[0] + dX * lr,
            bb[1] - dY * tr,
            bb[2] - dX * (1 - lr),
            bb[3] + dY * (1 - tr)
        ], this.keepaspectratio, 'update');
        return this.applyZoom();
    }
    /**
     * Reset the zoom level to the original zoom level from initBoard();
     * Additionally, if the board as been initialized with a boundingBox (which is the default),
     * restore the viewport to the original viewport during initialization. Otherwise,
     * (i.e. if the board as been initialized with unitX/Y and originX/Y),
     * just set the zoom level to 100%.
     *
     * @returns {JXG.Board} Reference to the board
     */
    zoom100() {
        var bb, dX, dY;
        if (Type.exists(this.attr.boundingbox)) {
            this.setBoundingBox(this.attr.boundingbox, this.keepaspectratio, 'reset');
        }
        else {
            // Board has been set up with unitX/Y and originX/Y
            bb = this.getBoundingBox();
            dX = (bb[2] - bb[0]) * (1.0 - this.zoomX) * 0.5;
            dY = (bb[1] - bb[3]) * (1.0 - this.zoomY) * 0.5;
            this.setBoundingBox([bb[0] + dX, bb[1] - dY, bb[2] - dX, bb[3] + dY], this.keepaspectratio, 'reset');
        }
        return this.applyZoom();
    }
    /**
     * Zooms the board so every visible point is shown. Keeps aspect ratio.
     * @returns {JXG.Board} Reference to the board
     */
    zoomAllPoints() {
        var el, border, borderX, borderY, pEl, minX = 0, maxX = 0, minY = 0, maxY = 0, len = this.objectsList.length;
        for (el = 0; el < len; el++) {
            pEl = this.objectsList[el];
            if (Type.isPoint(pEl) && pEl.visPropCalc.visible) {
                if (pEl.coords.usrCoords[1] < minX) {
                    minX = pEl.coords.usrCoords[1];
                }
                else if (pEl.coords.usrCoords[1] > maxX) {
                    maxX = pEl.coords.usrCoords[1];
                }
                if (pEl.coords.usrCoords[2] > maxY) {
                    maxY = pEl.coords.usrCoords[2];
                }
                else if (pEl.coords.usrCoords[2] < minY) {
                    minY = pEl.coords.usrCoords[2];
                }
            }
        }
        border = 50;
        borderX = border / this.unitX;
        borderY = border / this.unitY;
        this.setBoundingBox([minX - borderX, maxY + borderY, maxX + borderX, minY - borderY], this.keepaspectratio, 'update');
        return this.applyZoom();
    }
    /**
     * Reset the bounding box and the zoom level to 100% such that a given set of elements is
     * within the board's viewport.
     * @param {Array} elements A set of elements given by id, reference, or name.
     * @returns {JXG.Board} Reference to the board.
     */
    zoomElements(elements) {
        var i, e, box, newBBox = [Infinity, -Infinity, -Infinity, Infinity], cx, cy, dx, dy, d;
        if (!Array.isArray(elements) || elements.length === 0) {
            return this;
        }
        for (i = 0; i < elements.length; i++) {
            e = this.select(elements[i]);
            box = e.bounds();
            if (Array.isArray(box)) {
                if (box[0] < newBBox[0]) {
                    newBBox[0] = box[0];
                }
                if (box[1] > newBBox[1]) {
                    newBBox[1] = box[1];
                }
                if (box[2] > newBBox[2]) {
                    newBBox[2] = box[2];
                }
                if (box[3] < newBBox[3]) {
                    newBBox[3] = box[3];
                }
            }
        }
        if (Array.isArray(newBBox)) {
            cx = 0.5 * (newBBox[0] + newBBox[2]);
            cy = 0.5 * (newBBox[1] + newBBox[3]);
            dx = 1.5 * (newBBox[2] - newBBox[0]) * 0.5;
            dy = 1.5 * (newBBox[1] - newBBox[3]) * 0.5;
            d = Math.max(dx, dy);
            this.setBoundingBox([cx - d, cy + d, cx + d, cy - d], this.keepaspectratio, 'update');
        }
        return this;
    }
    /**
     * Sets the zoom level to <tt>fX</tt> resp <tt>fY</tt>.
     * @param {Number} fX
     * @param {Number} fY
     * @returns {JXG.Board} Reference to the board.
     */
    setZoom(fX, fY) {
        var oX = this.attr.zoom.factorx, oY = this.attr.zoom.factory;
        this.attr.zoom.factorx = fX / this.zoomX;
        this.attr.zoom.factory = fY / this.zoomY;
        this.zoomIn();
        this.attr.zoom.factorx = oX;
        this.attr.zoom.factory = oY;
        return this;
    }
    /**
     * Inner, recursive method of removeObject.
     *
     * @param {JXG.GeometryElement|Array} object The object to remove or array of objects to be removed.
     * The element(s) is/are given by name, id or a reference.
     * @param {Boolean} [saveMethod=false] If saveMethod=true, the algorithm runs through all elements
     * and tests if the element to be deleted is a child element. If this is the case, it will be
     * removed from the list of child elements. If saveMethod=false (default), the element
     * is removed from the lists of child elements of all its ancestors.
     * The latter should be much faster.
     * @returns {JXG.Board} Reference to the board
     * @private
     */
    _removeObj(object, saveMethod) {
        var el, i;
        if (Array.isArray(object)) {
            for (i = 0; i < object.length; i++) {
                this._removeObj(object[i], saveMethod);
            }
            return this;
        }
        object = this.select(object);
        // If the object which is about to be removed is unknown or a string, do nothing.
        // it is a string if a string was given and could not be resolved to an element.
        if (!Type.exists(object) || Type.isString(object)) {
            return this;
        }
        try {
            // remove all children.
            for (el in object.childElements) {
                if (object.childElements.hasOwnProperty(el)) {
                    object.childElements[el].board._removeObj(object.childElements[el]);
                }
            }
            // Remove all children in elements like turtle
            for (el in object.objects) {
                if (object.objects.hasOwnProperty(el)) {
                    object.objects[el].board._removeObj(object.objects[el]);
                }
            }
            // Remove the element from the childElement list and the descendant list of all elements.
            if (saveMethod) {
                // Running through all objects has quadratic complexity if many objects are deleted.
                for (el in this.objects) {
                    if (this.objects.hasOwnProperty(el)) {
                        if (Type.exists(this.objects[el].childElements) &&
                            Type.exists(this.objects[el].childElements.hasOwnProperty(object.id))) {
                            delete this.objects[el].childElements[object.id];
                            delete this.objects[el].descendants[object.id];
                        }
                    }
                }
            }
            else if (Type.exists(object.ancestors)) {
                // Running through the ancestors should be much more efficient.
                for (el in object.ancestors) {
                    if (object.ancestors.hasOwnProperty(el)) {
                        if (Type.exists(object.ancestors[el].childElements) &&
                            Type.exists(object.ancestors[el].childElements.hasOwnProperty(object.id))) {
                            delete object.ancestors[el].childElements[object.id];
                            delete object.ancestors[el].descendants[object.id];
                        }
                    }
                }
            }
            // remove the object itself from our control structures
            if (object._pos > -1) {
                this.objectsList.splice(object._pos, 1);
                for (i = object._pos; i < this.objectsList.length; i++) {
                    this.objectsList[i]._pos--;
                }
            }
            else if (object.type !== OBJECT_TYPE.TURTLE) {
                JXG.debug('Board.removeObject: object ' + object.id + ' not found in list.');
            }
            delete this.objects[object.id];
            delete this.elementsByName[object.name];
            if (object.visProp && object.evalVisProp('trace')) {
                object.clearTrace();
            }
            // the object deletion itself is handled by the object.
            if (Type.exists(object.remove)) {
                object.remove();
            }
        }
        catch (e) {
            JXG.debug(object.id + ': Could not be removed: ' + e);
        }
        return this;
    }
    /**
     * Removes object from board and renderer.
     * <p>
     * <b>Performance hints:</b> It is recommended to use the object's id.
     * If many elements are removed, it is best to call <tt>board.suspendUpdate()</tt>
     * before looping through the elements to be removed and call
     * <tt>board.unsuspendUpdate()</tt> after the loop. Further, it is advisable to loop
     * in reverse order, i.e. remove the object in reverse order of their creation time.
     * @param {JXG.GeometryElement|Array} object The object to remove or array of objects to be removed.
     * The element(s) is/are given by name, id or a reference.
     * @param {Boolean} saveMethod If true, the algorithm runs through all elements
     * and tests if the element to be deleted is a child element. If yes, it will be
     * removed from the list of child elements. If false (default), the element
     * is removed from the lists of child elements of all its ancestors.
     * This should be much faster.
     * @returns {JXG.Board} Reference to the board
     */
    removeObject(object, saveMethod = false) {
        var i;
        this.renderer.suspendRedraw();
        if (Array.isArray(object)) {
            for (i = 0; i < object.length; i++) {
                this._removeObj(object[i], saveMethod);
            }
        }
        else {
            this._removeObj(object, saveMethod);
        }
        this.renderer.unsuspendRedraw();
        this.update();
        return this;
    }
    /**
     * Removes the ancestors of an object an the object itself from board and renderer.
     * @param {JXG.GeometryElement} object The object to remove.
     * @returns {JXG.Board} Reference to the board
     */
    removeAncestors(object) {
        var anc;
        for (anc in object.ancestors) {
            if (object.ancestors.hasOwnProperty(anc)) {
                this.removeAncestors(object.ancestors[anc]);
            }
        }
        this.removeObject(object);
        return this;
    }
    /**
     * Initialize some objects which are contained in every GEONExT construction by default,
     * but are not contained in the gxt files.
     * @returns {JXG.Board} Reference to the board
     */
    initGeonextBoard() {
        var p1, p2, p3;
        p1 = this.create('point', [0, 0], {
            id: this.id + 'g00e0',
            name: 'Ursprung',
            withLabel: false,
            visible: false,
            fixed: true
        });
        p2 = this.create('point', [1, 0], {
            id: this.id + 'gX0e0',
            name: 'Punkt_1_0',
            withLabel: false,
            visible: false,
            fixed: true
        });
        p3 = this.create('point', [0, 1], {
            id: this.id + 'gY0e0',
            name: 'Punkt_0_1',
            withLabel: false,
            visible: false,
            fixed: true
        });
        this.create('line', [p1, p2], {
            id: this.id + 'gXLe0',
            name: 'X-Achse',
            withLabel: false,
            visible: false
        });
        this.create('line', [p1, p3], {
            id: this.id + 'gYLe0',
            name: 'Y-Achse',
            withLabel: false,
            visible: false
        });
        return this;
    }
    /**
     * Change the height and width of the board's container.
     * After doing so, {@link JXG.JSXGraph.setBoundingBox} is called using
     * the actual size of the bounding box and the actual value of keepaspectratio.
     * If setBoundingbox() should not be called automatically,
     * call resizeContainer with dontSetBoundingBox == true.
     * @param {Number} canvasWidth New width of the container.
     * @param {Number} canvasHeight New height of the container.
     * @param {Boolean} [dontset=false] If true do not set the CSS width and height of the DOM element.
     * @param {Boolean} [dontSetBoundingBox=false] If true do not call setBoundingBox(), but keep view centered around original visible center.
     * @returns {JXG.Board} Reference to the board
     */
    resizeContainer(canvasWidth, canvasHeight, dontset, dontSetBoundingBox = false) {
        var box, oldWidth, oldHeight, oX, oY;
        oldWidth = this.canvasWidth;
        oldHeight = this.canvasHeight;
        if (!dontSetBoundingBox) {
            box = this.getBoundingBox(); // This is the actual bounding box.
        }
        // this.canvasWidth = Math.max(parseFloat(canvasWidth), JSXMath.eps);
        // this.canvasHeight = Math.max(parseFloat(canvasHeight), JSXMath.eps);
        this.canvasWidth = parseFloat(canvasWidth);
        this.canvasHeight = parseFloat(canvasHeight);
        if (!dontset) {
            this.containerObj.style.width = this.canvasWidth + 'px';
            this.containerObj.style.height = this.canvasHeight + 'px';
        }
        this.renderer.resize(this.canvasWidth, this.canvasHeight);
        if (!dontSetBoundingBox) {
            this.setBoundingBox(box, this.keepaspectratio, 'keep');
        }
        else {
            oX = (this.canvasWidth - oldWidth) * 0.5;
            oY = (this.canvasHeight - oldHeight) * 0.5;
            this.moveOrigin(this.origin.scrCoords[1] + oX, this.origin.scrCoords[2] + oY);
        }
        return this;
    }
    /**
     * Lists the dependencies graph in a new HTML-window.
     * @returns {JXG.Board} Reference to the board
     */
    showDependencies() {
        var el, t, c, f, i;
        t = '<p>\n';
        for (el in this.objects) {
            if (this.objects.hasOwnProperty(el)) {
                i = 0;
                for (c in this.objects[el].childElements) {
                    if (this.objects[el].childElements.hasOwnProperty(c)) {
                        i += 1;
                    }
                }
                if (i >= 0) {
                    t += '<strong>' + this.objects[el].id + ':<' + '/strong> ';
                }
                for (c in this.objects[el].childElements) {
                    if (this.objects[el].childElements.hasOwnProperty(c)) {
                        t +=
                            this.objects[el].childElements[c].id +
                                '(' +
                                this.objects[el].childElements[c].name +
                                ')' +
                                ', ';
                    }
                }
                t += '<p>\n';
            }
        }
        t += '<' + '/p>\n';
        f = window.open();
        f.document.open();
        f.document.write(t);
        f.document.close();
        return this;
    }
    /**
     * Lists the XML code of the construction in a new HTML-window.
     * @returns {JXG.Board} Reference to the board
     */
    showXML() {
        var f = window.open('');
        f.document.open();
        f.document.write('<pre>' + Type.escapeHTML(this.xmlString) + '<' + '/pre>');
        f.document.close();
        return this;
    }
    /**
     * Sets for all objects the needsUpdate flag to 'true'.
     * @param{JXG.GeometryElement} [drag=undefined] Optional element that is dragged.
     * @returns {JXG.Board} Reference to the board
     */
    prepareUpdate(drag) {
        var el, i, pEl, len = this.objectsList.length;
        /*
        if (this.attr.updatetype === 'hierarchical') {
            return this;
        }
        */
        for (el = 0; el < len; el++) {
            pEl = this.objectsList[el];
            if (this._change3DView ||
                (Type.exists(drag) && drag.elType === 'view3d_slider')) {
                // The 3D view has changed. No elements are recomputed,
                // only 3D elements are projected to the new view.
                pEl.needsUpdate =
                    pEl.visProp.element3d ||
                        pEl.elType === 'view3d' ||
                        pEl.elType === 'view3d_slider' ||
                        this.needsFullUpdate;
                // Special case sphere3d in central projection:
                // We have to update the defining points of the ellipse
                if (pEl.visProp.element3d &&
                    pEl.visProp.element3d.type === OBJECT_TYPE.SPHERE3D) {
                    for (i = 0; i < pEl.parents.length; i++) {
                        this.objects[pEl.parents[i]].needsUpdate = true;
                    }
                }
            }
            else {
                pEl.needsUpdate = pEl.needsRegularUpdate || this.needsFullUpdate;
            }
        }
        for (el in this.groups) {
            if (this.groups.hasOwnProperty(el)) {
                pEl = this.groups[el];
                pEl.needsUpdate = pEl.needsRegularUpdate || this.needsFullUpdate;
            }
        }
        return this;
    }
    /**
     * Runs through all elements and calls their update() method.
     * @param {JXG.GeometryElement} drag Element that caused the update.
     * @returns {JXG.Board} Reference to the board
     */
    updateElements(drag) {
        var el, pEl;
        //var childId, i = 0;
        drag = this.select(drag);
        /*
        if (Type.exists(drag)) {
            for (el = 0; el < this.objectsList.length; el++) {
                pEl = this.objectsList[el];
                if (pEl.id === drag.id) {
                    i = el;
                    break;
                }
            }
        }
        */
        for (el = 0; el < this.objectsList.length; el++) {
            pEl = this.objectsList[el];
            if (this.needsFullUpdate && pEl.elementClass === OBJECT_CLASS.TEXT) {
                pEl.updateSize();
            }
            // For updates of an element we distinguish if the dragged element is updated or
            // other elements are updated.
            // The difference lies in the treatment of gliders and points based on transformations.
            pEl.update(!Type.exists(drag) || pEl.id !== drag.id).updateVisibility();
        }
        // update groups last
        for (el in this.groups) {
            if (this.groups.hasOwnProperty(el)) {
                this.groups[el].update(drag);
            }
        }
        return this;
    }
    /**
     * Runs through all elements and calls their update() method.
     * @returns {JXG.Board} Reference to the board
     */
    updateRenderer() {
        var el, len = this.objectsList.length, autoPositionLabelList = [], currentIndex, randomIndex;
        if (!this.renderer) {
            return;
        }
        /*
        objs = this.objectsList.slice(0);
        objs.sort(function (a, b) {
            if (a.visProp.layer < b.visProp.layer) {
                return -1;
            } else if (a.visProp.layer === b.visProp.layer) {
                return b.lastDragTime.getTime() - a.lastDragTime.getTime();
            } else {
                return 1;
            }
        });
        */
        // TODO
        // if (this.renderer.type === 'canvas') {
        // this.updateRendererCanvas();
        // } else {
        for (el = 0; el < len; el++) {
            if (this.objectsList[el].visProp.islabel && this.objectsList[el].visProp.autoposition) {
                autoPositionLabelList.push(el);
            }
            else {
                this.objectsList[el].updateRenderer();
            }
        }
        currentIndex = autoPositionLabelList.length;
        // Randomize the order of the labels
        while (currentIndex !== 0) {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex--;
            [autoPositionLabelList[currentIndex], autoPositionLabelList[randomIndex]] = [autoPositionLabelList[randomIndex], autoPositionLabelList[currentIndex]];
        }
        for (el = 0; el < autoPositionLabelList.length; el++) {
            this.objectsList[autoPositionLabelList[el]].updateRenderer();
        }
        /*
        for (el = autoPositionLabelList.length - 1; el >= 0; el--) {
            this.objectsList[autoPositionLabelList[el]].updateRenderer();
        }
        */
        // }
        return this;
    }
    /**
     * Runs through all elements and calls their update() method.
     * This is a special version for the CanvasRenderer.
     * Here, we have to do our own layer handling.
     * @returns {JXG.Board} Reference to the board
     */
    updateRendererCanvas() {
        var el, pEl, olen = this.objectsList.length, 
        // i, minim, lay,
        // layers = this.options.layer,
        // len = this.options.layer.numlayers,
        // last = Number.NEGATIVE_INFINITY.toExponential,
        depth_order_layers = [], objects_sorted, 
        // Sort the elements for the canvas rendering according to
        // their layer, _pos, depthOrder (with this priority)
        // @private
        _compareFn = function (a, b) {
            if (a.visProp.layer !== b.visProp.layer) {
                return a.visProp.layer - b.visProp.layer;
            }
            // The objects are in the same layer, but the layer is not depth ordered
            if (depth_order_layers.indexOf(a.visProp.layer) === -1) {
                return a._pos - b._pos;
            }
            // The objects are in the same layer and the layer is depth ordered
            // We have to sort 2D elements according to the zIndices of
            // their 3D parents.
            if (!a.visProp.element3d && !b.visProp.element3d) {
                return a._pos - b._pos;
            }
            if (a.visProp.element3d && !b.visProp.element3d) {
                return -1;
            }
            if (b.visProp.element3d && !a.visProp.element3d) {
                return 1;
            }
            return a.visProp.element3d.zIndex - b.visProp.element3d.zIndex;
        };
        // Only one view3d element is supported. Get the depth orderer layers and
        // update the zIndices of the 3D elements.
        for (el = 0; el < olen; el++) {
            pEl = this.objectsList[el];
            if (pEl.elType === 'view3d' && pEl.evalVisProp('depthorder.enabled')) {
                depth_order_layers = pEl.evalVisProp('depthorder.layers');
                pEl.updateRenderer();
                break;
            }
        }
        objects_sorted = this.objectsList.toSorted(_compareFn);
        olen = objects_sorted.length;
        for (el = 0; el < olen; el++) {
            objects_sorted[el].prepareUpdate().updateRenderer();
        }
        // for (i = 0; i < len; i++) {
        //     minim = Number.POSITIVE_INFINITY;
        //     for (lay in layers) {
        //         if (layers.hasOwnProperty(lay)) {
        //             if (layers[lay] > last && layers[lay] < minim) {
        //                 minim = layers[lay];
        //             }
        //         }
        //     }
        //     for (el = 0; el < olen; el++) {
        //         pEl = this.objectsList[el];
        //         if (pEl.visProp.layer === minim) {
        //             pEl.prepareUpdate().updateRenderer();
        //         }
        //     }
        //     last = minim;
        // }
        return this;
    }
    /**
     * Please use {@link JXG.Board.on} instead.
     * @param {Function} hook A function to be called by the board after an update occurred.
     * @param {String} [m='update'] When the hook is to be called. Possible values are <i>mouseup</i>, <i>mousedown</i> and <i>update</i>.
     * @param {Object} [context=board] Determines the execution context the hook is called. This parameter is optional, default is the
     * board object the hook is attached to.
     * @returns {Number} Id of the hook, required to remove the hook from the board.
     * @deprecated
     */
    addHook(hook, m, context) {
        JXG.deprecated('Board.addHook()', 'Board.on()');
        m = Type.def(m, 'update');
        context = Type.def(context, this);
        this.hooks.push([m, hook]);
        this.on(m, hook, context);
        return this.hooks.length - 1;
    }
    // /**
    //  * Alias of {@link JXG.Board.on}.
    //  */
    // addEvent: JXG.shortcut(JXG.Board.prototype, 'on'),
    /**
     * Please use {@link JXG.Board.off} instead.
     * @param {Number|function} id The number you got when you added the hook or a reference to the event handler.
     * @returns {JXG.Board} Reference to the board
     * @deprecated
     */
    removeHook(id) {
        JXG.deprecated('Board.removeHook()', 'Board.off()');
        if (this.hooks[id]) {
            this.off(this.hooks[id][0], this.hooks[id][1]);
            this.hooks[id] = null;
        }
        return this;
    }
    // /**
    //  * Alias of {@link JXG.Board.off}.
    //  */
    // removeEvent: JXG.shortcut(JXG.Board.prototype, 'off'),
    /**
     * Runs through all hooked functions and calls them.
     * @returns {JXG.Board} Reference to the board
     * @deprecated
     */
    updateHooks(m) {
        var arg = Array.prototype.slice.call(arguments, 0);
        JXG.deprecated('Board.updateHooks()', 'Board.triggerEventHandlers()');
        arg[0] = Type.def(arg[0], 'update');
        this.triggerEventHandlers([arg[0]], arguments);
        return this;
    }
    /**
     * Adds a dependent board to this board.
     * @param {JXG.Board} board A reference to board which will be updated after an update of this board occurred.
     * @returns {JXG.Board} Reference to the board
     */
    addChild(board) {
        if (Type.exists(board) && Type.exists(board.containerObj)) {
            this.dependentBoards.push(board);
            this.update();
        }
        return this;
    }
    /**
     * Deletes a board from the list of dependent boards.
     * @param {JXG.Board} board Reference to the board which will be removed.
     * @returns {JXG.Board} Reference to the board
     */
    removeChild(board) {
        var i;
        for (i = this.dependentBoards.length - 1; i >= 0; i--) {
            if (this.dependentBoards[i] === board) {
                this.dependentBoards.splice(i, 1);
            }
        }
        return this;
    }
    /**
     * Runs through most elements and calls their update() method and update the conditions.
     * @param {JXG.GeometryElement} [drag] Element that caused the update.
     * @returns {JXG.Board} Reference to the board
     */
    update(drag = true) {
        var i, len, b, insert, storeActiveEl;
        if (this.inUpdate || this.isSuspendedUpdate) {
            return this;
        }
        this.inUpdate = true;
        if (this.attr.minimizereflow === 'all' &&
            this.containerObj &&
            this.renderer.type !== 'vml') {
            storeActiveEl = this.document.activeElement; // Store focus element
            insert = this.renderer.removeToInsertLater(this.containerObj);
        }
        if (this.attr.minimizereflow === 'svg' && this.renderer.type === 'svg') {
            storeActiveEl = this.document.activeElement;
            insert = this.renderer.removeToInsertLater(this.renderer.svgRoot);
        }
        this.prepareUpdate(drag).updateElements(drag).updateConditions();
        this.renderer.suspendRedraw();
        this.updateRenderer();
        this.renderer.unsuspendRedraw();
        this.triggerEventHandlers(['update'], []);
        if (insert) {
            insert();
            storeActiveEl.focus(); // Restore focus element
        }
        // To resolve dependencies between boards
        // for (var board in JXG.boards) {
        len = this.dependentBoards.length;
        for (i = 0; i < len; i++) {
            b = this.dependentBoards[i];
            if (Type.exists(b) && b !== this) {
                b.updateQuality = this.updateQuality;
                b.prepareUpdate().updateElements().updateConditions();
                b.renderer.suspendRedraw(this);
                b.updateRenderer();
                b.renderer.unsuspendRedraw();
                b.triggerEventHandlers(['update'], []);
            }
        }
        this.inUpdate = false;
        return this;
    }
    /**
     * Runs through all elements and calls their update() method and update the conditions.
     * This is necessary after zooming and changing the bounding box.
     * @returns {JXG.Board} Reference to the board
     */
    fullUpdate() {
        this.needsFullUpdate = true;
        this.update();
        this.needsFullUpdate = false;
        return this;
    }
    /**
     * Adds a grid to the board according to the settings given in board.options.
     * @returns {JXG.Board} Reference to the board.
     */
    addGrid() {
        this.create('grid', []);
        return this;
    }
    /**
     * Removes all grids assigned to this board. Warning: This method also removes all objects depending on one or
     * more of the grids.
     * @returns {JXG.Board} Reference to the board object.
     */
    removeGrids() {
        var i;
        for (i = 0; i < this.grids.length; i++) {
            this.removeObject(this.grids[i]);
        }
        this.grids.length = 0;
        this.update(); // required for canvas renderer
        return this;
    }
    /**
     * Creates a new geometric element of type elementType.
     * @param {String} elementType Type of the element to be constructed given as a string e.g. 'point' or 'circle'.
     * @param {Array} parents Array of parent elements needed to construct the element e.g. coordinates for a point or two
     * points to construct a line. This highly depends on the elementType that is constructed. See the corresponding JXG.create*
     * methods for a list of possible parameters.
     * @param {Object} [attributes] An object containing the attributes to be set. This also depends on the elementType.
     * Common attributes are name, visible, strokeColor.
     * @returns {Object} Reference to the created element. This is usually a GeometryElement, but can be an array containing
     * two or more elements.
     */
    create(elementType, parents = [], attributes = {}) {
        var el, i;
        elementType = elementType.toLowerCase();
        // this loop lets us select parents by name (eg: a point with label 'A' can be referenced by A)
        for (i = 0; i < parents.length; i++) {
            if (Type.isString(parents[i]) &&
                !(elementType === 'text' && i === 2) &&
                !(elementType === 'solidofrevolution3d' && i === 2) &&
                !(elementType === 'text3d' && (i === 2 || i === 4)) &&
                !((elementType === 'input' ||
                    elementType === 'checkbox' ||
                    elementType === 'button') &&
                    (i === 2 || i === 3)) &&
                !(elementType === 'curve' /*&& i > 0*/) && // Allow curve plots with jessiecode, parents[0] is the
                // variable name
                !(elementType === 'functiongraph') && // Prevent problems with function terms like 'x', 'y'
                !(elementType === 'implicitcurve')) {
                if (i > 0 && parents[0].elType === 'view3d') {
                    // 3D elements are based on 3D elements, only
                    parents[i] = parents[0].select(parents[i]);
                }
                else {
                    parents[i] = this.select(parents[i]);
                }
            }
        }
        // TODO: main switch
        if (elementType == 'text') {
            el = createText(this, parents, attributes);
        }
        else {
            switch (elementType) {
                case 'text':
                    el = createText(this, parents, attributes);
                    break;
                case 'point':
                    el = createPoint(this, parents, attributes);
                    break;
            }
            if (el.prepareUpdate && el.update && el.updateRenderer) {
                el.fullUpdate();
            }
        }
        return el;
    }
    /**
     * Deprecated name for {@link JXG.Board.create}.
     * @deprecated
     */
    createElement() {
        JXG.deprecated('Board.createElement()', 'Board.create()');
        return this.create.apply(this, arguments);
    }
    /**
     * Delete the elements drawn as part of a trace of an element.
     * @returns {JXG.Board} Reference to the board
     */
    clearTraces() {
        var el;
        for (el = 0; el < this.objectsList.length; el++) {
            this.objectsList[el].clearTrace();
        }
        this.numTraces = 0;
        return this;
    }
    /**
     * Stop updates of the board.
     * @returns {JXG.Board} Reference to the board
     */
    suspendUpdate() {
        if (!this.inUpdate) {
            this.isSuspendedUpdate = true;
        }
        return this;
    }
    /**
     * Enable updates of the board.
     * @returns {JXG.Board} Reference to the board
     */
    unsuspendUpdate() {
        if (this.isSuspendedUpdate) {
            this.isSuspendedUpdate = false;
            this.fullUpdate();
        }
        return this;
    }
    /**
     * Set the bounding box of the board.
     * @param {Array} bbox New bounding box [x1,y1,x2,y2]
     * @param {Boolean} [keepaspectratio=false] If set to true, the aspect ratio will be 1:1, but
     * the resulting viewport may be larger.
     * @param {String} [setZoom='reset'] Reset, keep or update the zoom level of the board. 'reset'
     * sets {@link JXG.Board#zoomX} and {@link JXG.Board#zoomY} to the start values (or 1.0).
     * 'update' adapts these values accoring to the new bounding box and 'keep' does nothing.
     * @returns {JXG.Board} Reference to the board
     */
    setBoundingBox(bbox, keepaspectratio = false, setZoom = "reset") {
        var h, w, ux, uy, offX = 0, offY = 0, zoom_ratio = 1, ratio, dx, dy, prev_w, prev_h, dim = Env.getDimensions(this.containerObj, this.document);
        if (!Array.isArray(bbox)) {
            return this;
        }
        if (bbox[0] < Options.board.maxBoundingBox[0] - JSXMath.eps ||
            bbox[1] > Options.board.maxBoundingBox[1] + JSXMath.eps ||
            bbox[2] > Options.board.maxBoundingBox[2] + JSXMath.eps ||
            bbox[3] < Options.board.maxBoundingBox[3] - JSXMath.eps) {
            return this;
        }
        if (!Type.exists(setZoom)) {
            setZoom = 'reset';
        }
        ux = this.unitX;
        uy = this.unitY;
        this.canvasWidth = parseFloat(dim.width); // parseInt(dim.width, 10);
        this.canvasHeight = parseFloat(dim.height); // parseInt(dim.height, 10);
        w = this.canvasWidth;
        h = this.canvasHeight;
        if (keepaspectratio) {
            if (this.keepaspectratio) {
                ratio = ux / uy; // Keep this ratio if keepaspectratio was true
                if (isNaN(ratio)) {
                    ratio = 1.0;
                }
            }
            else {
                ratio = 1.0;
            }
            if (setZoom === 'keep') {
                zoom_ratio = this.zoomX / this.zoomY;
            }
            dx = bbox[2] - bbox[0];
            dy = bbox[1] - bbox[3];
            prev_w = ux * dx;
            prev_h = uy * dy;
            if (w >= h) {
                if (prev_w >= prev_h) {
                    this.unitY = h / dy;
                    this.unitX = this.unitY * ratio;
                }
                else {
                    // Switch dominating interval
                    this.unitY = h / Math.abs(dx) * JSXMath.sign(dy) / zoom_ratio;
                    this.unitX = this.unitY * ratio;
                }
            }
            else {
                if (prev_h > prev_w) {
                    this.unitX = w / dx;
                    this.unitY = this.unitX / ratio;
                }
                else {
                    // Switch dominating interval
                    this.unitX = w / Math.abs(dy) * JSXMath.sign(dx) * zoom_ratio;
                    this.unitY = this.unitX / ratio;
                }
            }
            // Add the additional units in equal portions left and right
            offX = (w / this.unitX - dx) * 0.5;
            // Add the additional units in equal portions above and below
            offY = (h / this.unitY - dy) * 0.5;
            this.keepaspectratio = true;
        }
        else {
            this.unitX = w / (bbox[2] - bbox[0]);
            this.unitY = h / (bbox[1] - bbox[3]);
            this.keepaspectratio = false;
        }
        this.moveOrigin(-this.unitX * (bbox[0] - offX), this.unitY * (bbox[1] + offY));
        if (setZoom === 'update') {
            this.zoomX *= this.unitX / ux;
            this.zoomY *= this.unitY / uy;
        }
        else if (setZoom === 'reset') {
            this.zoomX = Type.exists(this.attr.zoomx) ? this.attr.zoomx : 1.0;
            this.zoomY = Type.exists(this.attr.zoomy) ? this.attr.zoomy : 1.0;
        }
        return this;
    }
    /**
     * Get the bounding box of the board.
     * @returns {Array} bounding box [x1,y1,x2,y2] upper left corner, lower right corner
     */
    getBoundingBox() {
        var ul = new Coords$1(COORDS_BY.SCREEN, [0, 0], this).usrCoords, lr = new Coords$1(COORDS_BY.SCREEN, [this.canvasWidth, this.canvasHeight], this).usrCoords;
        return [ul[1], ul[2], lr[1], lr[2]];
    }
    /**
     * Sets the value of attribute <tt>key</tt> to <tt>value</tt>.
     * @param {String} key The attribute's name.
     * @param value The new value
     * @private
     */
    _set(key, value) {
        key = key.toLocaleLowerCase();
        if (value !== null &&
            Type.isObject(value) &&
            !Type.exists(value.id) &&
            !Type.exists(value.name)) {
            // value is of type {prop: val, prop: val,...}
            // Convert these attributes to lowercase, too
            // this.attr[key] = {};
            // for (el in value) {
            //     if (value.hasOwnProperty(el)) {
            //         this.attr[key][el.toLocaleLowerCase()] = value[el];
            //     }
            // }
            this.attr[key] = Type.mergeAttrHelper(this.attr[key], value);
        }
        else {
            this.attr[key] = value;
        }
    }
    /**
     * Sets an arbitrary number of attributes. This method has one or more
     * parameters of the following types:
     * <ul>
     * <li> object: {key1:value1,key2:value2,...}
     * <li> string: 'key:value'
     * <li> array: ['key', value]
     * </ul>
     * Some board attributes are immutable, like e.g. the renderer type.
     *
     * @param {Object} attributes An object with attributes.
     * @returns {JXG.Board} Reference to the board
     *
     * @example
     * const board = JXG.JSXGraph.initBoard('jxgbox', {
     *     boundingbox: [-5, 5, 5, -5],
     *     keepAspectRatio: false,
     *     axis:true,
     *     showFullscreen: true,
     *     showScreenshot: true,
     *     showCopyright: false
     * });
     *
     * board.setAttribute({
     *     animationDelay: 10,
     *     boundingbox: [-10, 5, 10, -5],
     *     defaultAxes: {
     *         x: { strokeColor: 'blue', ticks: { strokeColor: 'blue'}}
     *     }
     *     description: 'test',
     *     fullscreen: {
     *         scale: 0.5
     *     }
     *     intl: {
     *         enabled: true,
     *         locale: 'de-DE'
     *     }
     * });
     *
     * board.setAttribute({
     *     selection: {
     *         enabled: true,
     *         fillColor: 'blue'
     *     }
     *     showInfobox: false,
     *     zoomX: 0.5,
     *     zoomY: 2,
     *     fullscreen: { symbol: 'x' }
     *     screenshot: { symbol: 'y' }
     *     showCopyright: true,
     *     showFullscreen: false,
     *     showScreenshot: false,
     *     showZoom: false,
     *     showNavigation: false
     * });
     * board.setAttribute('showCopyright:false');
     *
     * var p = board.create('point', [1, 1], {size: 10,
     *     label: {
     *         fontSize: 24,
     *         highlightStrokeOpacity: 0.1,
     *         offset: [5, 0]
     *     }
     * });
     *
     *
     * </pre><div id="JXGea7b8e09-beac-4d95-9a0c-5fc1c761ffbc" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *     const board = JXG.JSXGraph.initBoard('JXGea7b8e09-beac-4d95-9a0c-5fc1c761ffbc', {
     *         boundingbox: [-5, 5, 5, -5],
     *         keepAspectRatio: false,
     *         axis:true,
     *         showFullscreen: true,
     *         showScreenshot: true,
     *         showCopyright: false
     *     });
     *
     *     board.setAttribute({
     *         animationDelay: 10,
     *         boundingbox: [-10, 5, 10, -5],
     *         defaultAxes: {
     *             x: { strokeColor: 'blue', ticks: { strokeColor: 'blue'}}
     *         }
     *         description: 'test',
     *         fullscreen: {
     *             scale: 0.5
     *         }
     *         intl: {
     *             enabled: true,
     *             locale: 'de-DE'
     *         }
     *     });
     *
     *     board.setAttribute({
     *         selection: {
     *             enabled: true,
     *             fillColor: 'blue'
     *         }
     *         showInfobox: false,
     *         zoomX: 0.5,
     *         zoomY: 2,
     *         fullscreen: { symbol: 'x' }
     *         screenshot: { symbol: 'y' }
     *         showCopyright: true,
     *         showFullscreen: false,
     *         showScreenshot: false,
     *         showZoom: false,
     *         showNavigation: false
     *     });
     *
     *     board.setAttribute('showCopyright:false');
     *
     *     var p = board.create('point', [1, 1], {size: 10,
     *         label: {
     *             fontSize: 24,
     *             highlightStrokeOpacity: 0.1,
     *             offset: [5, 0]
     *         }
     *     });
     *
     *
     *     })();
     *
     * </script><pre>
     *
     *
     */
    setAttribute(attr) {
        var i, arg, pair, key, value, oldvalue, // j, le,
        node, attributes = {};
        // Normalize the user input
        for (i = 0; i < arguments.length; i++) {
            arg = arguments[i];
            if (Type.isString(arg)) {
                // pairRaw is string of the form 'key:value'
                pair = arg.split(":");
                attributes[Type.trim(pair[0])] = Type.trim(pair[1]);
            }
            else if (!Array.isArray(arg)) {
                // pairRaw consists of objects of the form {key1:value1,key2:value2,...}
                JXG.extend(attributes, arg);
            }
            else {
                // pairRaw consists of array [key,value]
                attributes[arg[0]] = arg[1];
            }
        }
        for (i in attributes) {
            if (attributes.hasOwnProperty(i)) {
                key = i.replace(/\s+/g, "").toLowerCase();
                value = attributes[i];
            }
            value = (value.toLowerCase && value.toLowerCase() === 'false')
                ? false
                : value;
            oldvalue = this.attr[key];
            if (oldvalue === value) {
                continue;
            }
            switch (key) {
                case 'axis':
                    if (value === false) {
                        if (Type.exists(this.defaultAxes)) {
                            this.defaultAxes.x.setAttribute({ visible: false });
                            this.defaultAxes.y.setAttribute({ visible: false });
                        }
                    }
                    break;
                case 'boundingbox':
                    this.setBoundingBox(value, this.keepaspectratio);
                    this._set(key, value);
                    break;
                case 'defaultaxes':
                    if (Type.exists(this.defaultAxes.x) && Type.exists(value.x)) {
                        this.defaultAxes.x.setAttribute(value.x);
                    }
                    if (Type.exists(this.defaultAxes.y) && Type.exists(value.y)) {
                        this.defaultAxes.y.setAttribute(value.y);
                    }
                    break;
                case 'title':
                    this.document.getElementById(this.container + '_ARIAlabel')
                        .innerHTML = value;
                    this._set(key, value);
                    break;
                case 'keepaspectratio':
                    this._set(key, value);
                    this.setBoundingBox(this.getBoundingBox(), value, 'keep');
                    break;
                // /* eslint-disable no-fallthrough */
                case 'document':
                case 'maxboundingbox':
                    this[key] = value;
                    this._set(key, value);
                    break;
                case 'zoomx':
                case 'zoomy':
                    this[key] = value;
                    this._set(key, value);
                    this.setZoom(this.attr.zoomx, this.attr.zoomy);
                    break;
                case 'registerevents':
                case 'renderer':
                    // immutable, i.e. ignored
                    break;
                case 'fullscreen':
                case 'screenshot':
                    node = this.containerObj.ownerDocument.getElementById(this.container + '_navigation_' + key);
                    if (node && Type.exists(value.symbol)) {
                        node.innerHTML = Type.evaluate(value.symbol);
                    }
                    this._set(key, value);
                    break;
                case 'selection':
                    value.visible = false;
                    value.withLines = false;
                    value.vertices = { visible: false };
                    this._set(key, value);
                    break;
                case 'showcopyright':
                    if (this.renderer.type === 'svg') {
                        node = this.containerObj.ownerDocument.getElementById(this.renderer.uniqName('licenseText'));
                        if (node) {
                            node.style.display = ((Type.evaluate(value)) ? 'inline' : 'none');
                        }
                        else if (Type.evaluate(value)) {
                            this.renderer.displayCopyright(this.licenseText, Options.text.fontSize);
                        }
                    }
                    this._set(key, value);
                    break;
                case 'showlogo':
                    if (this.renderer.type === 'svg') {
                        node = this.containerObj.ownerDocument.getElementById(this.renderer.uniqName('licenseLogo'));
                        if (node) {
                            node.style.display = ((Type.evaluate(value)) ? 'inline' : 'none');
                        }
                        else if (Type.evaluate(value)) {
                            this.renderer.displayLogo(this.licenseLogo, Options.text.fontSize);
                        }
                    }
                    this._set(key, value);
                    break;
                default:
                    if (Type.exists(this.attr[key])) {
                        this._set(key, value);
                    }
                    break;
                // /* eslint-enable no-fallthrough */
            }
        }
        // Redraw navbar to handle the remaining show* attributes
        this.containerObj.ownerDocument.getElementById(this.container + "_navigationbar").remove();
        this.renderer.drawNavigationBar(this, this.attr.navbar);
        this.triggerEventHandlers(["attribute"], [attributes, this]);
        this.fullUpdate();
        return this;
    }
    /**
     * Adds an animation. Animations are controlled by the boards, so the boards need to be aware of the
     * animated elements. This function tells the board about new elements to animate.
     * @param {JXG.GeometryElement} element The element which is to be animated.
     * @returns {JXG.Board} Reference to the board
     */
    addAnimation(element) {
        var that = this;
        this.animationObjects[element.id] = element;
        if (!this.animationIntervalCode) {
            this.animationIntervalCode = window.setInterval(function () {
                that.animate();
            }, element.board.attr.animationdelay);
        }
        return this;
    }
    /**
     * Cancels all running animations.
     * @returns {JXG.Board} Reference to the board
     */
    stopAllAnimation() {
        var el;
        for (el in this.animationObjects) {
            if (this.animationObjects.hasOwnProperty(el) &&
                Type.exists(this.animationObjects[el])) {
                this.animationObjects[el] = null;
                delete this.animationObjects[el];
            }
        }
        window.clearInterval(this.animationIntervalCode);
        delete this.animationIntervalCode;
        return this;
    }
    /**
     * General purpose animation function. This currently only supports moving points from one place to another. This
     * is faster than managing the animation per point, especially if there is more than one animated point at the same time.
     * @returns {JXG.Board} Reference to the board
     */
    animate() {
        var props, el, o, newCoords, r, p, c, cbtmp, count = 0, obj = null;
        for (el in this.animationObjects) {
            if (this.animationObjects.hasOwnProperty(el) &&
                Type.exists(this.animationObjects[el])) {
                count += 1;
                o = this.animationObjects[el];
                if (o.animationPath) {
                    if (Type.isFunction(o.animationPath)) {
                        newCoords = o.animationPath(new Date().getTime() - o.animationStart);
                    }
                    else {
                        newCoords = o.animationPath.pop();
                    }
                    if (!Type.exists(newCoords) ||
                        (!Array.isArray(newCoords) && isNaN(newCoords))) {
                        delete o.animationPath;
                    }
                    else {
                        o.setPositionDirectly(COORDS_BY.USER, newCoords);
                        o.fullUpdate();
                        obj = o;
                    }
                }
                if (o.animationData) {
                    c = 0;
                    for (r in o.animationData) {
                        if (o.animationData.hasOwnProperty(r)) {
                            p = o.animationData[r].pop();
                            if (!Type.exists(p)) {
                                delete o.animationData[p];
                            }
                            else {
                                c += 1;
                                props = {};
                                props[r] = p;
                                o.setAttribute(props);
                            }
                        }
                    }
                    if (c === 0) {
                        delete o.animationData;
                    }
                }
                if (!Type.exists(o.animationData) && !Type.exists(o.animationPath)) {
                    this.animationObjects[el] = null;
                    delete this.animationObjects[el];
                    if (Type.exists(o.animationCallback)) {
                        cbtmp = o.animationCallback;
                        o.animationCallback = null;
                        cbtmp();
                    }
                }
            }
        }
        if (count === 0) {
            window.clearInterval(this.animationIntervalCode);
            delete this.animationIntervalCode;
        }
        else {
            this.update(obj);
        }
        return this;
    }
    /**
     * Migrate the dependency properties of the point src
     * to the point dest and delete the point src.
     * For example, a circle around the point src
     * receives the new center dest. The old center src
     * will be deleted.
     * @param {JXG.Point} src Original point which will be deleted
     * @param {JXG.Point} dest New point with the dependencies of src.
     * @param {Boolean} copyName Flag which decides if the name of the src element is copied to the
     *  dest element.
     * @returns {JXG.Board} Reference to the board
     */
    migratePoint(src, dest, copyName) {
        var child, childId, prop, found, i, srcLabelId, srcHasLabel = false;
        src = this.select(src);
        dest = this.select(dest);
        if (Type.exists(src.label)) {
            srcLabelId = src.label.id;
            srcHasLabel = true;
            this.removeObject(src.label);
        }
        for (childId in src.childElements) {
            if (src.childElements.hasOwnProperty(childId)) {
                child = src.childElements[childId];
                found = false;
                for (prop in child) {
                    if (child.hasOwnProperty(prop)) {
                        if (child[prop] === src) {
                            child[prop] = dest;
                            found = true;
                        }
                    }
                }
                if (found) {
                    delete src.childElements[childId];
                }
                for (i = 0; i < child.parents.length; i++) {
                    if (child.parents[i] === src.id) {
                        child.parents[i] = dest.id;
                    }
                }
                dest.addChild(child);
            }
        }
        // The destination object should receive the name
        // and the label of the originating (src) object
        if (copyName) {
            if (srcHasLabel) {
                delete dest.childElements[srcLabelId];
                delete dest.descendants[srcLabelId];
            }
            if (dest.label) {
                this.removeObject(dest.label);
            }
            delete this.elementsByName[dest.name];
            dest.name = src.name;
            if (srcHasLabel) {
                dest.createLabel();
            }
        }
        this.removeObject(src);
        if (Type.exists(dest.name) && dest.name !== '') {
            this.elementsByName[dest.name] = dest;
        }
        this.fullUpdate();
        return this;
    }
    /**
     * Initializes color blindness simulation.
     * @param {String} deficiency Describes the color blindness deficiency which is simulated. Accepted values are 'protanopia', 'deuteranopia', and 'tritanopia'.
     * @returns {JXG.Board} Reference to the board
     */
    emulateColorblindness(deficiency) {
        var e, o;
        if (!Type.exists(deficiency)) {
            deficiency = 'none';
        }
        if (this.currentCBDef === deficiency) {
            return this;
        }
        for (e in this.objects) {
            if (this.objects.hasOwnProperty(e)) {
                o = this.objects[e];
                if (deficiency !== 'none') {
                    if (this.currentCBDef === 'none') {
                        // this could be accomplished by JXG.extend, too. But do not use
                        // Type.deepcopy as this could result in an infinite loop because in
                        // visProp there could be geometry elements which contain the board which
                        // contains all objects which contain board etc.
                        o.visPropOriginal = {
                            strokecolor: o.visProp.strokecolor,
                            fillcolor: o.visProp.fillcolor,
                            highlightstrokecolor: o.visProp.highlightstrokecolor,
                            highlightfillcolor: o.visProp.highlightfillcolor
                        };
                    }
                    o.setAttribute({
                        strokecolor: Color.rgb2cb(o.eval(o.visPropOriginal.strokecolor), deficiency),
                        fillcolor: Color.rgb2cb(o.eval(o.visPropOriginal.fillcolor), deficiency),
                        highlightstrokecolor: Color.rgb2cb(o.eval(o.visPropOriginal.highlightstrokecolor), deficiency),
                        highlightfillcolor: Color.rgb2cb(o.eval(o.visPropOriginal.highlightfillcolor), deficiency)
                    });
                }
                else if (Type.exists(o.visPropOriginal)) {
                    JXG.extend(o.visProp, o.visPropOriginal);
                }
            }
        }
        this.currentCBDef = deficiency;
        this.update();
        return this;
    }
    /**
     * Select a single or multiple elements at once.
     * @param {String|Object|function} str The name, id or a reference to a JSXGraph element on this board. An object will
     * be used as a filter to return multiple elements at once filtered by the properties of the object.
     * @param {Boolean} onlyByIdOrName If true (default:false) elements are only filtered by their id, name or groupId.
     * The advanced filters consisting of objects or functions are ignored.
     * @returns {JXG.GeometryElement|JXG.Composition}
     * @example
     * // select the element with name A
     * board.select('A');
     *
     * // select all elements with strokecolor set to 'red' (but not '#ff0000')
     * board.select({
     *   strokeColor: 'red'
     * });
     *
     * // select all points on or below the x axis and make them black.
     * board.select({
     *   elementClass: JXG.OBJECT_CLASS_POINT,
     *   Y (v) {
     *     return v <= 0;
     *   }
     * }).setAttribute({color: 'black'});
     *
     * // select all elements
     * board.select(function (el) {
     *   return true;
     * });
     */
    select(str, onlyByIdOrName = false) {
        var flist, olist, i, l, s = str;
        if (s === null || s === undefined) {
            throw new Error('what??'); // TODO
            // return {};   // was x
        }
        // It's a string, most likely an id or a name.
        if (Type.isString(s) && s !== '') {
            // Search by ID
            if (Type.exists(this.objects[s])) {
                s = this.objects[s];
                // Search by name
            }
            else if (Type.exists(this.elementsByName[s])) {
                s = this.elementsByName[s];
                // Search by group ID
            }
            else if (Type.exists(this.groups[s])) {
                s = this.groups[s];
            }
            // It's a function or an object, but not an element
        }
        else if (!onlyByIdOrName &&
            (Type.isFunction(s) || (Type.isObject(s) && !Type.isFunction(s.setAttribute)))) {
            flist = Type.filterElements(this.objectsList, s);
            olist = {};
            l = flist.length;
            for (i = 0; i < l; i++) {
                olist[flist[i].id] = flist[i];
            }
            // TODO  s = new Composition(olist);
            // It's an element which has been deleted (and still hangs around, e.g. in an attractor list
        }
        else if (Type.isObject(s) &&
            Type.exists(s.id) &&
            !Type.exists(this.objects[s.id])) {
            s = null;
        }
        return s;
    }
    /**
     * Checks if the given point is inside the boundingbox.
     * @param {Number|JXG.Coords} x User coordinate or {@link JXG.Coords} object.
     * @param {Number} [y] User coordinate. May be omitted in case <tt>x</tt> is a {@link JXG.Coords} object.
     * @returns {Boolean}
     */
    hasPoint(x, y) {
        var px = x, py = y, bbox = this.getBoundingBox();
        if (Type.exists(x) && Array.isArray(x.usrCoords)) {
            px = x.usrCoords[1];
            py = x.usrCoords[2];
        }
        return !!(Type.isNumber(px) &&
            Type.isNumber(py) &&
            bbox[0] < px &&
            px < bbox[2] &&
            bbox[1] > py &&
            py > bbox[3]);
    }
    /**
     * Update CSS transformations of type scaling. It is used to correct the mouse position
     * in {@link JXG.Board.getMousePosition}.
     * The inverse transformation matrix is updated on each mouseDown and touchStart event.
     *
     * It is up to the user to call this method after an update of the CSS transformation
     * in the DOM.
     */
    updateCSSTransforms() {
        var obj = this.containerObj, o = obj;
        this.cssTransMat = Env.getCSSTransformMatrix(o);
        // Newer variant of walking up the tree.
        // We walk up all parent nodes and collect possible CSS transforms.
        // Works also for ShadowDOM
        // if (Type.exists(o.getRootNode)) {
        // TODO using '.parentNode instead of .host    - how did host ever work??
        o = o.parentNode === o.getRootNode() ? o : o.parentNode;
        while (o !== o.getRootNode()) {
            console.log('o', o);
            console.log('o.getRootNode', o.getRootNode());
            console.log('o.parentNode', o.parentNode);
            this.cssTransMat = JSXMath.matMatMult(Env.getCSSTransformMatrix(o), this.cssTransMat);
            o = o === o.getRootNode() ? o : o.parentNode;
        }
        this.cssTransMat = JSXMath.inverse(this.cssTransMat);
        // } else {
        //     /*
        //      * This is necessary for IE11
        //      */
        //     o = (o.offsetParent) as HTMLElement;
        //     while (o) {
        //         this.cssTransMat = JSXMath.matMatMult(Env.getCSSTransformMatrix(o), this.cssTransMat);
        //         o2 = (o2.parentNode) as HTMLElement;
        //         while (o2 !== o) {
        //             this.cssTransMat = JSXMath.matMatMult(Env.getCSStypTransformMatrix(o), this.cssTransMat);
        //             o2 = (o2.parentNode) as HTMLElement;
        //         }
        //         o = (o.offsetParent) as HTMLElement;
        //     }
        //     this.cssTransMat = JSXMath.inverse(this.cssTransMat);
        // }
        return this;
    }
    /**
     * Start selection mode. This function can either be triggered from outside or by
     * a down event together with correct key pressing. The default keys are
     * shift+ctrl. But this can be changed in the options.
     *
     * Starting from out side can be realized for example with a button like this:
     * <pre>
     * 	&lt;button onclick='board.startSelectionMode()'&gt;Start&lt;/button&gt;
     * </pre>
     * @example
     * //
     * // Set a new bounding box from the selection rectangle
     * //
     * var board = JXG.JSXGraph.initBoard('jxgbox', {
     *         boundingBox:[-3,2,3,-2],
     *         keepAspectRatio: false,
     *         axis:true,
     *         selection: {
     *             enabled: true,
     *             needShift: false,
     *             needCtrl: true,
     *             withLines: false,
     *             vertices: {
     *                 visible: false
     *             }
     *             fillColor: '#ffff00',
     *         }
     *      });
     *
     * var f = function f(x) { return Math.cos(x); }
     *     curve = board.create('functiongraph', [f]);
     *
     * board.on('stopselecting', function(){
     *     var box = board.stopSelectionMode(),
     *
     *         // bbox has the coordinates of the selection rectangle.
     *         // Attention: box[i].usrCoords have the form [1, x, y], i.e.
     *         // are homogeneous coordinates.
     *         bbox = box[0].usrCoords.slice(1).concat(box[1].usrCoords.slice(1));
     *
     *         // Set a new bounding box
     *         board.setBoundingBox(bbox, false);
     *  });
     *
     *
     * </pre><div class='jxgbox' id='JXG11eff3a6-8c50-11e5-b01d-901b0e1b8723' style='width: 300px; height: 300px;'></div>
     * <script type='text/javascript'>
     *     (function() {
     *     //
     *     // Set a new bounding box from the selection rectangle
     *     //
     *     var board = JXG.JSXGraph.initBoard('JXG11eff3a6-8c50-11e5-b01d-901b0e1b8723', {
     *             boundingBox:[-3,2,3,-2],
     *             keepAspectRatio: false,
     *             axis:true,
     *             selection: {
     *                 enabled: true,
     *                 needShift: false,
     *                 needCtrl: true,
     *                 withLines: false,
     *                 vertices: {
     *                     visible: false
     *                 }
     *                 fillColor: '#ffff00',
     *             }
     *        });
     *
     *     var f = function f(x) { return Math.cos(x); }
     *         curve = board.create('functiongraph', [f]);
     *
     *     board.on('stopselecting', function(){
     *         var box = board.stopSelectionMode(),
     *
     *             // bbox has the coordinates of the selection rectangle.
     *             // Attention: box[i].usrCoords have the form [1, x, y], i.e.
     *             // are homogeneous coordinates.
     *             bbox = box[0].usrCoords.slice(1).concat(box[1].usrCoords.slice(1));
     *
     *             // Set a new bounding box
     *             board.setBoundingBox(bbox, false);
     *      });
     *     })();
     *
     * </script><pre>
     *
     */
    startSelectionMode() {
        this.selectingMode = true;
        this.selectionPolygon.setAttribute({ visible: true });
        this.selectingBox = [
            [0, 0],
            [0, 0]
        ];
        this._setSelectionPolygonFromBox();
        this.selectionPolygon.fullUpdate();
    }
    /**
     * Finalize the selection: disable selection mode and return the coordinates
     * of the selection rectangle.
     * @returns {Array} Coordinates of the selection rectangle. The array
     * contains two {@link JXG.Coords} objects. One the upper left corner and
     * the second for the lower right corner.
     */
    stopSelectionMode() {
        this.selectingMode = false;
        this.selectionPolygon.setAttribute({ visible: false });
        return [
            this.selectionPolygon.vertices[0].coords,
            this.selectionPolygon.vertices[2].coords
        ];
    }
    /**
     * Start the selection of a region.
     * @private
     * @param  {Array} pos Screen coordiates of the upper left corner of the
     * selection rectangle.
     */
    _startSelecting(pos) {
        this.isSelecting = true;
        this.selectingBox = [
            [pos[0], pos[1]],
            [pos[0], pos[1]]
        ];
        this._setSelectionPolygonFromBox();
    }
    /**
     * Update the selection rectangle during a move event.
     * @private
     * @param  {Array} pos Screen coordiates of the move event
     */
    _moveSelecting(pos) {
        if (this.isSelecting) {
            this.selectingBox[1] = [pos[0], pos[1]];
            this._setSelectionPolygonFromBox();
            this.selectionPolygon.fullUpdate();
        }
    }
    /**
     * Update the selection rectangle during an up event. Stop selection.
     * @private
     * @param  {Object} evt Event object
     */
    _stopSelecting(evt) {
        var pos = this.getMousePosition(evt);
        this.isSelecting = false;
        this.selectingBox[1] = [pos[0], pos[1]];
        this._setSelectionPolygonFromBox();
    }
    /**
     * Update the Selection rectangle.
     * @private
     */
    _setSelectionPolygonFromBox() {
        var A = this.selectingBox[0], B = this.selectingBox[1];
        this.selectionPolygon.vertices[0].setPositionDirectly(COORDS_BY.SCREEN, [
            A[0],
            A[1]
        ]);
        this.selectionPolygon.vertices[1].setPositionDirectly(COORDS_BY.SCREEN, [
            A[0],
            B[1]
        ]);
        this.selectionPolygon.vertices[2].setPositionDirectly(COORDS_BY.SCREEN, [
            B[0],
            B[1]
        ]);
        this.selectionPolygon.vertices[3].setPositionDirectly(COORDS_BY.SCREEN, [
            B[0],
            A[1]
        ]);
    }
    /**
     * Test if a down event should start a selection. Test if the
     * required keys are pressed. If yes, {@link JXG.Board.startSelectionMode} is called.
     * @param  {Object} evt Event object
     */
    _testForSelection(evt) {
        if (this._isRequiredKeyPressed(evt, 'selection')) {
            if (!Type.exists(this.selectionPolygon)) {
                this._createSelectionPolygon(this.attr);
            }
            this.startSelectionMode();
        }
    }
    /**
     * Create the internal selection polygon, which will be available as board.selectionPolygon.
     * @private
     * @param  {Object} attr board attributes, e.g. the subobject board.attr.
     * @returns {Object} pointer to the board to enable chaining.
     */
    _createSelectionPolygon(attr) {
        var selectionattr;
        if (!Type.exists(this.selectionPolygon)) {
            selectionattr = Type.copyAttributes(attr, Options, 'board', 'selection');
            if (selectionattr.enabled === true) {
                this.selectionPolygon = this.create('polygon', [
                    [0, 0],
                    [0, 0],
                    [0, 0],
                    [0, 0]
                ], selectionattr);
            }
        }
        return this;
    }
    /* **************************
     *     EVENT DEFINITION
     * for documentation purposes
     * ************************** */
    //region Event handler documentation
    /**
     * @event
     * @description Whenever the {@link JXG.Board#setAttribute} is called.
     * @name JXG.Board#attribute
     * @param {Event} e The browser's event object.
     */
    __evt__attribute(e) { }
    /**
     * @event
     * @description Whenever the user starts to touch or click the board.
     * @name JXG.Board#down
     * @param {Event} e The browser's event object.
     */
    __evt__down(e) { }
    /**
     * @event
     * @description Whenever the user starts to click on the board.
     * @name JXG.Board#mousedown
     * @param {Event} e The browser's event object.
     */
    __evt__mousedown(e) { }
    /**
     * @event
     * @description Whenever the user taps the pen on the board.
     * @name JXG.Board#pendown
     * @param {Event} e The browser's event object.
     */
    __evt__pendown(e) { }
    /**
     * @event
     * @description Whenever the user starts to click on the board with a
     * device sending pointer events.
     * @name JXG.Board#pointerdown
     * @param {Event} e The browser's event object.
     */
    __evt__pointerdown(e) { }
    /**
     * @event
     * @description Whenever the user starts to touch the board.
     * @name JXG.Board#touchstart
     * @param {Event} e The browser's event object.
     */
    __evt__touchstart(e) { }
    /**
     * @event
     * @description Whenever the user stops to touch or click the board.
     * @name JXG.Board#up
     * @param {Event} e The browser's event object.
     */
    __evt__up(e) { }
    /**
     * @event
     * @description Whenever the user releases the mousebutton over the board.
     * @name JXG.Board#mouseup
     * @param {Event} e The browser's event object.
     */
    __evt__mouseup(e) { }
    /**
     * @event
     * @description Whenever the user releases the mousebutton over the board with a
     * device sending pointer events.
     * @name JXG.Board#pointerup
     * @param {Event} e The browser's event object.
     */
    __evt__pointerup(e) { }
    /**
     * @event
     * @description Whenever the user stops touching the board.
     * @name JXG.Board#touchend
     * @param {Event} e The browser's event object.
     */
    __evt__touchend(e) { }
    /**
     * @event
     * @description Whenever the user clicks on the board.
     * @name JXG.Board#click
     * @see JXG.Board#clickDelay
     * @param {Event} e The browser's event object.
     */
    __evt__click(e) { }
    /**
     * @event
     * @description Whenever the user double clicks on the board.
     * This event works on desktop browser, but is undefined
     * on mobile browsers.
     * @name JXG.Board#dblclick
     * @see JXG.Board#clickDelay
     * @see JXG.Board#dblClickSuppressClick
     * @param {Event} e The browser's event object.
     */
    __evt__dblclick(e) { }
    /**
     * @event
     * @description Whenever the user clicks on the board with a mouse device.
     * @name JXG.Board#mouseclick
     * @param {Event} e The browser's event object.
     */
    __evt__mouseclick(e) { }
    /**
     * @event
     * @description Whenever the user double clicks on the board with a mouse device.
     * @name JXG.Board#mousedblclick
     * @see JXG.Board#clickDelay
     * @param {Event} e The browser's event object.
     */
    __evt__mousedblclick(e) { }
    /**
     * @event
     * @description Whenever the user clicks on the board with a pointer device.
     * @name JXG.Board#pointerclick
     * @param {Event} e The browser's event object.
     */
    __evt__pointerclick(e) { }
    /**
     * @event
     * @description Whenever the user double clicks on the board with a pointer device.
     * This event works on desktop browser, but is undefined
     * on mobile browsers.
     * @name JXG.Board#pointerdblclick
     * @see JXG.Board#clickDelay
     * @param {Event} e The browser's event object.
     */
    __evt__pointerdblclick(e) { }
    /**
     * @event
     * @description This event is fired whenever the user is moving the finger or mouse pointer over the board.
     * @name JXG.Board#move
     * @param {Event} e The browser's event object.
     * @param {Number} mode The mode the board currently is in
     * @see JXG.Board#mode
     */
    __evt__move(e, mode) { }
    /**
     * @event
     * @description This event is fired whenever the user is moving the mouse over the board.
     * @name JXG.Board#mousemove
     * @param {Event} e The browser's event object.
     * @param {Number} mode The mode the board currently is in
     * @see JXG.Board#mode
     */
    __evt__mousemove(e, mode) { }
    /**
     * @event
     * @description This event is fired whenever the user is moving the pen over the board.
     * @name JXG.Board#penmove
     * @param {Event} e The browser's event object.
     * @param {Number} mode The mode the board currently is in
     * @see JXG.Board#mode
     */
    __evt__penmove(e, mode) { }
    /**
     * @event
     * @description This event is fired whenever the user is moving the mouse over the board with a
     * device sending pointer events.
     * @name JXG.Board#pointermove
     * @param {Event} e The browser's event object.
     * @param {Number} mode The mode the board currently is in
     * @see JXG.Board#mode
     */
    __evt__pointermove(e, mode) { }
    /**
     * @event
     * @description This event is fired whenever the user is moving the finger over the board.
     * @name JXG.Board#touchmove
     * @param {Event} e The browser's event object.
     * @param {Number} mode The mode the board currently is in
     * @see JXG.Board#mode
     */
    __evt__touchmove(e, mode) { }
    /**
     * @event
     * @description This event is fired whenever the user is moving an element over the board by
     * pressing arrow keys on a keyboard.
     * @name JXG.Board#keymove
     * @param {Event} e The browser's event object.
     * @param {Number} mode The mode the board currently is in
     * @see JXG.Board#mode
     */
    __evt__keymove(e, mode) { }
    /**
     * @event
     * @description Whenever an element is highlighted this event is fired.
     * @name JXG.Board#hit
     * @param {Event} e The browser's event object.
     * @param {JXG.GeometryElement} el The hit element.
     * @param target
     *
     * @example
     * var c = board.create('circle', [[1, 1], 2]);
     * board.on('hit', function(evt, el) {
     *     console.log('Hit element', el);
     * });
     *
     * </pre><div id='JXG19eb31ac-88e6-11e8-bcb5-901b0e1b8723' class='jxgbox' style='width: 300px; height: 300px;'></div>
     * <script type='text/javascript'>
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG19eb31ac-88e6-11e8-bcb5-901b0e1b8723',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var c = board.create('circle', [[1, 1], 2]);
     *     board.on('hit', function(evt, el) {
     *         console.log('Hit element', el);
     *     });
     *
     *     })();
     *
     * </script><pre>
     */
    __evt__hit(e, el, target) { }
    /**
     * @event
     * @description Whenever an element is highlighted this event is fired.
     * @name JXG.Board#mousehit
     * @see JXG.Board#hit
     * @param {Event} e The browser's event object.
     * @param {JXG.GeometryElement} el The hit element.
     * @param target
     */
    __evt__mousehit(e, el, target) { }
    /**
     * @event
     * @description This board is updated.
     * @name JXG.Board#update
     */
    __evt__update() { }
    /**
     * @event
     * @description The bounding box of the board has changed.
     * @name JXG.Board#boundingbox
     */
    __evt__boundingbox() { }
    /**
     * @event
     * @description Select a region is started during a down event or by calling
     * {@link JXG.Board.startSelectionMode}
     * @name JXG.Board#startselecting
     */
    __evt__startselecting() { }
    /**
     * @event
     * @description Select a region is started during a down event
     * from a device sending mouse events or by calling
     * {@link JXG.Board.startSelectionMode}.
     * @name JXG.Board#mousestartselecting
     */
    __evt__mousestartselecting() { }
    /**
     * @event
     * @description Select a region is started during a down event
     * from a device sending pointer events or by calling
     * {@link JXG.Board.startSelectionMode}.
     * @name JXG.Board#pointerstartselecting
     */
    __evt__pointerstartselecting() { }
    /**
     * @event
     * @description Select a region is started during a down event
     * from a device sending touch events or by calling
     * {@link JXG.Board.startSelectionMode}.
     * @name JXG.Board#touchstartselecting
     */
    __evt__touchstartselecting() { }
    /**
     * @event
     * @description Selection of a region is stopped during an up event.
     * @name JXG.Board#stopselecting
     */
    __evt__stopselecting() { }
    /**
     * @event
     * @description Selection of a region is stopped during an up event
     * from a device sending mouse events.
     * @name JXG.Board#mousestopselecting
     */
    __evt__mousestopselecting() { }
    /**
     * @event
     * @description Selection of a region is stopped during an up event
     * from a device sending pointer events.
     * @name JXG.Board#pointerstopselecting
     */
    __evt__pointerstopselecting() { }
    /**
     * @event
     * @description Selection of a region is stopped during an up event
     * from a device sending touch events.
     * @name JXG.Board#touchstopselecting
     */
    __evt__touchstopselecting() { }
    /**
     * @event
     * @description A move event while selecting of a region is active.
     * @name JXG.Board#moveselecting
     */
    __evt__moveselecting() { }
    /**
     * @event
     * @description A move event while selecting of a region is active
     * from a device sending mouse events.
     * @name JXG.Board#mousemoveselecting
     */
    __evt__mousemoveselecting() { }
    /**
     * @event
     * @description Select a region is started during a down event
     * from a device sending mouse events.
     * @name JXG.Board#pointermoveselecting
     */
    __evt__pointermoveselecting() { }
    /**
     * @event
     * @description Select a region is started during a down event
     * from a device sending touch events.
     * @name JXG.Board#touchmoveselecting
     */
    __evt__touchmoveselecting() { }
    /**
     * @ignore
     */
    __evt() { }
    //endregion
    /**
     * Expand the JSXGraph construction to fullscreen.
     * In order to preserve the proportions of the JSXGraph element,
     * a wrapper div is created which is set to fullscreen.
     * This function is called when fullscreen mode is triggered
     * <b>and</b> when it is closed.
     * <p>
     * The wrapping div has the CSS class 'jxgbox_wrap_private' which is
     * defined in the file 'jsxgraph.css'
     * <p>
     * This feature is not available on iPhones (as of December 2021).
     *
     * @param {String} id (Optional) id of the div element which is brought to fullscreen.
     * If not provided, this defaults to the JSXGraph div. However, it may be necessary for the aspect ratio trick
     * which using padding-bottom/top and an out div element. Then, the id of the outer div has to be supplied.
     *
     * @return {JXG.Board} Reference to the board
     *
     * @example
     * &lt;div id='jxgbox' class='jxgbox' style='width:500px; height:200px;'&gt;&lt;/div&gt;
     * &lt;button onClick='board.toFullscreen()'&gt;Fullscreen&lt;/button&gt;
     *
     * &lt;script language='Javascript' type='text/javascript'&gt;
     * var board = JXG.JSXGraph.initBoard('jxgbox', {axis:true, boundingbox:[-5,5,5,-5]});
     * var p = board.create('point', [0, 1]);
     * &lt;/script&gt;
     *
     * </pre><div id='JXGd5bab8b6-fd40-11e8-ab14-901b0e1b8723' class='jxgbox' style='width: 300px; height: 300px;'></div>
     * <script type='text/javascript'>
     *      var board_d5bab8b6;
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGd5bab8b6-fd40-11e8-ab14-901b0e1b8723',
     *             {boundingbox:[-5,5,5,-5], axis: true, showcopyright: false, shownavigation: false});
     *         var p = board.create('point', [0, 1]);
     *         board_d5bab8b6 = board;
     *     })();
     * </script>
     * <button onClick='board_d5bab8b6.toFullscreen()'>Fullscreen</button>
     * <pre>
     *
     * @example
     * &lt;div id='outer' style='max-width: 500px; margin: 0 auto;'&gt;
     * &lt;div id='jxgbox' class='jxgbox' style='height: 0; padding-bottom: 100%'&gt;&lt;/div&gt;
     * &lt;/div&gt;
     * &lt;button onClick='board.toFullscreen('outer')'&gt;Fullscreen&lt;/button&gt;
     *
     * &lt;script language='Javascript' type='text/javascript'&gt;
     * var board = JXG.JSXGraph.initBoard('jxgbox', {
     *     axis:true,
     *     boundingbox:[-5,5,5,-5],
     *     fullscreen: { id: 'outer' }
     *     showFullscreen: true
     * });
     * var p = board.create('point', [-2, 3], {});
     * &lt;/script&gt;
     *
     * </pre><div id='JXG7103f6b_outer' style='max-width: 500px; margin: 0 auto;'>
     * <div id='JXG7103f6be-6993-4ff8-8133-c78e50a8afac' class='jxgbox' style='height: 0; padding-bottom: 100%;'></div>
     * </div>
     * <button onClick='board_JXG7103f6be.toFullscreen('JXG7103f6b_outer')'>Fullscreen</button>
     * <script type='text/javascript'>
     *     var board_JXG7103f6be;
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG7103f6be-6993-4ff8-8133-c78e50a8afac',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, fullscreen: { id: 'JXG7103f6b_outer' } showFullscreen: true,
     *              showcopyright: false, shownavigation: false});
     *     var p = board.create('point', [-2, 3], {});
     *     board_JXG7103f6be = board;
     *     })();
     *
     * </script><pre>
     *
     *
     */
    toFullscreen(id) {
        var wrap_id, wrap_node, inner_node, dim, doc = this.document, fullscreenElement;
        id = id || this.container;
        this._fullscreen_inner_id = id;
        inner_node = doc.getElementById(id);
        wrap_id = 'fullscreenwrap_' + id;
        if (!Type.exists(inner_node._cssFullscreenStore)) {
            // Store the actual, absolute size of the div
            // This is used in scaleJSXGraphDiv
            dim = this.containerObj.getBoundingClientRect();
            inner_node._cssFullscreenStore = {
                w: dim.width,
                h: dim.height
            };
        }
        // Wrap a div around the JSXGraph div.
        // It is removed when fullscreen mode is closed.
        if (doc.getElementById(wrap_id)) {
            wrap_node = doc.getElementById(wrap_id);
        }
        else {
            wrap_node = document.createElement('div');
            wrap_node.classList.add('JXG_wrap_private');
            wrap_node.setAttribute('id', wrap_id);
            inner_node.parentNode.insertBefore(wrap_node, inner_node);
            wrap_node.appendChild(inner_node);
        }
        // Trigger fullscreen mode
        wrap_node.requestFullscreen =
            wrap_node.requestFullscreen ||
                wrap_node.webkitRequestFullscreen ||
                wrap_node.mozRequestFullScreen ||
                wrap_node.msRequestFullscreen;
        if (doc.fullscreenElement !== undefined) {
            fullscreenElement = doc.fullscreenElement;
        }
        if (fullscreenElement === null) {
            // Start fullscreen mode
            if (wrap_node.requestFullscreen) {
                wrap_node.requestFullscreen();
                this.startFullscreenResizeObserver(wrap_node);
            }
        }
        else {
            this.stopFullscreenResizeObserver(wrap_node);
            if (Type.exists(document.exitFullscreen)) {
                document.exitFullscreen();
            }
            else if (Type.exists(document.exitFullscreen)) {
                document.exitFullscreen();
            }
        }
        return this;
    }
    /**
     * If fullscreen mode is toggled, the possible CSS transformations
     * which are applied to the JSXGraph canvas have to be reread.
     * Otherwise the position of upper left corner is wrongly interpreted.
     *
     * @param  {Object} evt fullscreen event object (unused)
     */
    fullscreenListener(evt) {
        var inner_id, inner_node, fullscreenElement, doc = this.document;
        inner_id = this._fullscreen_inner_id;
        if (!Type.exists(inner_id)) {
            return;
        }
        if (doc.fullscreenElement !== undefined) {
            fullscreenElement = doc.fullscreenElement;
        }
        inner_node = doc.getElementById(inner_id);
        // If full screen mode is started we have to remove CSS margin around the JSXGraph div.
        // Otherwise, the positioning of the fullscreen div will be false.
        // When leaving the fullscreen mode, the margin is put back in.
        if (fullscreenElement) {
            // Just entered fullscreen mode
            // Store the original data.
            // Further, the CSS margin has to be removed when in fullscreen mode,
            // and must be restored later.
            //
            // Obsolete:
            // It is used in AbstractRenderer.updateText to restore the scaling matrix
            // which is removed by MathJax.
            inner_node._cssFullscreenStore.id = fullscreenElement.id;
            inner_node._cssFullscreenStore.isFullscreen = true;
            inner_node._cssFullscreenStore.margin = inner_node.style.margin;
            inner_node._cssFullscreenStore.width = inner_node.style.width;
            inner_node._cssFullscreenStore.height = inner_node.style.height;
            inner_node._cssFullscreenStore.transform = inner_node.style.transform;
            // Be sure to replace relative width / height units by absolute units
            inner_node.style.width = inner_node._cssFullscreenStore.w + 'px';
            inner_node.style.height = inner_node._cssFullscreenStore.h + 'px';
            inner_node.style.margin = '';
            // Do the shifting and scaling via CSS properties
            // We do this after fullscreen mode has been established to get the correct size
            // of the JSXGraph div.
            Env.scaleJSXGraphDiv(fullscreenElement.id, inner_id, doc, Type.evaluate(this.attr.fullscreen.scale));
            // Clear this.doc.fullscreenElement, because Safari doesn't to it and
            // when leaving full screen mode it is still set.
            fullscreenElement = null;
        }
        else if (Type.exists(inner_node._cssFullscreenStore)) {
            // Just left the fullscreen mode
            inner_node._cssFullscreenStore.isFullscreen = false;
            inner_node.style.margin = inner_node._cssFullscreenStore.margin;
            inner_node.style.width = inner_node._cssFullscreenStore.width;
            inner_node.style.height = inner_node._cssFullscreenStore.height;
            inner_node.style.transform = inner_node._cssFullscreenStore.transform;
            inner_node._cssFullscreenStore = null;
            // Remove the wrapper div
            inner_node.parentElement.replaceWith(inner_node);
        }
        this.updateCSSTransforms();
    }
    /**
     * Start resize observer to handle
     * orientation changes in fullscreen mode.
     *
     * @param {Object} node DOM object which is in fullscreen mode. It is the wrapper element
     * around the JSXGraph div.
     * @returns {JXG.Board} Reference to the board
     * @private
     * @see JXG.Board#toFullscreen
     *
     */
    startFullscreenResizeObserver(node) {
        let that = this;
        if (!Env.isBrowser || !this.attr.resize || !this.attr.resize.enabled) {
            return this;
        }
        this.resizeObserver = new ResizeObserver(function (entries) {
            var inner_id, fullscreenElement, doc = that.document;
            if (!that._isResizing) {
                that._isResizing = true;
                window.setTimeout(function () {
                    try {
                        inner_id = that._fullscreen_inner_id;
                        if (doc.fullscreenElement !== undefined) {
                            fullscreenElement = doc.fullscreenElement;
                        }
                        else if (doc.fullscreenElement !== undefined) {
                            fullscreenElement = doc.fullscreenElement;
                        }
                        else {
                            fullscreenElement = doc.fullscreenElement;
                        }
                        if (fullscreenElement !== null) {
                            Env.scaleJSXGraphDiv(fullscreenElement.id, inner_id, doc, Type.evaluate(that.attr.fullscreen.scale));
                        }
                    }
                    catch (err) {
                        that.stopFullscreenResizeObserver(node);
                    }
                    finally {
                        that._isResizing = false;
                    }
                }, that.attr.resize.throttle);
            }
        });
        this.resizeObserver.observe(node);
        return this;
    }
    /**
     * Remove resize observer to handle orientation changes in fullscreen mode.
     * @param {Object} node DOM object which is in fullscreen mode. It is the wrapper element
     * around the JSXGraph div.
     * @returns {JXG.Board} Reference to the board
     * @private
     * @see JXG.Board#toFullscreen
     */
    stopFullscreenResizeObserver(node) {
        if (!Env.isBrowser || !this.attr.resize || !this.attr.resize.enabled) {
            return this;
        }
        if (Type.exists(this.resizeObserver)) {
            this.resizeObserver.unobserve(node);
        }
        return this;
    }
    /**
     * Add user activity to the array 'board.userLog'.
     *
     * @param {String} type Event type, e.g. 'drag'
     * @param {Object} obj JSXGraph element object
     *
     * @see JXG.Board#userLog
     * @return {JXG.Board} Reference to the board
     */
    addLogEntry(type, obj, pos) {
        var t, id, last = this.userLog.length - 1;
        if (Type.exists(obj.elementClass)) {
            id = obj.id;
        }
        if (Type.evaluate(this.attr.logging.enabled)) {
            t = (new Date()).getTime();
            if (last >= 0 &&
                this.userLog[last].type === type &&
                this.userLog[last].id === id &&
                // Distinguish consecutive drag events of
                // the same element
                t - this.userLog[last].end < 500) {
                this.userLog[last].end = t;
                this.userLog[last].endpos = pos;
            }
            else {
                this.userLog.push({
                    type: type,
                    id: id,
                    start: t,
                    startpos: pos,
                    end: t,
                    endpos: pos,
                    bbox: this.getBoundingBox(),
                    canvas: [this.canvasWidth, this.canvasHeight],
                    zoom: [this.zoomX, this.zoomY]
                });
            }
        }
        return this;
    }
}

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Andreas Walter,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */
/*global JXG: true, define: true, html_sanitize: true*/
/*jslint nomen: true, plusplus: true*/
/**
 * @fileoverview type.js contains several functions to help deal with javascript's weak types.
 * This file mainly consists of detector functions which verify if a variable is or is not of
 * a specific type and converter functions that convert variables to another type or normalize
 * the type of a variable.
 */
/*
* In TypeScript, the concept of a "static class" as it exists in languages like C# (where you explicitly
* declare a class with the static keyword) does not directly apply. In TypeScript (and JavaScript), you
* cannot declare an entire class as static.
*
 * Instead, you achieve a similar effect by making all members (properties and methods) within a class
 * static. This means that these members belong to the class itself, rather than to instances of the class.
 * You can then access these members directly using the class name, without needing to create an object from
 * the class.
 *
 * Type is a static class
*/
// TS has strong types - get rid of whatever we can
// import { HtmlSanitizer } from './htmlsanitizer.js';
class Type {
    /**
     * Checks if the given object is an JSXGraph board.
     * @param {Object} v
     * @returns {Boolean}
     */
    static isBoard(v) {
        return (v instanceof Board);
        //     this.isObject(v) &&
        //     this.isNumber(v.BOARD_MODE_NONE) &&
        //     this.isObject(v.objects) &&
        //     this.isObject(v.jc) &&
        //     this.isFunction(v.update) &&
        //     !!v.containerObj &&
        //     this.isString(v.id)
        // );
    }
    /**
     * Checks if the given string is an id within the given board.
     * @param {JXG.Board} board
     * @param {String} s
     * @returns {Boolean}
     */
    static isId(board, s) {
        return typeof s === 'string' && !!board.objects[s];
    }
    /**
     * Checks if the given string is a name within the given board.
     * @param {JXG.Board} board
     * @param {String} s
     * @returns {Boolean}
     */
    static isName(board, s) {
        return typeof s === 'string' && !!board.elementsByName[s];
    }
    /**
     * Checks if the given string is a group id within the given board.
     * @param {JXG.Board} board
     * @param {String} s
     * @returns {Boolean}
     */
    static isGroup(board, s) {
        return typeof s === 'string' && !!board.groups[s];
    }
    /**
     * Checks if the value of a given variable is of type string.
     * @param v A variable of any type.
     * @returns {Boolean} True, if v is of type string.
     */
    static isString(v) {
        return typeof v === 'string';
    }
    /**
     * Checks if the value of a given variable is of type number.
     * @param v A variable of any type.
     * @param {Boolean} [acceptStringNumber=false] If set to true, the function returns true for e.g. v='3.1415'.
     * @param {Boolean} [acceptNaN=true] If set to false, the function returns false for v=NaN.
     * @returns {Boolean} True, if v is of type number.
     */
    static isNumber(v, acceptStringNumber = false, acceptNaN = true) {
        var result = typeof v === 'number' ||
            Object.prototype.toString.call(v) === '[Object Number]';
        if (acceptStringNumber) {
            result = result || '' + parseFloat(v) === v;
        }
        if (!acceptNaN) {
            result = result && !isNaN(v);
        }
        return result;
    }
    /**
     * Checks if a given variable references a function.
     * @param v A variable of any type.
     * @returns {Boolean} True, if v is a function.
     */
    static isFunction(v) {
        return typeof v === 'function';
    }
    /**
     * Tests if the input variable is an Object
     * @param v
     */
    static isObject(v) {
        // return typeof v === 'object' && !Array.isArray(v);
        return typeof v === 'object' && !Array.isArray(v) && v !== null;
    }
    /**
     * Tests if the input variable is a DOM Document or DocumentFragment node
     * @param v A variable of any type
     */
    static isDocumentOrFragment(v) {
        return (this.isObject(v) &&
            (v.nodeType === Node.DOCUMENT_NODE ||
                v.nodeType === Node.DOCUMENT_FRAGMENT_NODE));
    }
    /**
     * Checks if a given variable is a reference of a JSXGraph Point element.
     * @param v A variable of any type.
     * @returns {Boolean} True, if v is of type JXG.Point.
     */
    static isPoint(v) {
        if (v !== null && typeof v === 'object' && Type.exists(v.elementClass)) {
            return v.elementClass === OBJECT_CLASS.POINT;
        }
        return false;
    }
    /**
     * Checks if a given variable is a reference of a JSXGraph Point3D element.
     * @param v A variable of any type.
     * @returns {Boolean} True, if v is of type JXG.Point3D.
     */
    static isPoint3D(v) {
        if (v !== null && typeof v === 'object' && Type.exists(v.type)) {
            return v.type === OBJECT_TYPE.POINT3D;
        }
        return false;
    }
    /**
     * Checks if a given variable is a reference of a JSXGraph Point element or an array of length at least two or
     * a function returning an array of length two or three.
     * @param {JXG.Board} board
     * @param v A variable of any type.
     * @returns {Boolean} True, if v is of type JXG.Point.
     */
    static isPointType(board, v) {
        var val, p;
        if (Array.isArray(v)) {
            return true;
        }
        if (typeof v === 'function') {
            val = v();
            if (Array.isArray(val) && val.length > 1) {
                return true;
            }
        }
        p = board.select(v);
        return this.isPoint(p);
    }
    /**
     * Checks if a given variable is a reference of a JSXGraph Point3D element or an array of length three
     * or a function returning an array of length three.
     * @param {JXG.Board} board
     * @param v A variable of any type.
     * @returns {Boolean} True, if v is of type JXG.Point3D or an array of length at least 3, or a function returning
     * such an array.
     */
    static isPointType3D(board, v) {
        var val, p;
        if (Array.isArray(v) && v.length >= 3) {
            return true;
        }
        if (typeof v === 'function') {
            val = v();
            if (Array.isArray(val) && val.length >= 3) {
                return true;
            }
        }
        p = board.select(v);
        return this.isPoint3D(p);
    }
    /**
     * Checks if a given variable is a reference of a JSXGraph transformation element or an array
     * of JSXGraph transformation elements.
     * @param v A variable of any type.
     * @returns {Boolean} True, if v is of type JXG.Transformation.
     */
    static isTransformationOrArray(v) {
        if (v !== null) {
            if (Array.isArray(v) && v.length > 0) {
                return this.isTransformationOrArray(v[0]);
            }
            if (typeof v === 'object') {
                return v.type === OBJECT_TYPE.TRANSFORMATION;
            }
        }
        return false;
    }
    /**
     * Checks if v is an empty object or empty.
     * @param v {Object|Array}
     * @returns {boolean} True, if v is an empty object or array.
     */
    static isEmpty(v) {
        return Object.keys(v).length === 0;
    }
    /**
     * Checks if a given variable is neither undefined nor null. You should not use this together with global
     * variables!
     * @param v A variable of any type.
     * @param {Boolean} [checkEmptyString=false] If set to true, it is also checked whether v is not equal to ''.
     * @returns {Boolean} True, if v is neither undefined nor null.
     */
    static exists(v, checkEmptyString = false) {
        /* eslint-disable eqeqeq */
        var result = !(v == undefined || v === null);
        if (checkEmptyString) {
            return result && v !== '';
        }
        return result;
    }
    // exists: (function (undef) {
    //     return function (v, checkEmptyString) {
    //         var result = !(v === undef || v === null);
    //         checkEmptyString = checkEmptyString || false;
    //         if (checkEmptyString) {
    //             return result && v !== '';
    //         }
    //         return result;
    //     };
    // }()),
    /**
     * Handle default parameters.
     * @param v Given value
     * @param d Default value
     * @returns <tt>d</tt>, if <tt>v</tt> is undefined or null.
     */
    static def(v, d) {
        if (Type.exists(v)) {
            return v;
        }
        return d;
    }
    /**
     * Converts a string containing either <strong>true</strong> or <strong>false</strong> into a boolean value.
     * @param {String} s String containing either <strong>true</strong> or <strong>false</strong>.
     * @returns {Boolean} String typed boolean value converted to boolean.
     */
    static str2Bool(s) {
        if (!Type.exists(s)) {
            return true;
        }
        if (typeof s === 'boolean') {
            return s;
        }
        if (this.isString(s)) {
            return s.toLowerCase() === 'true';
        }
        return false;
    }
    /**
     * Converts a given CSS style string into a JavaScript object.
     * @param {String} styles String containing CSS styles.
     * @returns {Object} Object containing CSS styles.
     */
    static cssParse(styles) {
        var str = styles;
        if (!this.isString(str))
            return {};
        str = str.replace(/\s*;\s*$/g, '');
        str = str.replace(/\s*;\s*/g, '","');
        str = str.replace(/\s*:\s*/g, '":"');
        str = str.trim();
        str = '{"' + str + '"}';
        return JSON.parse(str);
    }
    /**
     * Converts a given object into a CSS style string.
     * @param {Object} styles Object containing CSS styles.
     * @returns {String} String containing CSS styles.
     */
    static cssStringify(styles) {
        var str = '', attr, val;
        if (!this.isObject(styles))
            return '';
        for (attr in styles) {
            if (!styles.hasOwnProperty(attr))
                continue;
            val = styles[attr];
            if (!this.isString(val) && !this.isNumber(val))
                continue;
            str += attr + ':' + val + '; ';
        }
        str = str.trim();
        return str;
    }
    // only used by transformations, move it there if necessary
    // /**
    //  * Convert a String, a number or a function into a function. This method is used in Transformation.js
    //  * @param {JXG.Board} board Reference to a JSXGraph board. It is required to resolve dependencies given
    //  * by a JessieCode string, thus it must be a valid reference only in case one of the param
    //  * values is of type string.
    //  * @param {Array} param An array containing strings, numbers, or functions.
    //  * @param {Number} n Length of <tt>param</tt>.
    //  * @returns {Function} A function taking one parameter k which specifies the index of the param element
    //  * to evaluate.
    //  */
    // static createEvalFunction(board, param, n):Function {
    //     var f: Function[] = [],
    //         func,
    //         i,
    //         e,
    //         deps = {};
    //     for (i = 0; i < n; i++) {
    //         f[i] = this.createFunction(param[i], board);
    //         for (e in f[i]["deps"]) {
    //             deps[e] = f[i]["deps"]   // was f[i].deps;
    //         }
    //     }
    //     func = function (k) {
    //         return f[k]();
    //     };
    //     func.deps = deps;
    //     return func;
    // }
    /**
     * Convert a String, number or function into a function.
     * @param {String|Number|Function} term A variable of type string, function or number.
     * @param {JXG.Board} board Reference to a JSXGraph board. It is required to resolve dependencies given
     * by a JessieCode/GEONE<sub>X</sub>T string, thus it must be a valid reference only in case one of the param
     * values is of type string.
     * @param {String} variableName Only required if function is supplied as JessieCode string or evalGeonext is set to true.
     * Describes the variable name of the variable in a JessieCode/GEONE<sub>X</sub>T string given as term.
     * @param {Boolean} [evalGeonext=false] Obsolete and ignored! Set this true
     * if term should be treated as a GEONE<sub>X</sub>T string.
     * @returns {Function} A function evaluating the value given by term or null if term is not of type string,
     * function or number.
     */
    static createFunction(term, board, variableName) {
        console.error('what do we use this for (other than jessiecode)?');
        let f = () => { }; // default empty function
        return f;
        // if (typeof term === 'function'){
        //     f = term;
        //         f.deps = this.isObject(term.deps) ? term.deps : {};
        // } else if (this.isNumber(term) || Array.isArray(term)) {
        //     /** @ignore */
        //     f = function () {
        //         return term;
        //     };
        //     f.deps = {};
        //     // } else if (this.isString(term)) {
        //     //     // In case of string function like fontsize
        //     //     /** @ignore */
        //     //     f = function () { return term; };
        //     //     f.deps = {};
        // }
        // if (f !== null) {
        //     f.origin = term;
        // }
        // return f;
    }
    /**
     *  Test if the parents array contains existing points. If instead parents contains coordinate arrays or
     *  function returning coordinate arrays
     *  free points with these coordinates are created.
     *
     * @param {JXG.Board} board Board object
     * @param {Array} parents Array containing parent elements for a new object. This array may contain
     *    <ul>
     *      <li> {@link JXG.Point} objects
     *      <li> {@link JXG.GeometryElement#name} of {@link JXG.Point} objects
     *      <li> {@link JXG.GeometryElement#id} of {@link JXG.Point} objects
     *      <li> Coordinates of points given as array of numbers of length two or three, e.g. [2, 3].
     *      <li> Coordinates of points given as array of functions of length two or three. Each function returns one coordinate, e.g.
     *           [function(){ return 2; } function(){ return 3; }]
     *      <li> Function returning coordinates, e.g. function() { return [2, 3]; }
     *    </ul>
     *  In the last three cases a new point will be created.
     * @param {String} attrClass Main attribute class of newly created points, see {@link JXG#copyAttributes}
     * @param {Array} attrArray List of subtype attributes for the newly created points. The list of subtypes is mapped to the list of new points.
     * @returns {Array} List of newly created {@link JXG.Point} elements or false if not all returned elements are points.
     */
    // static providePoints(board, parents, attributes, attrClass, attrArray) {
    //     var i,
    //         j,
    //         len,
    //         lenAttr = 0,
    //         points = [],
    //         attr,
    //         val;
    //     if (!Array.isArray(parents)) {
    //         parents = [parents];
    //     }
    //     len = parents.length;
    //     if (Type.exists(attrArray)) {
    //         lenAttr = attrArray.length;
    //     }
    //     if (lenAttr === 0) {
    //         attr = this.copyAttributes(attributes, board.options, attrClass);
    //     }
    //     for (i = 0; i < len; ++i) {
    //         if (lenAttr > 0) {
    //             j = Math.min(i, lenAttr - 1);
    //             attr = this.copyAttributes(
    //                 attributes,
    //                 board.options,
    //                 attrClass,
    //                 attrArray[j].toLowerCase(),
    //             );
    //         }
    //         if (Array.isArray(parents[i]) && parents[i].length > 1) {
    //             points.push(board.create('point', parents[i], attr));
    //             points[points.length - 1]._is_new = true;
    //         } else if (this.isFunction(parents[i])) {
    //             val = parents[i]();
    //             if (Array.isArray(val) && val.length > 1) {
    //                 points.push(board.create('point', [parents[i]], attr));
    //                 points[points.length - 1]._is_new = true;
    //             }
    //         } else {
    //             points.push(board.select(parents[i]));
    //         }
    //         if (!this.isPoint(points[i])) {
    //             return false;
    //         }
    //     }
    //     return points;
    // }
    // /**
    //  *  Test if the parents array contains existing points. If instead parents contains coordinate arrays or
    //  *  function returning coordinate arrays
    //  *  free points with these coordinates are created.
    //  *
    //  * @param {JXG.View3D} view View3D object
    //  * @param {Array} parents Array containing parent elements for a new object. This array may contain
    //  *    <ul>
    //  *      <li> {@link JXG.Point3D} objects
    //  *      <li> {@link JXG.GeometryElement#name} of {@link JXG.Point3D} objects
    //  *      <li> {@link JXG.GeometryElement#id} of {@link JXG.Point3D} objects
    //  *      <li> Coordinates of 3D points given as array of numbers of length three, e.g. [2, 3, 1].
    //  *      <li> Coordinates of 3D points given as array of functions of length three. Each function returns one coordinate, e.g.
    //  *           [function(){ return 2; } function(){ return 3; } function(){ return 1; }]
    //  *      <li> Function returning coordinates, e.g. function() { return [2, 3, 1]; }
    //  *    </ul>
    //  *  In the last three cases a new 3D point will be created.
    //  * @param {String} attrClass Main attribute class of newly created 3D points, see {@link JXG#copyAttributes}
    //  * @param {Array} attrArray List of subtype attributes for the newly created 3D points. The list of subtypes is mapped to the list of new 3D points.
    //  * @returns {Array} List of newly created {@link JXG.Point3D} elements or false if not all returned elements are 3D points.
    //  */
    // static providePoints3D(view, parents, attributes, attrClass, attrArray) {
    //     var i,
    //         j,
    //         len,
    //         lenAttr = 0,
    //         points = [],
    //         attr,
    //         val;
    //     if (!Array.isArray(parents)) {
    //         parents = [parents];
    //     }
    //     len = parents.length;
    //     if (Type.exists(attrArray)) {
    //         lenAttr = attrArray.length;
    //     }
    //     if (lenAttr === 0) {
    //         attr = this.copyAttributes(attributes, view.board.options, attrClass);
    //     }
    //     for (i = 0; i < len; ++i) {
    //         if (lenAttr > 0) {
    //             j = Math.min(i, lenAttr - 1);
    //             attr = this.copyAttributes(
    //                 attributes,
    //                 view.board.options,
    //                 attrClass,
    //                 attrArray[j],
    //             );
    //         }
    //         if (
    //             Array.isArray(parents[i]) &&
    //             parents[i].length > 0 &&
    //             parents[i].every((x) => Array.isArray(x) && this.isNumber(x[0]))
    //         ) {
    //             // Testing for array-of-arrays-of-numbers, like [[1,2,3],[2,3,4]]
    //             for (j = 0; j < parents[i].length; j++) {
    //                 points.push(view.create('point3d', parents[i][j], attr));
    //                 points[points.length - 1]._is_new = true;
    //             }
    //         } else if (
    //             Array.isArray(parents[i]) &&
    //             parents[i].every((x) => this.isNumber(x) || this.isFunction(x))
    //         ) {
    //             // Single array [1,2,3]
    //             points.push(view.create('point3d', parents[i], attr));
    //             points[points.length - 1]._is_new = true;
    //         } else if (this.isPoint3D(parents[i])) {
    //             points.push(parents[i]);
    //         } else if (this.isFunction(parents[i])) {
    //             val = parents[i]();
    //             if (Array.isArray(val) && val.length > 1) {
    //                 points.push(view.create('point3d', [parents[i]], attr));
    //                 points[points.length - 1]._is_new = true;
    //             }
    //         } else {
    //             points.push(view.select(parents[i]));
    //         }
    //         if (!this.isPoint3D(points[i])) {
    //             return false;
    //         }
    //     }
    //     return points;
    // }
    /**
     * Generates a function which calls the function fn in the scope of owner.
     * @param {Function} fn Function to call.
     * @param {Object} owner Scope in which fn is executed.
     * @returns {Function} A function with the same signature as fn.
     */
    static bind(fn, owner) {
        return function () {
            return fn.apply(owner, arguments);
        };
    }
    /**
     * If <tt>val</tt> is a function, it will be evaluated without giving any parameters, else the input value
     * is just returned.
     * @param val Could be anything. Preferably a number or a function.
     * @returns If <tt>val</tt> is a function, it is evaluated and the result is returned. Otherwise <tt>val</tt> is returned.
     */
    static evaluate(val) {
        if (this.isFunction(val)) {
            return val();
        }
        return val;
    }
    /**
     * Search an array for a given value.
     * @param {Array} array
     * @param value
     * @param {String} [sub] Use this property if the elements of the array are objects.
     * @returns {Number} The index of the first appearance of the given value, or
     * <tt>-1</tt> if the value was not found.
     */
    static indexOf(array, value, sub) {
        var i, s = Type.exists(sub);
        if (Array.prototype.indexOf(value) && !s) {
            return array.prototype.indexOf(value);
        }
        for (i = 0; i < array.length; i++) {
            if ((s && array[i][sub] === value) || (!s && array[i] === value)) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Eliminates duplicate entries in an array consisting of numbers and strings.
     * @param {Array} a An array of numbers and/or strings.
     * @returns {Array} The array with duplicate entries eliminated.
     */
    static eliminateDuplicates(a) {
        var i, len = a.length, result = [], obj = {};
        for (i = 0; i < len; i++) {
            obj[a[i]] = 0;
        }
        for (i in obj) {
            if (obj.hasOwnProperty(i)) {
                result.push(i);
            }
        }
        return result;
    }
    /**
     * Swaps to array elements.
     * @param {Array} arr
     * @param {Number} i
     * @param {Number} j
     * @returns {Array} Reference to the given array.
     */
    static swap(arr, i, j) {
        var tmp;
        tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
        return arr;
    }
    /**
     * Generates a copy of an array and removes the duplicate entries. The original
     * Array will be altered.
     * @param {Array} arr
     * @returns {Array}
     */
    static uniqueArray(arr) {
        var i, j, isArray, ret = [];
        if (arr.length === 0) {
            return [];
        }
        for (i = 0; i < arr.length; i++) {
            isArray = Array.isArray(arr[i]);
            if (!Type.exists(arr[i])) {
                arr[i] = '';
                continue;
            }
            for (j = i + 1; j < arr.length; j++) {
                if (isArray && Type.cmpArrays(arr[i], arr[j])) {
                    arr[i] = [];
                }
                else if (!isArray && arr[i] === arr[j]) {
                    arr[i] = '';
                }
            }
        }
        j = 0;
        for (i = 0; i < arr.length; i++) {
            isArray = Array.isArray(arr[i]);
            if (!isArray && arr[i] !== '') {
                ret[j] = arr[i];
                j++;
            }
            else if (isArray && arr[i].length !== 0) {
                ret[j] = arr[i].slice(0);
                j++;
            }
        }
        arr = ret;
        return ret;
    }
    // /**
    //  * Converts an array of {@link JXG.Coords} objects into a coordinate matrix.
    //  * @param {Array} coords
    //  * @param {Boolean} split
    //  * @returns {Array}
    //  */
    // static coordsArrayToMatrix(coords:, split) {
    //     var i,
    //         x:number[] = [],
    //         m:number[] = [];
    //     for (i = 0; i < coords.length; i++) {
    //         if (split) {
    //             x.push(coords[i].usrCoords[1]);
    //             m.push(coords[i].usrCoords[2]);
    //         } else {
    //             m.push([coords[i].usrCoords[1], coords[i].usrCoords[2]]);
    //         }
    //     }
    //     if (split) {
    //         m = [x, m];
    //     }
    //     return m;
    // }
    /**
     * Compare two arrays.
     * @param {Array} a1
     * @param {Array} a2
     * @returns {Boolean} <tt>true</tt>, if the arrays coefficients are of same type and value.
     */
    static cmpArrays(a1, a2) {
        var i;
        // trivial cases
        if (a1 === a2) {
            return true;
        }
        if (a1.length !== a2.length) {
            return false;
        }
        for (i = 0; i < a1.length; i++) {
            if (Array.isArray(a1[i]) && Array.isArray(a2[i])) {
                if (!this.cmpArrays(a1[i], a2[i])) {
                    return false;
                }
            }
            else if (a1[i] !== a2[i]) {
                return false;
            }
        }
        return true;
    }
    /**
     * Removes an element from the given array
     * @param {Array} ar
     * @param el
     * @returns {Array}
     */
    static removeElementFromArray(ar, el) {
        var i;
        for (i = 0; i < ar.length; i++) {
            if (ar[i] === el) {
                ar.splice(i, 1);
                return ar;
            }
        }
        return ar;
    }
    /**
     * Truncate a number <tt>n</tt> after <tt>p</tt> decimals.
     * @param {Number} n
     * @param {Number} p
     * @returns {Number}
     */
    static trunc(n, p) {
        p = Type.def(p, 0);
        return this.toFixed(n, p);
    }
    /**
     * Decimal adjustment of a number.
     * From https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Math/round
     *
     * @param    {String}    type    The type of adjustment.
     * @param    {Number}    value    The number.
     * @param    {Number}    exp        The exponent (the 10 logarithm of the adjustment base).
     * @returns    {Number}            The adjusted value.
     *
     * @private
     */
    static _decimalAdjust(type, value, exp) {
        // If the exp is undefined or zero...
        if (exp === undefined || +exp === 0) {
            return Math[type](value);
        }
        value = +value;
        exp = +exp;
        // If the value is not a number or the exp is not an integer...
        if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {
            return NaN;
        }
        // Shift
        value = value.toString().split('e');
        value = Math[type](+(value[0] + 'e' + (value[1] ? +value[1] - exp : -exp)));
        // Shift back
        value = value.toString().split('e');
        return +(value[0] + 'e' + (value[1] ? +value[1] + exp : exp));
    }
    /**
     * Round a number to given number of decimal digits.
     *
     * Example: JXG._toFixed(3.14159, -2) gives 3.14
     * @param  {Number} value Number to be rounded
     * @param  {Number} exp   Number of decimal digits given as negative exponent
     * @return {Number}       Rounded number.
     *
     * @private
     */
    static _round10(value, exp) {
        return this._decimalAdjust('round', value, exp);
    }
    /**
     * "Floor" a number to given number of decimal digits.
     *
     * Example: JXG._toFixed(3.14159, -2) gives 3.14
     * @param  {Number} value Number to be floored
     * @param  {Number} exp   Number of decimal digits given as negative exponent
     * @return {Number}       "Floored" number.
     *
     * @private
     */
    static _floor10(value, exp) {
        return this._decimalAdjust('floor', value, exp);
    }
    /**
     * "Ceil" a number to given number of decimal digits.
     *
     * Example: JXG._toFixed(3.14159, -2) gives 3.15
     * @param  {Number} value Number to be ceiled
     * @param  {Number} exp   Number of decimal digits given as negative exponent
     * @return {Number}       "Ceiled" number.
     *
     * @private
     */
    static _ceil10(value, exp) {
        return this._decimalAdjust('ceil', value, exp);
    }
    /**
     * Replacement of the default toFixed() method.
     * It does a correct rounding (independent of the browser) and
     * returns "0.00" for toFixed(-0.000001, 2) instead of "-0.00" which
     * is returned by JavaScript's toFixed()
     *
     * @memberOf JXG
     * @param  {Number} num    Number tp be rounded
     * @param  {Number} digits Decimal digits
     * @return {String}        Rounded number is returned as string
     */
    static toFixed(num, digits) {
        return this._round10(num, -digits).toFixed(digits);
    }
    /**
     * Truncate a number <tt>val</tt> automatically.
     * @memberOf JXG
     * @param val
     * @returns {Number}
     */
    static autoDigits(val) {
        var x = Math.abs(val), str;
        if (x >= 0.1) {
            str = Type.toFixed(val, 2);
        }
        else if (x >= 0.01) {
            str = Type.toFixed(val, 4);
        }
        else if (x >= 0.0001) {
            str = Type.toFixed(val, 6);
        }
        else {
            str = val;
        }
        return str;
    }
    /**
     * Convert value v. If v has the form
     * <ul>
     * <li> 'x%': return floating point number x * percentOfWhat * 0.01
     * <li> 'xfr': return floating point number x * percentOfWhat
     * <li> 'xpx': return x * convertPx or convertPx(x) or x
     * <li> x or 'x': return floating point number x
     * </ul>
     * @param {String|Number} v
     * @param {Number} percentOfWhat
     * @param {Function|Number|*} convertPx
     * @returns {String|Number}
     */
    static parseNumber(v, percentOfWhat, convertPx) {
        var str;
        if (this.isString(v) && v.indexOf('%') > -1) {
            str = v.replace(/\s+%\s+/, '');
            return parseFloat(str) * percentOfWhat * 0.01;
        }
        if (this.isString(v) && v.indexOf('fr') > -1) {
            str = v.replace(/\s+fr\s+/, '');
            return parseFloat(str) * percentOfWhat;
        }
        if (this.isString(v) && v.indexOf('px') > -1) {
            str = v.replace(/\s+px\s+/, '');
            str = parseFloat(str);
            if (this.isFunction(convertPx)) {
                return convertPx(str);
            }
            else if (this.isNumber(convertPx)) {
                return str * convertPx;
            }
            else {
                return str;
            }
        }
        // Number or String containing no unit
        return parseFloat(v);
    }
    /**
     * Parse a string for label positioning of the form 'left pos' or 'pos right'
     * and return e.g.
     * <tt>{ side: 'left', pos: 'pos' }</tt>.
     * @param {String} str
     * @returns {Obj}  <tt>{ side, pos }</tt>
     */
    static parsePosition(str) {
        var a, i, side = '', pos = '';
        str = str.trim();
        if (str !== '') {
            a = str.split(/[ ,]+/);
            for (i = 0; i < a.length; i++) {
                if (a[i] === 'left' || a[i] === 'right') {
                    side = a[i];
                }
                else {
                    pos = a[i];
                }
            }
        }
        return {
            side: side,
            pos: pos,
        };
    }
    // /**
    //  * Extracts the keys of a given object.
    //  * @param object The object the keys are to be extracted
    //  * @param onlyOwn If true, hasOwnProperty() is used to verify that only keys are collected
    //  * the object owns itself and not some other object in the prototype chain.
    //  * @returns {Array} All keys of the given object.
    //  */
    // static keys(object, onlyOwn) {
    //     var keys = [],
    //         property;
    //     // the caller decides if we use hasOwnProperty
    //     /*jslint forin:true*/
    //     for (property in object) {
    //         if (onlyOwn) {
    //             if (object.hasOwnProperty(property)) {
    //                 keys.push(property);
    //             }
    //         } else {
    //             keys.push(property);
    //         }
    //     }
    //     /*jslint forin:false*/
    //     return keys;
    // }
    /**
     * This outputs an object with a base class reference to the given object. This is useful if
     * you need a copy of an e.g. attributes object and want to overwrite some of the attributes
     * without changing the original object.
     * @param {Object} obj Object to be embedded.
     * @returns {Object} An object with a base class reference to <tt>obj</tt>.
     */
    static clone(obj) {
        var cObj = {};
        cObj.prototype = obj;
        return cObj;
    }
    /**
     * Embeds an existing object into another one just like {@link #clone} and copies the contents of the second object
     * to the new one. Warning: The copied properties of obj2 are just flat copies.
     * @param {Object} obj Object to be copied.
     * @param {Object} obj2 Object with data that is to be copied to the new one as well.
     * @returns {Object} Copy of given object including some new/overwritten data from obj2.
     */
    static cloneAndCopy(obj, obj2) {
        var r, cObj = function () {
            return undefined;
        };
        cObj.prototype = obj;
        // no hasOwnProperty on purpose
        /*jslint forin:true*/
        /*jshint forin:true*/
        for (r in obj2) {
            cObj[r] = obj2[r];
        }
        /*jslint forin:false*/
        /*jshint forin:false*/
        return cObj;
    }
    /**
     * Recursively merges obj2 into obj1 in-place. Contrary to {@link JXG#deepCopy} this won't create a new object
     * but instead will overwrite obj1.
     * <p>
     * In contrast to method JXG.mergeAttr, merge recurses into any kind of object, e.g. DOM object and JSXGraph objects.
     * So, please be careful.
     * @param {Object} obj1
     * @param {Object} obj2
     * @returns {Object}
     * @see JXG.mergeAttr
     *
     * @example
     * JXG.Options = JXG.merge(JXG.Options, {
     *     board: {
     *         showNavigation: false,
     *         showInfobox: true
     *     }
     *     point: {
     *         face: 'o',
     *         size: 4,
     *         fillColor: '#eeeeee',
     *         highlightFillColor: '#eeeeee',
     *         strokeColor: 'white',
     *         highlightStrokeColor: 'white',
     *         showInfobox: 'inherit'
     *     }
     * });
     *
     * </pre><div id="JXGc5bf0f2a-bd5a-4612-97c2-09f17b1bbc6b" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGc5bf0f2a-bd5a-4612-97c2-09f17b1bbc6b',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     JXG.Options = JXG.merge(JXG.Options, {
     *         board: {
     *             showNavigation: false,
     *             showInfobox: true
     *         }
     *         point: {
     *             face: 'o',
     *             size: 4,
     *             fillColor: '#eeeeee',
     *             highlightFillColor: '#eeeeee',
     *             strokeColor: 'white',
     *             highlightStrokeColor: 'white',
     *             showInfobox: 'inherit'
     *         }
     *     });
     *
     *
     *     })();
     *
     * </script><pre>
     */
    static merge(obj1, obj2) {
        var i, j, o, oo;
        for (i in obj2) {
            if (obj2.hasOwnProperty(i)) {
                o = obj2[i];
                if (Array.isArray(o)) {
                    if (obj1[i] == undefined) {
                        obj1[i] = [];
                    }
                    for (j = 0; j < o.length; j++) {
                        oo = obj2[i][j];
                        if (typeof obj2[i][j] === 'object') {
                            if (obj1[i][j] == undefined) {
                                obj1[i][j] = obj2[i][j];
                            }
                            else {
                                obj1[i][j] = this.merge(obj1[i][j], oo);
                            }
                        }
                        else {
                            obj1[i][j] = obj2[i][j];
                        }
                    }
                }
                else if (typeof o === 'object') {
                    if (typeof obj1[i] !== 'object') {
                        obj1[i] = o; //{};
                    }
                    obj1[i] = this.merge(obj1[i], o);
                }
                else {
                    if (typeof obj1 === 'boolean') {
                        // This is necessary in the following scenario:
                        //   lastArrow == false
                        // and call of
                        //   setAttribute({lastArrow: {type: 7}})
                        obj1 = {};
                    }
                    obj1[i] = o;
                }
            }
        }
        return obj1;
    }
    /**
     * Creates a deep copy of an existing object, i.e. arrays or sub-objects are copied component resp.
     * element-wise instead of just copying the reference. If a second object is supplied, the two objects
     * are merged into one object. The properties of the second object have priority.
     * @param  obj This object will be copied.
     * @param  obj2 This object will merged into the newly created object
     * @param  [toLower=false] If true the keys are convert to lower case. This is needed for visProp, see JXG#copyAttributes
     * @returns {Object} copy of obj or merge of obj and obj2.
     */
    static deepCopy(obj, obj2 = {}, toLower = false) {
        var c, i, prop, i2;
        toLower = toLower || false;
        if (typeof obj !== 'object' || obj === null) {
            return obj;
        }
        // Missing hasOwnProperty is on purpose in this function
        if (Array.isArray(obj)) {
            c = [];
            for (i = 0; i < Object.keys(obj).length; i++) { // warning: Object.keys() can be slow!
                prop = obj[i];
                // Attention: typeof null === 'object'
                if (prop !== null && typeof prop === 'object') {
                    // We certainly do not want to recurse into a JSXGraph object.
                    // This would for sure result in an infinite recursion.
                    // As alternative we copy the id of the object.
                    if (Type.exists(prop.board)) {
                        c[i] = prop.id;
                    }
                    else {
                        c[i] = this.deepCopy(prop, {}, toLower);
                    }
                }
                else {
                    c[i] = prop;
                }
            }
        }
        else {
            c = {};
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    i2 = toLower ? i.toLowerCase() : i;
                    prop = obj[i];
                    if (prop !== null && typeof prop === 'object') {
                        if (Type.exists(prop.board)) {
                            c[i2] = prop.id;
                        }
                        else {
                            c[i2] = this.deepCopy(prop, {}, toLower);
                        }
                    }
                    else {
                        c[i2] = prop;
                    }
                }
            }
            for (i in obj2) {
                if (obj2.hasOwnProperty(i)) {
                    i2 = toLower ? i.toLowerCase() : i;
                    prop = obj2[i];
                    if (prop !== null && typeof prop === 'object') {
                        if (Array.isArray(prop) || !Type.exists(c[i2])) {
                            c[i2] = this.deepCopy(prop, {}, toLower);
                        }
                        else {
                            c[i2] = this.deepCopy(c[i2], prop, toLower);
                        }
                    }
                    else {
                        c[i2] = prop;
                    }
                }
            }
        }
        return c;
    }
    /**
     * In-place (deep) merging of attributes. Allows attributes like `{shadow: {enabled: true...}}`
     * <p>
     * In contrast to method JXG.merge, mergeAttr does not recurse into DOM objects and JSXGraph objects. Instead
     * handles (pointers) to these objects are used.
     *
     * @param {Object} attr Object with attributes - usually containing default options - that will be changed in-place.
     * @param {Object} special Special option values which overwrite (recursively) the default options
     * @param {Boolean} [toLower=true] If true the keys are converted to lower case.
     * @param {Boolean} [ignoreUndefinedSpecials=false] If true the values in special that are undefined are not used.
     *
     * @see JXG.merge
     *
     */
    // static mergeAttr(attr: object, special: object, toLower: boolean = true, ignoreUndefinedSpecials: boolean = false) {
    //     attr = this.mergeAttrHelper(attr, special, toLower, ignoreUndefinedSpecials)
    // }
    // the helper version is testable.
    static mergeAttrHelper(attr, special, toLower = true, ignoreUndefinedSpecials = false) {
        let result = structuredClone(attr); // deep copy
        for (let e in special) {
            if (special.hasOwnProperty(e)) { // only direct properties, not inherited ones
                let e2 = toLower ? e.toLowerCase() : e;
                // Key already exists, but not in lower case
                if (e2 !== e && result.hasOwnProperty(e)) {
                    if (result.hasOwnProperty(e2)) {
                        // Lower case key already exists - this should not happen
                        // We have to unify the two key-value pairs
                        // It is not clear which has precedence.
                        result = this.mergeAttrHelper(result[e2], result[e], toLower);
                    }
                    else {
                        result[e2] = result[e];
                    }
                    delete result[e];
                }
                let o = special[e];
                if (this.isObject(o) &&
                    o !== null &&
                    // Do not recurse into a document object or a JSXGraph object
                    !this.isDocumentOrFragment(o) &&
                    !Type.exists(o.board) &&
                    // Do not recurse if a string is provided as "new String(...)"
                    typeof o.valueOf() !== 'string') {
                    if (result[e2] === undefined ||
                        result[e2] === null ||
                        !this.isObject(result[e2])) {
                        // The last test handles the case:
                        //   attr.draft = false;
                        //   special.draft = { strokewidth: 4}
                        result[e2] = {};
                    }
                    result[e2] = this.mergeAttrHelper(result[e2], o, toLower);
                }
                else if (!ignoreUndefinedSpecials || Type.exists(o)) {
                    // Flat copy
                    // This is also used in the cases
                    //   attr.shadow = { enabled: true ...}
                    //   special.shadow = false;
                    // and
                    //   special.anchor is a JSXGraph element
                    result[e2] = o;
                }
            }
        }
        return result;
    }
    /**
     * Convert a n object to a new object containing only
     * lower case properties.
     *
     * @param {Object} obj
     * @returns Object
     * @example
     * var attr = JXG.keysToLowerCase({radiusPoint: {visible: false}});
     *
     * // return {radiuspoint: {visible: false}}
     */
    static keysToLowerCase(obj) {
        return Type.mergeAttrHelper({}, obj); // merge converts to lower by default
    }
    /**
     * Generates an attributes object that is filled with default values from the Options object
     * and overwritten by the user specified attributes.
     * @param {Object} attributes user specified attributes
     * @param {Object} options defaults options
     * @param {String} s variable number of strings, e.g. 'slider', subtype 'point1'. Must be provided in lower case!
     * @returns {Object} The resulting attributes object
     */
    // examples:
    // attr_foci = Type.copyAttributes(attributes, board.options, "conic", "foci"),
    // attr_center = Type.copyAttributes(attributes, board.options, "conic", "center"),
    // attr_curve = Type.copyAttributes(attributes, board.options, "conic");
    static testCopy(attributes, options, ...s) {
        this.copyAttributes(attributes, options, ...s);
    }
    static copyAttributes(attributes, options, ...s) {
        var defaultOptions, arg, i, len, o, isAvail, primitives = {
            circle: 1,
            curve: 1,
            foreignobject: 1,
            image: 1,
            line: 1,
            point: 1,
            polygon: 1,
            text: 1,
            ticks: 1,
            integral: 1,
        };
        len = arguments.length;
        if (len < 3 || primitives[s[0]]) {
            // Default options from Options.elements
            defaultOptions = this.deepCopy(Options.elements, {}, true);
        }
        else {
            defaultOptions = {};
        }
        // Only the layer of the main element is set.
        if (len < 4 && Type.exists(s) && Type.exists(Options.layer[s[2]])) {
            defaultOptions.layer = Options.layer[s[2]];
        }
        // Default options from the specific element like 'line' in
        //     copyAttribute(attributes, board.options, 'line')
        // but also like in
        //     Type.copyAttributes(attributes, board.options, 'view3d', 'az', 'slider');
        o = options;
        isAvail = true;
        for (i = 2; i < len; i++) {
            arg = arguments[i];
            Options[arg];
            if (Options[arg]) {
                o = Options[arg];
            }
            else {
                isAvail = false;
                break;
            }
        }
        if (isAvail) {
            defaultOptions = this.deepCopy(defaultOptions, o, true);
        }
        // Merge the specific options given in the parameter 'attributes'
        // into the default options.
        // Additionally, we step into a sub-element of attribute like line.point1 -
        // in case it is supplied as in
        //     copyAttribute(attributes, board.options, 'line', 'point1')
        // In this case we would merge attributes.point1 into the global line.point1 attributes.
        // o = (typeof attributes === 'object') ? this.keysToLowerCase(attributes) : {};
        // isAvail = true;
        // for (i = 2; i < len; i++) {
        //     arg = arguments[i].toLowerCase();
        //     if (o[arg]) {
        //         o = o[arg];
        //     } else {
        //         isAvail = false;
        //         break;
        //     }
        // }
        // if (isAvail) {
        defaultOptions = this.mergeAttrHelper(defaultOptions, attributes, true);
        // }
        if (arguments[2] === 'board') {
            // For board attributes we are done now.
            return defaultOptions;
        }
        // Special treatment of labels
        o = options;
        isAvail = true;
        for (i = 2; i < len; i++) {
            arg = arguments[i];
            if (Type.exists(o[arg])) {
                o = o[arg];
            }
            else {
                isAvail = false;
                break;
            }
        }
        if (isAvail && Type.exists(o.label)) {
            defaultOptions.label = this.deepCopy(o.label, defaultOptions.label, true);
        }
        defaultOptions.label = this.deepCopy(Options.label, defaultOptions.label, true);
        return defaultOptions;
    }
    /**
     * Copy all prototype methods from object "superObject" to object
     * "subObject". The constructor of superObject will be available
     * in subObject as subObject.constructor[constructorName].
     * @param {Object} subObj A JavaScript object which receives new methods.
     * @param {Object} superObj A JavaScript object which lends its prototype methods to subObject
     * @returns {String} constructorName Under this name the constructor of superObj will be available
     * in subObject.
     * @private
     */
    static copyPrototypeMethods(subObject, superObject, constructorName) {
        var key;
        subObject.prototype[constructorName] = superObject.prototype.constructor;
        for (key in superObject.prototype) {
            if (superObject.prototype.hasOwnProperty(key)) {
                subObject.prototype[key] = superObject.prototype[key];
            }
        }
    }
    /**
     * Create a stripped down version of a JSXGraph element for cloning to the background.
     * Used in {JXG.GeometryElement#cloneToBackground} for creating traces.
     *
     * @param {JXG.GeometryElement} el Element to be cloned
     * @returns Object Cloned element
     * @private
     */
    static getCloneObject(el) {
        var obj, key;
        let copy = {};
        copy.id = el.id + 'T' + el.numTraces;
        el.numTraces += 1;
        copy.coords = el.coords;
        obj = this.deepCopy(el.visProp, el.visProp.traceattributes, true);
        copy.visProp = {};
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                if (key.indexOf('aria') !== 0 &&
                    key.indexOf('highlight') !== 0 &&
                    key.indexOf('attractor') !== 0 &&
                    key !== 'label' &&
                    key !== 'needsregularupdate' &&
                    key !== 'infoboxdigits') {
                    copy.visProp[key] = el.eval(obj[key]);
                }
            }
        }
        copy.evalVisProp = function (val) {
            return copy.visProp[val];
        };
        copy.eval = function (val) {
            return val;
        };
        copy.visProp.layer = 0; // TODO: was     el.board.options.layer.trace;
        copy.visProp.tabindex = null;
        copy.visProp.highlight = false;
        copy.board = el.board;
        copy.elementClass = el.elementClass;
        this.clearVisPropOld(copy);
        copy.visPropCalc = {
            visible: el.evalVisProp('visible'),
        };
        return copy;
    }
    /**
     * Converts a JavaScript object into a JSON string.
     * @param {Object} obj A JavaScript object, functions will be ignored.
     * @param {Boolean} [noquote=false] No quotes around the name of a property.
     * @returns {String} The given object stored in a JSON string.
     * @deprecated
     */
    static toJSON(obj, noquote) {
        var list, prop, i, s, val;
        noquote = this.def(noquote, false);
        // check for native JSON support:
        if (JSON !== undefined && JSON.stringify && !noquote) {
            try {
                s = JSON.stringify(obj);
                return s;
            }
            catch (e) {
                // if something goes wrong, e.g. if obj contains functions we won't return
                // and use our own implementation as a fallback
            }
        }
        switch (typeof obj) {
            case 'object':
                if (obj) {
                    list = [];
                    if (Array.isArray(obj)) {
                        for (i = 0; i < obj.length; i++) {
                            list.push(this.toJSON(obj[i], noquote));
                        }
                        return '[' + list.join(',') + ']';
                    }
                    for (prop in obj) {
                        if (obj.hasOwnProperty(prop)) {
                            try {
                                val = Type.toJSON(obj[prop], noquote);
                            }
                            catch (e2) {
                                val = '';
                            }
                            if (noquote) {
                                list.push(prop + ':' + val);
                            }
                            else {
                                list.push('"' + prop + '":' + val);
                            }
                        }
                    }
                    return '{' + list.join(',') + '} ';
                }
                return 'null';
            case 'string':
                return "'" + obj.replace(/(["'])/g, '\\$1') + "'";
            case 'number':
            case 'boolean':
                return obj.toString();
        }
        return '0';
    }
    /**
     * Resets visPropOld.
     * @param {JXG.GeometryElement} el
     * @returns {GeometryElement}
     */
    static clearVisPropOld(el) {
        el.visPropOld = {
            cssclass: '',
            cssdefaultstyle: '',
            cssstyle: '',
            fillcolor: '',
            fillopacity: '',
            firstarrow: false,
            fontsize: -1,
            lastarrow: false,
            left: -1e5,
            linecap: '',
            shadow: false,
            strokecolor: '',
            strokeopacity: '',
            strokewidth: '',
            tabindex: -1e5,
            transitionduration: 0,
            top: -1e5,
            visible: null,
        };
        return el;
    }
    /**
     * Checks if an object contains a key, whose value equals to val.
     * @param {Object} obj
     * @param val
     * @returns {Boolean}
     */
    static isInObject(obj, val) {
        var el;
        for (el in obj) {
            if (obj.hasOwnProperty(el)) {
                if (obj[el] === val) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Replaces all occurences of &amp; by &amp;amp;, &gt; by &amp;gt;, and &lt; by &amp;lt;.
     * @param {String} str
     * @returns {String}
     */
    static escapeHTML(str) {
        return str
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
    }
    /**
     * Eliminates all substrings enclosed by &lt; and &gt; and replaces all occurences of
     * &amp;amp; by &amp;, &amp;gt; by &gt;, and &amp;lt; by &lt;.
     * @param {String} str
     * @returns {String}
     */
    static unescapeHTML(str) {
        // This regex is NOT insecure. We are replacing everything found with ''
        /*jslint regexp:true*/
        return str
            .replace(/<\/?[^>]+>/gi, '')
            .replace(/&amp;/g, '&')
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>');
    }
    /**
     * Makes a string lower case except for the first character which will be upper case.
     * @param {String} str Arbitrary string
     * @returns {String} The capitalized string.
     */
    static capitalize(str) {
        return str.charAt(0).toUpperCase() + str.substring(1).toLowerCase();
    }
    /**
     * Make numbers given as strings nicer by removing all unnecessary leading and trailing zeroes.
     * @param {String} str
     * @returns {String}
     */
    static trimNumber(str) {
        str = str.replace(/^0+/, '');
        str = str.replace(/0+$/, '');
        if (str[str.length - 1] === '.' || str[str.length - 1] === ',') {
            str = str.slice(0, -1);
        }
        if (str[0] === '.' || str[0] === ',') {
            str = '0' + str;
        }
        return str;
    }
    /**
     * Filter an array of elements.
     * @param {Array} list
     * @param {Object|function} filter
     * @returns {Array}
     */
    static filterElements(list, filter) {
        var i, f, item, flower, value, visPropValue, pass, l = list.length, result = [];
        if (typeof filter !== 'function' && typeof filter !== 'object') {
            return result;
        }
        for (i = 0; i < l; i++) {
            pass = true;
            item = list[i];
            if (typeof filter === 'object') {
                for (f in filter) {
                    if (filter.hasOwnProperty(f)) {
                        flower = f.toLowerCase();
                        if (typeof item[f] === 'function') {
                            value = item[f]();
                        }
                        else {
                            value = item[f];
                        }
                        if (item.visProp && typeof item.visProp[flower] === 'function') {
                            visPropValue = item.visProp[flower]();
                        }
                        else {
                            visPropValue = item.visProp && item.visProp[flower];
                        }
                        if (typeof filter[f] === 'function') {
                            pass = filter[f](value) || filter[f](visPropValue);
                        }
                        else {
                            pass = value === filter[f] || visPropValue === filter[f];
                        }
                        if (!pass) {
                            break;
                        }
                    }
                }
            }
            else if (typeof filter === 'function') {
                pass = filter(item);
            }
            if (pass) {
                result.push(item);
            }
        }
        return result;
    }
    /**
     * Remove all leading and trailing whitespaces from a given string.
     */
    static trim(str) {
        // str = str.replace(/^\s+/, '');
        // str = str.replace(/\s+$/, '');
        //
        // return str;
        return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
    }
    /**
     * Convert a floating point number to a string integer + fraction.
     * Returns either a string of the form '3 1/3' (in case of useTeX=false)
     * or '3 \\frac{1}{3}' (in case of useTeX=true).
     *
     * @param {Number} x
     * @param {Boolean} [useTeX=false]
     * @param {Number} [order=0.001]
     * @returns {String}
     * @see JXG.Math.decToFraction
     */
    static toFraction(x, useTeX = false, order = 0.001) {
        var arr = JSXMath.decToFraction(x, order), str = '';
        if (arr[1] === 0 && arr[2] === 0) {
            // 0
            str += '0';
        }
        else {
            // Sign
            if (arr[0] < 0) {
                str += '-';
            }
            if (arr[2] === 0) {
                // Integer
                str += arr[1];
            }
            else if (!(arr[2] === 1 && arr[3] === 1)) {
                // Proper fraction
                if (arr[1] !== 0) {
                    // Absolute value larger than 1
                    str += arr[1] + ' ';
                }
                // Add fractional part
                if (useTeX === true) {
                    str += '\\frac{' + arr[2] + '}{' + arr[3] + '}';
                }
                else {
                    str += arr[2] + '/' + arr[3];
                }
            }
        }
        return str;
    }
    /**
     * Concat array src to array dest.
     * Uses push instead of JavaScript concat, which is much
     * faster.
     * The array dest is changed in place.
     * <p><b>Attention:</b> if "dest" is an anonymous array, the correct result is returned from the function.
     *
     * @param {Array} dest
     * @param {Array} src
     * @returns Array
     */
    static concat(dest, src) {
        var i, le = src.length;
        for (i = 0; i < le; i++) {
            dest.push(src[i]);
        }
        return dest;
    }
    /**
     * Convert HTML tags to entities or use html_sanitize if the google caja html sanitizer is available.
     * @param {String} str
     * @param {Boolean} caja
     * @returns {String} Sanitized string
     */
    static sanitizeHTML(str) {
        ///// caja is no longer supported
        ///// the old default sanitizer was insufficient
        // we use htmlSanitizer   https://github.com/jitbit/HtmlSanitizer
        /////  the old sanitizer
        // if (str && typeof str === "string") {
        //     str = str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
        // }
        // TODO: test and get it working
        // str = HtmlSanitizer.SanitizeHtml(str);
        return str;
    }
    /**
     * If <tt>s</tt> is a slider, it returns the sliders value, otherwise it just returns the given value.
     * @param {*} s
     * @returns {*} s.Value() if s is an element of type slider, s otherwise
     */
    static evalSlider(s) {
        if (s &&
            s.type === OBJECT_TYPE.GLIDER &&
            typeof s.Value === 'function') {
            return s.Value();
        }
        return s;
    }
    /**
     * Convert a string containing a MAXIMA /STACK expression into a JSXGraph / JessieCode string
     * or an array of JSXGraph / JessieCode strings.
     * <p>
     * This function is meanwhile superseded by stack_jxg.stack2jsxgraph.
     *
     * @deprecated
     *
     * @example
     * console.log( JXG.stack2jsxgraph("%e**x") );
     * // Output:
     * //    "EULER**x"
     *
     * @example
     * console.log( JXG.stack2jsxgraph("[%pi*(x**2 - 1), %phi*(x - 1), %gamma*(x+1)]") );
     * // Output:
     * //    [ "PI*(x**2 - 1)", "1.618033988749895*(x - 1)", "0.5772156649015329*(x+1)" ]
     *
     * @param {String} str
     * @returns String
     */
    static stack2jsxgraph(str) {
        var t;
        t = str
            .replace(/%pi/g, 'PI')
            .replace(/%e/g, 'EULER')
            .replace(/%phi/g, '1.618033988749895')
            .replace(/%gamma/g, '0.5772156649015329')
            .trim();
        // String containing array -> array containing strings
        if (t[0] === '[' && t[t.length - 1] === ']') {
            t = t.slice(1, -1).split(/\s*,\s*/);
        }
        return t;
    }
    /**
     * Simple DIFF for two objects, helpful for debugging
     * @param a object
     * @param b object
     * @returns
     */
    static getObjectDiff(a, b) {
        const changes = {};
        // Check current object's properties
        for (const [key, value] of Object.entries(b)) {
            if (!(key in a)) {
                changes[key] = {
                    expect: undefined,
                    found: value
                };
                continue;
            }
            const originalValue = a[key];
            const currentValue = value;
            // Handle different types of comparisons
            if (originalValue !== currentValue &&
                String(originalValue) !== String(currentValue) &&
                JSON.stringify(originalValue) !== JSON.stringify(currentValue)) {
                changes[key] = {
                    expect: originalValue,
                    found: currentValue
                };
            }
        }
        // Check for removed properties
        for (const key of Object.keys(a)) {
            if (!(key in b)) {
                changes[key] = {
                    expect: a[key],
                    found: undefined
                };
            }
        }
        return changes;
    }
}

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Andreas Walter,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */
/*global JXG: true, define: true, window: true, document: true, navigator: true, module: true, global: true, self: true, require: true*/
/*jslint nomen: true, plusplus: true*/
/**
 * @fileoverview The functions in this file help with the detection of the environment JSXGraph runs in. We can distinguish
 * between node.js, windows 8 app and browser, what rendering techniques are supported and (most of the time) if the device
 * the browser runs on is a tablet/cell or a desktop computer.
 */
// import { JXG } from "../Env.js";
class Env {
    /**
     * Determines whether evt is a touch event.
     * @param evt {Event}
     * @returns {Boolean}
     */
    static isTouchEvent(evt) {
        return ['touchstart', 'touchend', 'touchmove', 'touchcancel'].includes(evt.type);
    }
    /**
     * Determines whether evt is a pointer event.
     * @param evt {Event}
     * @returns {Boolean}
     */
    static isPointerEvent(evt) {
        return Type.exists(evt.pointerId);
    }
    /**
     * Determines whether evt is neither a touch event nor a pointer event.
     * @param evt {Event}
     * @returns {Boolean}
     */
    static isMouseEvent(evt) {
        return !Env.isTouchEvent(evt) && !Env.isPointerEvent(evt);
    }
    /**
     * Determines the number of touch points in a touch event.
     * For other events, -1 is returned.
     * @param evt {Event}
     * @returns {Number}
     */
    static getNumberOfTouchPoints(evt) {
        var n = -1;
        if (Env.isTouchEvent(evt)) {
            n = evt['touches'].length;
        }
        return n;
    }
    /**
     * Checks whether an mouse, pointer or touch event evt is the first event of a multitouch event.
     * Attention: When two or more pointer device types are being used concurrently,
     *            it is only checked whether the passed event is the first one of its type!
     * @param evt {Event}
     * @returns {boolean}
     */
    static isFirstTouch(evt) {
        var touchPoints = Env.getNumberOfTouchPoints(evt);
        if (Env.isPointerEvent(evt)) {
            return evt.isPrimary;
        }
        return touchPoints === 1;
    }
    /**
     * A document/window environment is available.
     * @type Boolean
     * @default false
     */
    static isBrowser() {
        console.log("isBrowser", window !== null && document !== null);
        return true; // TODO
    }
    /**
     * Features of ECMAScript 6+ are available.
     * @type Boolean
     * @default false
     */
    static supportsES6() {
        // var testMap;
        /* jshint ignore:start */
        try {
            // This would kill the old uglifyjs: testMap = (a = 0) => a;
            new Function("(a = 0) => a");
            return true;
        }
        catch (err) {
            return false;
        }
        /* jshint ignore:end */
    }
    /**
     * Detect browser support for SVG.
     * @returns {Boolean} True, if the browser supports SVG.
     */
    static supportsSVG() {
        var svgSupport;
        if (!this.isBrowser) {
            return false;
        }
        svgSupport = !!document.createElementNS && !!document.createElementNS('http://www.w3.org/2000/svg', 'svg').createSVGRect;
        return svgSupport;
    }
    /**
     * Detect browser support for Canvas.
     * @returns {Boolean} True, if the browser supports HTML canvas.
     */
    static supportsCanvas() {
        var hasCanvas = false;
        // if (this.isNode()) {
        //     try {
        //         // c = typeof module === "object" ? module.require("canvas") : $__canvas;
        //         c = typeof module === "object" ? module.require("canvas") : import('canvas');
        //         hasCanvas = !!c;
        //     } catch (err) {}
        // }
        if (this.isNode()) {
            //try {
            //    Env.createCanvas(500, 500);
            hasCanvas = true;
            // } catch (err) {
            //     throw new Error('Env.createCanvas not available.\n' +
            //         'Install the npm package `canvas`\n' +
            //         'and call:\n' +
            //         '    import { createCanvas } from "canvas.js";\n' +
            //         '    Env.createCanvas = createCanvas;\n');
            // }
        }
        return (hasCanvas || (this.isBrowser !== null && !!document.createElement("canvas").getContext));
    }
    /**
     * True, if run inside a node.js environment.
     * @returns {Boolean}
     */
    static isNode() {
        // This is not a 100% sure but should be valid in most cases
        // We are not inside a browser
        /* eslint-disable no-undef */
        return (!this.isBrowser &&
            (typeof process !== 'undefined') &&
            (process.release.name.search(/node|io.js/) !== -1)
        /* eslint-enable no-undef */
        // there is a module object (plain node, no requirejs)
        // ((typeof module === "object" && !!module.exports) ||
        //     // there is a global object and requirejs is loaded
        //     (typeof global === "object" &&
        //         global.requirejsVars &&
        //         !global.requirejsVars.isBrowser)
        // )
        );
    }
    /**
     * True if run inside a webworker environment.
     * @returns {Boolean}
     */
    static isWebWorker() {
        return (!this.isBrowser &&
            typeof self === "object" &&
            typeof self.postMessage === "function");
    }
    /**
     * Checks if the environments supports the W3C Pointer Events API {@link https://www.w3.org/TR/pointerevents/}
     * @returns {Boolean}
     */
    static supportsPointerEvents() {
        return true; // TODO rewrite for modern web
    }
    //     return !!(
    //         (
    //             this.isBrowser &&
    //             window.navigator &&
    //             (window.PointerEvent || // Chrome/Edge/IE11+
    //                 window.navigator.pointerEnabled || // IE11+
    //                 window.navigator.msPointerEnabled)
    //         ) // IE10-
    //     );
    // }
    /**
     * Determine if the current browser supports touch events
     * @returns {Boolean} True, if the browser supports touch events.
     */
    static isTouchDevice() {
        return this.isBrowser !== null && window.ontouchstart !== undefined;
    }
    /**
     * Detects if the user is using an Android powered device.
     * @returns {Boolean}
     * @deprecated
     */
    static isAndroid() {
        return (Type.exists(navigator) &&
            navigator.userAgent.toLowerCase().indexOf("android") > -1);
    }
    /**
     * Detects if the user is using the default Webkit browser on an Android powered device.
     * @returns {Boolean}
     * @deprecated
     */
    static isWebkitAndroid() {
        return this.isAndroid() && navigator.userAgent.indexOf(" AppleWebKit/") > -1;
    }
    /**
     * Detects if the user is using a Apple iPad / iPhone.
     * @returns {Boolean}
     * @deprecated
     */
    static isApple() {
        return (Type.exists(navigator) &&
            (navigator.userAgent.indexOf("iPad") > -1 ||
                navigator.userAgent.indexOf("iPhone") > -1));
    }
    /**
     * Detects if the user is using Safari on an Apple device.
     * @returns {Boolean}
     * @deprecated
     */
    static isWebkitApple() {
        return (this.isApple() && navigator.userAgent.search(/Mobile\/[0-9A-Za-z.]*Safari/) > -1);
    }
    /**
     * Returns true if the run inside a Windows 8 "Metro" App.
     * @returns {Boolean}
     * @deprecated
     */
    static isMetroApp() {
        return (typeof window === "object" &&
            window.clientInformation &&
            window.clientInformation.appVersion &&
            window.clientInformation.appVersion.indexOf("MSAppHost") > -1);
    }
    /**
     * Detects if the user is using a Mozilla browser
     * @returns {Boolean}
     * @deprecated
     */
    static isMozilla() {
        return (Type.exists(navigator) &&
            navigator.userAgent.toLowerCase().indexOf("mozilla") > -1 &&
            navigator.userAgent.toLowerCase().indexOf("apple") === -1);
    }
    /**
     * Detects if the user is using a firefoxOS powered device.
     * @returns {Boolean}
     * @deprecated
     */
    static isFirefoxOS() {
        return (Type.exists(navigator) &&
            navigator.userAgent.toLowerCase().indexOf("android") === -1 &&
            navigator.userAgent.toLowerCase().indexOf("apple") === -1 &&
            navigator.userAgent.toLowerCase().indexOf("mobile") > -1 &&
            navigator.userAgent.toLowerCase().indexOf("mozilla") > -1);
    }
    /**
     * Detects if the user is using a desktop device, see <a href="https://stackoverflow.com/a/61073480">https://stackoverflow.com/a/61073480</a>.
     * @returns {boolean}
     *
     * @deprecated
     */
    static isDesktop() {
        return true;
        // console.log("isDesktop", screen.orientation);
        // const navigatorAgent =
        //     navigator.userAgent || navigator.vendor || window.opera;
        // return !(
        //     /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series([46])0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(
        //         navigatorAgent
        //     ) ||
        //     /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br([ev])w|bumb|bw-([nu])|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do([cp])o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly([-_])|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-([mpt])|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c([- _agpst])|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac([ \-/])|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja([tv])a|jbro|jemu|jigs|kddi|keji|kgt([ /])|klon|kpt |kwc-|kyo([ck])|le(no|xi)|lg( g|\/([klu])|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t([- ov])|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30([02])|n50([025])|n7(0([01])|10)|ne(([cm])-|on|tf|wf|wg|wt)|nok([6i])|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan([adt])|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c([-01])|47|mc|nd|ri)|sgh-|shar|sie([-m])|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel([im])|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c([- ])|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(
        //         navigatorAgent.substr(0, 4)
        //     )
        // );
    }
    /**
     * Detects if the user is using a mobile device, see <a href="https://stackoverflow.com/questions/25542814/html5-detecting-if-youre-on-mobile-or-pc-with-javascript">https://stackoverflow.com/questions/25542814/html5-detecting-if-youre-on-mobile-or-pc-with-javascript</a>.
     * @returns {boolean}
     *
     * @deprecated
     *
     */
    static isMobile() {
        return true;
        // return Type.exists(navigator) && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }
    /**
     * Reads the width and height of an HTML element.
     * @param {String|Object} elementId id of or reference to an HTML DOM node.
     * @returns {Object} An object with the two properties width and height.
     */
    static getDimensions(elementId, doc) {
        var element, display, els, originalVisibility, originalPosition, originalDisplay, originalWidth, originalHeight, style, pixelDimRegExp = /\d+(\.\d*)?px/;
        if (!this.isBrowser || elementId === null) {
            return {
                width: 500,
                height: 500
            };
        }
        doc = doc || document;
        // Borrowed from prototype.js
        element = (Type.isString(elementId)) ? doc.getElementById(elementId) : elementId;
        if (!Type.exists(element)) {
            throw new Error("\nJSXGraph: HTML container element '" + elementId + "' not found.");
        }
        display = element.style.display;
        // Work around a bug in Safari
        if (display !== "none" && display !== null) {
            if (element.clientWidth > 0 && element.clientHeight > 0) {
                return { width: element.clientWidth, height: element.clientHeight };
            }
            // A parent might be set to display:none; try reading them from styles
            style = window.getComputedStyle ? window.getComputedStyle(element) : element.style;
            return {
                width: pixelDimRegExp.test(style.width) ? parseFloat(style.width) : 0,
                height: pixelDimRegExp.test(style.height) ? parseFloat(style.height) : 0
            };
        }
        // All *Width and *Height properties give 0 on elements with display set to none,
        // hence we show the element temporarily
        els = element.style;
        // save style
        originalVisibility = els.visibility;
        originalPosition = els.position;
        originalDisplay = els.display;
        // show element
        els.visibility = "hidden";
        els.position = "absolute";
        els.display = "block";
        // read the dimension
        originalWidth = element.clientWidth;
        originalHeight = element.clientHeight;
        // restore original css values
        els.display = originalDisplay;
        els.position = originalPosition;
        els.visibility = originalVisibility;
        return {
            width: originalWidth,
            height: originalHeight
        };
    }
    /**
     * Adds an event listener to a DOM element.
     * @param {Object} obj Reference to a DOM node.
     * @param {String} type The event to catch, without leading 'on', e.g. 'mousemove' instead of 'onmousemove'.
     * @param {Function} fn The function to call when the event is triggered.
     * @param {Object} owner The scope in which the event trigger is called.
     * @param {Object|Boolean} [options=false] This parameter is passed as the third parameter to the method addEventListener. Depending on the data type it is either
     * an options object or the useCapture Boolean.
     *
     */
    static addEvent(obj, type, fn, owner, options = false) {
        let callback = function () {
            return fn.apply(owner, arguments);
        };
        // callback.origin = fn;  // TBTB ????
        // Check if owner is a board
        if (typeof owner === 'object' && Type.exists(owner.mode)) {
            owner['x_internal' + type] = owner['x_internal' + type] || [];
            owner['x_internal' + type].push(callback);
        }
        // Non-IE browser
        if (Type.exists(obj) && Type.exists(obj.addEventListener)) {
            obj.addEventListener(type, callback, options);
        }
        // // IE
        // if (Type.exists(obj) && Type.exists(obj.attachEvent)) {
        //     obj.attachEvent("on" + type, el);
        // }
    }
    /**
     * Removes an event listener from a DOM element.
     * @param {Object} obj Reference to a DOM node.
     * @param {String} type The event to catch, without leading 'on', e.g. 'mousemove' instead of 'onmousemove'.
     * @param {Function} fn The function to call when the event is triggered.
     * @param {Object} owner The scope in which the event trigger is called.
     */
    static removeEvent(obj, type, fn, owner) {
        var i;
        console.log('removeEvent', type);
        if (!Type.exists(owner)) {
            Env.debug("no such owner");
            return;
        }
        if (!Type.exists(owner["x_internal" + type])) {
            Env.debug("removeEvent: no such type: " + type);
            return;
        }
        if (!Array.isArray(owner["x_internal" + type])) {
            Env.debug("owner[x_internal + " + type + "] is not an array");
            return;
        }
        i = Type.indexOf(owner["x_internal" + type], fn, "origin");
        if (i === -1) {
            Env.debug("removeEvent: no such event function in internal list: " + type);
            return;
        }
        try {
            // Non-IE browser
            if (Type.exists(obj) && Type.exists(obj.removeEventListener)) {
                obj.removeEventListener(type, owner["x_internal" + type][i], false);
            }
            // IE
            if (Type.exists(obj) && Type.exists(obj.detachEvent)) {
                obj.detachEvent("on" + type, owner["x_internal" + type][i]);
            }
        }
        catch (e) {
            Env.debug("removeEvent: event not registered in browser: (" + type + " -- " + fn + ")");
        }
        owner["x_internal" + type].splice(i, 1);
    }
    /**
     * Removes all events of the given type from a given DOM node; Use with caution and do not use it on a container div
     * of a {@link Env.Board} because this might corrupt the event handling system.
     * @param {Object} obj Reference to a DOM node.
     * @param {String} type The event to catch, without leading 'on', e.g. 'mousemove' instead of 'onmousemove'.
     * @param {Object} owner The scope in which the event trigger is called.
     */
    static removeAllEvents(obj, type, owner) {
        var i, len;
        if (owner["x_internal" + type]) {
            len = owner["x_internal" + type].length;
            for (i = len - 1; i >= 0; i--) {
                Env.removeEvent(obj, type, owner["x_internal" + type][i].origin, owner);
            }
            if (owner["x_internal" + type].length > 0) {
                Env.debug("removeAllEvents: Not all events could be removed.");
            }
        }
    }
    /**
     * Cross browser mouse / pointer / touch coordinates retrieval relative to the documents's top left corner.
     * This method might be a bit outdated today, since pointer events and clientX/Y are omnipresent.
     *
     * @param {Object} [e] The browsers event object. If omitted, <tt>window.event</tt> will be used.
     * @param {Number} [index] If <tt>e</tt> is a touch event, this provides the index of the touch coordinates, i.e. it determines which finger.
     * @param {Object} [doc] The document object.
     * @returns {Array} Contains the position as x,y-coordinates in the first resp. second component.
     */
    static getPosition(e, index, doc) {
        var i, len, evtTouches, posx = 0, posy = 0;
        if (!e) {
            e = window.event;
        }
        evtTouches = e['touches']; // iOS touch events
        // touchend events have their position in "changedTouches"
        if (Type.exists(evtTouches) && evtTouches.length === 0) {
            evtTouches = e.changedTouches;
        }
        if (Type.exists(index) && Type.exists(evtTouches)) {
            if (index === -1) {
                len = evtTouches.length;
                for (i = 0; i < len; i++) {
                    if (evtTouches[i]) {
                        e = evtTouches[i];
                        break;
                    }
                }
            }
            else {
                e = evtTouches[index];
            }
        }
        // Scrolling is ignored.
        // e.clientX is supported since IE6
        if (e.clientX) {
            posx = e.clientX;
            posy = e.clientY;
        }
        return [posx, posy];
    }
    /**
     * Calculates recursively the offset of the DOM element in which the board is stored.
     * @param {Object} obj A DOM element
     * @returns {Array} An array with the elements left and top offset.
     */
    static getOffset(obj) {
        var cPos, o = obj, o2 = obj, l = o.offsetLeft - o.scrollLeft, t = o.offsetTop - o.scrollTop;
        cPos = this.getCSSTransform([l, t], o);
        l = cPos[0];
        t = cPos[1];
        /*
         * In Mozilla and Webkit: offsetParent seems to jump at least to the next iframe,
         * if not to the body. In IE and if we are in an position:absolute environment
         * offsetParent walks up the DOM hierarchy.
         * In order to walk up the DOM hierarchy also in Mozilla and Webkit
         * we need the parentNode steps.
         */
        o = o.offsetParent;
        while (o) {
            l += o.offsetLeft;
            t += o.offsetTop;
            if (o.offsetParent) {
                l += o.clientLeft - o.scrollLeft;
                t += o.clientTop - o.scrollTop;
            }
            cPos = this.getCSSTransform([l, t], o);
            l = cPos[0];
            t = cPos[1];
            o2 = o2.parentNode;
            while (o2 !== o) {
                l += o2.clientLeft - o2.scrollLeft;
                t += o2.clientTop - o2.scrollTop;
                cPos = this.getCSSTransform([l, t], o2);
                l = cPos[0];
                t = cPos[1];
                o2 = o2.parentNode;
            }
            o = o.offsetParent;
        }
        return [l, t];
    }
    /**
     * Access CSS style sheets.
     * @param {Object} obj A DOM element
     * @param {String} stylename The CSS property to read.
     * @returns The value of the CSS property and <tt>undefined</tt> if it is not set.
     */
    static getStyle(obj, stylename) {
        var r, doc = obj.ownerDocument;
        // Non-IE
        // if (doc.defaultView && doc.defaultView.getComputedStyle) {
        r = doc.defaultView.getComputedStyle(obj, null).getPropertyValue(stylename);
        //     // IE
        // } else if (obj.currentStyle && Env.ieVersion >= 9) {
        //     r = obj.currentStyle[stylename];
        // } else {
        //     if (obj.style) {
        //         // make stylename lower camelcase
        //         stylename = stylename.replace(/-([a-z]|[0-9])/gi, function (all, letter) {
        //             return letter.toUpperCase();
        //         });
        //         r = obj.style[stylename];
        //     }
        // }
        return r;
    }
    /**
     * Reads css style sheets of a given element. This method is a getStyle wrapper and
     * defaults the read value to <tt>0</tt> if it can't be parsed as an integer value.
     * @param {DOMElement} el
     * @param {string} css
     * @returns {number}
     */
    static getProp(el, css) {
        var n = parseInt(this.getStyle(el, css), 10);
        return isNaN(n) ? 0 : n;
    }
    /**
     * Correct position of upper left corner in case of
     * a CSS transformation. Here, only translations are
     * extracted. All scaling transformations are corrected
     * in {@link Env.Board#getMousePosition}.
     * @param {Array} cPos Previously determined position
     * @param {Object} obj A DOM element
     * @returns {Array} The corrected position.
     */
    static getCSSTransform(cPos, obj) {
        var i, j, str, arrStr, start, len, len2, arr, t = [
            "transform",
            "webkitTransform",
            "MozTransform",
            "msTransform",
            "oTransform"
        ];
        // Take the first transformation matrix
        len = t.length;
        for (i = 0, str = ""; i < len; i++) {
            if (Type.exists(obj.style[t[i]])) {
                str = obj.style[t[i]];
                break;
            }
        }
        /**
         * Extract the coordinates and apply the transformation
         * to cPos
         */
        if (str !== "") {
            start = str.indexOf("(");
            if (start > 0) {
                len = str.length;
                arrStr = str.substring(start + 1, len - 1);
                arr = arrStr.split(",");
                for (j = 0, len2 = arr.length; j < len2; j++) {
                    arr[j] = parseFloat(arr[j]);
                }
                if (str.indexOf("matrix") === 0) {
                    cPos[0] += arr[4];
                    cPos[1] += arr[5];
                }
                else if (str.indexOf("translateX") === 0) {
                    cPos[0] += arr[0];
                }
                else if (str.indexOf("translateY") === 0) {
                    cPos[1] += arr[0];
                }
                else if (str.indexOf("translate") === 0) {
                    cPos[0] += arr[0];
                    cPos[1] += arr[1];
                }
            }
        }
        // Zoom is used by reveal.js
        if (Type.exists(obj.style.zoom)) {
            str = obj.style.zoom;
            if (str !== "") {
                cPos[0] *= parseFloat(str);
                cPos[1] *= parseFloat(str);
            }
        }
        return cPos;
    }
    /**
     * Scaling CSS transformations applied to the div element containing the JSXGraph constructions
     * are determined. In IE prior to 9, 'rotate', 'skew', 'skewX', 'skewY' are not supported.
     * @returns {Array} 3x3 transformation matrix without translation part. See {@link Env.Board#updateCSSTransforms}.
     */
    static getCSSTransformMatrix(obj) {
        var i, j, str, arrstr, arr, start, len, len2, st, doc = obj.ownerDocument, t = [
            "transform",
            "webkitTransform",
            "MozTransform",
            "msTransform",
            "oTransform"
        ], mat = [
            [1, 0, 0],
            [0, 1, 0],
            [0, 0, 1]
        ];
        // This should work on all browsers except IE 6-8
        if (doc.defaultView && doc.defaultView.getComputedStyle) {
            st = doc.defaultView.getComputedStyle(obj, null);
            str =
                st.getPropertyValue("-webkit-transform") ||
                    st.getPropertyValue("-moz-transform") ||
                    st.getPropertyValue("-ms-transform") ||
                    st.getPropertyValue("-o-transform") ||
                    st.getPropertyValue("transform");
        }
        else {
            // Take the first transformation matrix
            len = t.length;
            for (i = 0, str = ""; i < len; i++) {
                if (Type.exists(obj.style[t[i]])) {
                    str = obj.style[t[i]];
                    break;
                }
            }
        }
        // Convert and reorder the matrix for JSXGraph
        if (str !== "") {
            start = str.indexOf("(");
            if (start > 0) {
                len = str.length;
                arrstr = str.substring(start + 1, len - 1);
                arr = arrstr.split(",");
                for (j = 0, len2 = arr.length; j < len2; j++) {
                    arr[j] = parseFloat(arr[j]);
                }
                if (str.indexOf("matrix") === 0) {
                    mat = [
                        [1, 0, 0],
                        [0, arr[0], arr[1]],
                        [0, arr[2], arr[3]]
                    ];
                }
                else if (str.indexOf("scaleX") === 0) {
                    mat[1][1] = arr[0];
                }
                else if (str.indexOf("scaleY") === 0) {
                    mat[2][2] = arr[0];
                }
                else if (str.indexOf("scale") === 0) {
                    mat[1][1] = arr[0];
                    mat[2][2] = arr[1];
                }
            }
        }
        // CSS style zoom is used by reveal.js
        // Recursively search for zoom style entries.
        // This is necessary for reveal.js on webkit.
        // It fails if the user does zooming
        if (Type.exists(obj.style.zoom)) {
            str = obj.style.zoom;
            if (str !== "") {
                mat[1][1] *= parseFloat(str);
                mat[2][2] *= parseFloat(str);
            }
        }
        return mat;
    }
    /**
     * Process data in timed chunks. Data which takes long to process, either because it is such
     * a huge amount of data or the processing takes some time, causes warnings in browsers about
     * irresponsive scripts. To prevent these warnings, the processing is split into smaller pieces
     * called chunks which will be processed in serial order.
     * Copyright 2009 Nicholas C. Zakas. All rights reserved. MIT Licensed
     * @param {Array} items to do
     * @param {Function} process Function that is applied for every array item
     * @param {Object} context The scope of function process
     * @param {Function} callback This function is called after the last array element has been processed.
     */
    static timedChunk(items, process, context, callback) {
        //create a clone of the original
        var todo = items.slice(), timerFun = function () {
            var start = +new Date();
            do {
                process.call(context, todo.shift());
            } while (todo.length > 0 && +new Date() - start < 300);
            if (todo.length > 0) {
                window.setTimeout(timerFun, 1);
            }
            else {
                callback(items);
            }
        };
        window.setTimeout(timerFun, 1);
    }
    /**
     * Scale and vertically shift a DOM element (usually a JSXGraph div)
     * inside of a parent DOM
     * element which is set to fullscreen.
     * This is realized with a CSS transformation.
     *
     * @param  {String} wrap_id  id of the parent DOM element which is in fullscreen mode
     * @param  {String} inner_id id of the DOM element which is scaled and shifted
     * @param  {Object} doc      document object or shadow root
     * @param  {Number} scale    Relative size of the JSXGraph board in the fullscreen window.
     *
     * @private
     * @see Env.Board#toFullscreen
     * @see Env.Board#fullscreenListener
     *
     */
    static scaleJSXGraphDiv(wrap_id, inner_id, doc, scale) {
        var w, h, b, wi, hi, wo, ho, inner, scale_l, vshift_l, f = scale, ratio, pseudo_keys = [
            ":fullscreen",
            ":-webkit-full-screen",
            ":-moz-full-screen",
            ":-ms-fullscreen"
        ], len_pseudo = pseudo_keys.length, i;
        b = doc.getElementById(wrap_id).getBoundingClientRect();
        h = b.height;
        w = b.width;
        inner = doc.getElementById(inner_id);
        wo = inner._cssFullscreenStore.w;
        ho = inner._cssFullscreenStore.h;
        ratio = ho / wo;
        // Scale the div such that fits into the fullscreen.
        if (wo > w * f) {
            wo = w * f;
            ho = wo * ratio;
        }
        if (ho > h * f) {
            ho = h * f;
            wo = ho / ratio;
        }
        wi = wo;
        hi = ho;
        // Compare the code in this.setBoundingBox()
        if (ratio > 1) {
            // h > w
            if (ratio < h / w) {
                scale_l = w * f / wo;
            }
            else {
                scale_l = h * f / ho;
            }
        }
        else {
            // h <= w
            if (ratio < h / w) {
                scale_l = w * f / wo;
            }
            else {
                scale_l = h * f / ho;
            }
        }
        vshift_l = (h - hi) * 0.5;
        // Set a CSS properties to center the JSXGraph div horizontally and vertically
        // at the first position of the fullscreen pseudo classes.
        for (i = 0; i < len_pseudo; i++) {
            try {
                inner.style.width = wi + 'px !important';
                inner.style.height = hi + 'px !important';
                inner.style.margin = '0 auto';
                // Add the transform to a possibly already existing transform
                inner.style.transform = inner._cssFullscreenStore.transform +
                    ' matrix(' + scale_l + ',0,0,' + scale_l + ',0,' + vshift_l + ')';
                break;
            }
            catch (err) {
                Env.debug("Env.scaleJSXGraphDiv:\n" + err);
            }
        }
        if (i === len_pseudo) {
            Env.debug("Env.scaleJSXGraphDiv: Could not set any CSS property.");
        }
    }
    static debug(msg) {
        console.warn("Debug: " + msg);
    }
    static warn(msg) {
        console.warn("Warning: " + msg);
    }
    static deprecated(old, replace = '') {
        console.warn(`Deprecated:  '${old}', use: '${replace}' instead`);
    }
}

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */
/*global JXG:true, define: true, ActiveXObject:true, jxgBinFileReader:true, DOMParser:true, XMLHttpRequest:true, document:true, navigator:true*/
/*jslint nomen: true, plusplus: true*/
/**
 * The FileReader object bundles the file input capabilities of JSXGraph.
 */
//TODO ; is this file safe as static???
class JSXFileReader {
    //    public document:true, navigator:true*/
    static handleRemoteFile(url, board, format, async, encoding, callback) {
        // TODO: clean this up
        // let request: XMLHttpRequest
        // try {
        //     request = new XMLHttpRequest();
        //     if (format.toLowerCase() === "raw") {
        //         request.overrideMimeType("text/plain; charset=" + encoding);
        //     } else {
        //         request.overrideMimeType("text/xml; charset=" + encoding);
        //     }
        // } catch (e) {
        //     try {
        //         request = new ActiveXObject("Msxml2.XMLHTTP");
        //     } catch (ex) {
        //         try {
        //             request = new ActiveXObject("Microsoft.XMLHTTP");
        //         } catch (exc) {
        //             request = null;
        //         }
        //     }
        // }
        // if (!request) {
        //     JXG.debug("AJAX not activated!");
        //     return;
        // }
        // request.open("GET", url, async);
        // if (format.toLowerCase() === "raw") {
        //     this.cbp = function () {
        //         var req = request;
        //         if (req.readyState === 4) {
        //             board(req.responseText);
        //         }
        //     };
        // } else {
        //     this.cbp = function () {
        //         var req = request,
        //             text = "";
        //         if (req.readyState === 4) {
        //             // Hack for ancient IEs:
        //             // We use the Visual Basic stuff from below.
        //             if (
        //                 Type.exists(req.responseText) && //TODO: was  .responseStream) &&
        //                 // PK: zip, geogebra
        //                 // 31: gzip, cinderella
        //                 (req.responseText.slice(0, 2) === "PK" ||
        //                     Encoding.asciiCharCodeAt(req.responseText.slice(0, 1), 0) === 31)
        //             ) {
        //                 // After this, text contains the binary? zip-compressed string
        //                 text = Base64.decode(this.jxgBinFileReader(req));
        //             } else {
        //                 // This is for all browsers except ancient IEs.
        //                 text = req.responseText;
        //                 // console.log(text);
        //             }
        //             this.parseString(text, board, format, callback);
        //         }
        //     };
        // }
        // this.cb = Type.bind(this.cbp, this);
        // // Old style
        // request.onreadystatechange = this.cb;
        // try {
        //     request.send(null);
        // } catch (ex2) {
        //     throw new Error(
        //         "JSXGraph: A problem occurred while trying to read remote file '" + url + "'."
        //     );
        // }
    }
    /**
     *
     * @param {Blob} url The Blob or File from which to read
     * @param {JXG.Board} board
     * @param {String} format
     * @param {Boolean} async
     * @param {Function} callback
     *
     * @private
     */
    static handleLocalFile(url, board, format, async, encoding, callback) {
        if (!Type.exists(async)) {
            async = true;
        }
        if (format.toLowerCase() === "raw") {
            this.cbp = function (e) {
                board(e.target.result);
            };
        }
        else {
            this.cbp = function (e) {
                var text = e.target.result;
                //console.log(text);
                this.parseString(text, board, format, callback);
            };
        }
        this.cb = Type.bind(this.cbp, this);
        let reader = new FileReader();
        reader.onload = this.cb;
        if (format.toLowerCase() === "raw") {
            reader.readAsText(url);
        }
        else {
            reader.readAsText(url, encoding);
        }
    }
    /**
     * Opens a file using the given URL and passes the contents to {@link JXG.FileReader#parseString}
     * @param {String} url
     * @param {JXG.Board|function} board Either a board or in case <tt>format</tt> equals 'raw' this has to be a callback function.
     * @param {String} format The expected file format. Possible values are <dl>
     * <dt>raw</dt><dd>Raw text file. In this case <tt>board</tt> has to be a callback function.</dd>
     * <dt>geonext</dt><dd>Geonext File <a href="https://www.geonext.de">https://www.geonext.de</a></dd>
     * <dt>intergeo</dt><dd>Intergeo file format <a href="https://www.i2geo.net">https://www.i2geo.net</a></dd>
     * <dt>tracenpoche</dt><dd>Tracenpoche construction <a href="https://tracenpoche.sesamath.net/">https://tracenpoche.sesamath.net/</a></dd>
     * <dt>graph</dt><dd>Graph file</dd>
     * <dt>digraph</dt><dd>DiGraph file</dd>
     * <dt>geogebra</dt><dd>Geogebra File <a href="https://www.geogebra.org">https://www.geogebra.org</a></dd>
     * <dl><dt>cdy or cinderella</dt><dd>Cinderella (<a href="https://www.cinderella.de/">https://www.cinderella.de</a></dd>
     * </dl>
     * @param {Boolean} async Call ajax asynchonously.
     * @param {function} callback A function that is run when the board is ready.
     */
    static parseFileContent(url, board, format, async, encoding, callback) {
        if (Type.isString(url) || FileReader === undefined) {
            this.handleRemoteFile(url, board, format, async, encoding, callback);
        }
        else {
            this.handleLocalFile(url, board, format, async, encoding, callback);
        }
    }
    /**
     * Parses a given string according to the file format given in format.
     * @param {String} str Contents of the file.
     * @param {JXG.Board} board The board the construction in the file should be loaded in.
     * @param {String} format Possible values are <dl>
     * <dt>raw</dt><dd>Raw text file. In this case <tt>board</tt> has to be a callback function.</dd>
     * <dt>geonext</dt><dd>Geonext File <a href="https://www.geonext.de">https://www.geonext.de</a></dd>
     * <dt>intergeo</dt><dd>Intergeo file format <a href="https://www.i2geo.net">https://www.i2geo.net</a></dd>
     * <dt>tracenpoche</dt><dd>Tracenpoche construction <a href="https://tracenpoche.sesamath.net/">https://tracenpoche.sesamath.net/</a></dd>
     * <dt>graph</dt><dd>Graph file</dd>
     * <dt>digraph</dt><dd>DiGraph file</dd>
     * <dt>geogebra</dt><dd>Geogebra File <a href="https://www.geogebra.org">https://www.geogebra.org</a></dd>
     * <dl><dt>cdy or cinderella</dt><dd>Cinderella (<a href="https://www.cinderella.de/">https://www.cinderella.de</a></dd>
     * </dl>
     * @param {function} callback
     */
    static parseString(str, board, format = '', callback) {
        var Reader, read;
        format = format.toLowerCase();
        Reader = JXG.readers[format];
        if (Type.exists(Reader)) {
            read = new Reader(board, str);
            read.read();
        }
        else if (format === "jessiecode") ;
        else {
            throw new Error("JSXGraph: There is no reader available for '" + format + "'.");
        }
        if (Type.isFunction(callback)) {
            callback(board);
        }
    }
}
/**
 *
 * @param {String} url
 * @param {JXG.Board} board
 * @param {String} format
 * @param {Boolean} async
 * @param {Function} callback
 *
 * @private
 */
JSXFileReader.cbp = () => { };
//    public ActiveXObject
JSXFileReader.jxgBinFileReader = undefined;
JSXFileReader.DOMParser = undefined;
JSXFileReader.XMLHttpRequest = undefined;

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */
/*global JXG: true, define: true, AMprocessNode: true, MathJax: true, document: true, window: true */
/*
    nomen:    Allow underscores to indicate private class members. Might be replaced by local variables.
    plusplus: Only allowed in for-loops
    newcap:   AsciiMathMl exposes non-constructor functions beginning with upper case letters
*/
/*jslint nomen: true, plusplus: true, newcap: true, unparam: true*/
/*eslint no-unused-vars: "off"*/
/**
 * @fileoverview JSXGraph can use various technologies to render the contents of a construction, e.g.
 * SVG, VML, and HTML5 Canvas. To accomplish this, The rendering and the logic and control mechanisms
 * are completely separated from each other. Every rendering technology has it's own class, called
 * Renderer, e.g. SVGRenderer for SVG, the same for VML and Canvas. The common base for all available
 * renderers is the class AbstractRenderer defined in this file.
 */
/**
 * <p>This class defines the interface to the graphics part of JSXGraph. This class is an abstract class, it
 * actually does not render anything. This is up to the {@link JXG.SVGRenderer}* and {@link JXG.CanvasRenderer}
 * classes. We strongly discourage you from using the methods in these classes
 * directly. Only the methods which are defined in this class and are not marked as private are guaranteed
 * to exist in any renderer instance you can access via {@link JXG.Board#renderer}. But not all methods may
 * work as expected.</p>
 * <p>The methods of this renderer can be divided into different categories:
 * <dl>
 *     <dt>Draw basic elements</dt>
 *     <dd>In this category we find methods to draw basic elements like {@link JXG.Point} {@link JXG.Line}
 *     and {@link JXG.Curve} as well as assisting methods tightly bound to these basic painters. You do not
 *     need to implement these methods in a descendant renderer but instead implement the primitive drawing
 *     methods described below. This approach is encouraged when you're using a XML based rendering engine
 *     like VML and SVG. If you want to use a bitmap based rendering technique you are supposed to override
 *     these methods instead of the primitive drawing methods.</dd>
 *     <dt>Draw primitives</dt>
 *     <dd>This category summarizes methods to handle primitive nodes. As creation and management of these nodes
 *     is different among different the rendering techniques most of these methods are purely virtual and need
 *     proper implementation if you choose to not overwrite the basic element drawing methods.</dd>
 *     <dt>Attribute manipulation</dt>
 *     <dd>In XML based renders you have to manipulate XML nodes and their attributes to change the graphics.
 *     For that purpose attribute manipulation methods are defined to set the color, opacity, and other things.
 *     Please note that some of these methods are required in bitmap based renderers, too, because some elements
 *     like {@link JXG.Text} can be HTML nodes floating over the construction.</dd>
 *     <dt>Renderer control</dt>
 *     <dd>Methods to clear the drawing board or to stop and to resume the rendering engine.</dd>
 * </dl></p>
 * @class JXG.AbstractRenderer
 * @constructor
 * @see JXG.SVGRenderer
 * @see JXG.CanvasRenderer
 */
class AbstractRenderer {
    constructor() {
        // WHY THIS IS A CLASS INSTEAD OF A SINGLETON OBJECT:
        //
        // The renderers need to keep track of some stuff which is not always the same on different boards,
        // like enhancedRendering, reference to the container object, and resolution in VML. Sure, those
        // things could be stored in board. But they are rendering related and JXG.Board is already very
        // very big.
        //
        // And we can't save the rendering related data in {SVG,VML,Canvas}Renderer and make only the
        // JXG.AbstractRenderer a singleton because of that:
        //
        // Given an object o with property a set to true
        //     var o = {a: true};
        // and a class c doing nothing
        //     c = function() {};
        // Set c's prototype to o
        //     c.prototype = o;
        // and create an instance of c we get i.a to be true
        //     i = new c();
        //     i.a;
        //     > true
        // But we can overwrite this property via
        //     c.prototype.a = false;
        //     i.a;
        //     > false
        /**
         * The vertical offset for {@link Text} elements. Every {@link Text} element will
         * be placed this amount of pixels below the user given coordinates.
         * @type Number
         * @default 0
         */
        this.vOffsetText = 0;
        /**
         * If this property is set to <tt>true</tt> the visual properties of the elements are updated
         * on every update. Visual properties means: All the stuff stored in the
         * {@link JXG.GeometryElement#visProp} property won't be set if enhancedRendering is <tt>false</tt>
         * @type Boolean
         * @default true
         */
        this.enhancedRendering = true;
        /**
         * The HTML element that stores the JSXGraph board in it.
         * @type Node
         */
        this.container = null;
        /**
         * This is used to easily determine which renderer we are using
         * @example if (board.renderer.type === 'vml') {
         *     // do something
         * }
         * @type String
         */
        this.type = "";
        /**
         * True if the browsers' SVG engine supports foreignObject.
         * Not supported browsers are IE 9 - 11.
         * It is tested in svg renderer.
         *
         * @type Boolean
         * @private
         */
        this.supportsForeignObject = false;
        /**
         * Defines dash patterns. Sizes are in pixel.
         * Defined styles are:
         * <ol>
         * <li> 2 dash, 2 space</li>
         * <li> 5 dash, 5 space</li>
         * <li> 10 dash, 10 space</li>
         * <li> 20 dash, 20 space</li>
         * <li> 20 dash, 10 space, 10 dash, 10 space</li>
         * <li> 20 dash, 5 space, 10 dash, 5 space</li>
         * <li> 0 dash, 5 space (dotted line)</li>
         * </ol>
         * This means, the numbering is <b>1-based</b>.
         * Solid lines are set with dash:0.
         * If the object's attribute "dashScale:true" the dash pattern is multiplied by
         * strokeWidth / 2.
         *
         * @type Array
         * @default [[2, 2], [5, 5], [10, 10], [20, 20], [20, 10, 10, 10], [20, 5, 10, 5], [0, 5]]
         * @see JXG.GeometryElement#dash
         * @see JXG.GeometryElement#dashScale
         */
        this.dashArray = [
            [2, 2],
            [5, 5],
            [10, 10],
            [20, 20],
            [20, 10, 10, 10],
            [20, 5, 10, 5],
            [0, 5]
        ];
    }
    /* ********* Private methods *********** */
    /**
     * Update visual properties, but only if {@link JXG.AbstractRenderer#enhancedRendering} or <tt>enhanced</tt> is set to true.
     * @param {JXG.GeometryElement} el The element to update
     * @param {Object} [not={}] Select properties you don't want to be updated: <tt>{fill: true, dash: true}</tt> updates
     * everything except for fill and dash. Possible values are <tt>stroke, fill, dash, shadow, gradient</tt>.
     * @param {Boolean} [enhanced=false] If true, {@link JXG.AbstractRenderer#enhancedRendering} is assumed to be true.
     * @private
     */
    _updateVisual(el, not = {}, enhanced = false) {
        if (enhanced || this.enhancedRendering) {
            not = not || {};
            this.setObjectTransition(el);
            if (!el.evalVisProp('draft')) {
                if (!not.stroke) {
                    if (el.highlighted) {
                        this.setObjectStrokeColor(el, el.evalVisProp('highlightstrokecolor'), el.evalVisProp('highlightstrokeopacity'));
                        this.setObjectStrokeWidth(el, el.evalVisProp('highlightstrokewidth'));
                    }
                    else {
                        this.setObjectStrokeColor(el, el.evalVisProp('strokecolor'), el.evalVisProp('strokeopacity'));
                        this.setObjectStrokeWidth(el, el.evalVisProp('strokewidth'));
                    }
                }
                if (!not.fill) {
                    if (el.highlighted) {
                        this.setObjectFillColor(el, el.evalVisProp('highlightfillcolor'), el.evalVisProp('highlightfillopacity'));
                    }
                    else {
                        this.setObjectFillColor(el, el.evalVisProp('fillcolor'), el.evalVisProp('fillopacity'));
                    }
                }
                if (!not.dash) {
                    this.setDashStyle(el);
                }
                if (!not.shadow) {
                    this.setShadow(el);
                }
                // if (!not.gradient) {
                //     // this.setGradient(el);
                //     this.setShadow(el);
                // }
                if (!not.tabindex) {
                    this.setTabindex(el);
                }
            }
            else {
                this.setDraft(el);
            }
            if (el.highlighted) {
                this.setCssClass(el, el.evalVisProp('highlightcssclass'));
            }
            else {
                this.setCssClass(el, el.evalVisProp('cssclass'));
            }
            if (el.evalVisProp('aria.enabled')) {
                this.setARIA(el);
            }
        }
    }
    /**
     * Get information if element is highlighted.
     * @param {JXG.GeometryElement} el The element which is tested for being highlighted.
     * @returns {String} 'highlight' if highlighted, otherwise the ampty string '' is returned.
     * @private
     */
    _getHighlighted(el) {
        var isTrace = false, hl;
        if (!Type.exists(el.board) || !Type.exists(el.board.highlightedObjects)) {
            // This case handles trace elements.
            // To make them work, we simply neglect highlighting.
            isTrace = true;
        }
        if (!isTrace && Type.exists(el.board.highlightedObjects[el.id])) {
            hl = "highlight";
        }
        else {
            hl = "";
        }
        return hl;
    }
    /* ********* Point related stuff *********** */
    /**
     * Draws a point on the {@link JXG.Board}.
     * @param {JXG.Point} el Reference to a {@link JXG.Point} object that has to be drawn.
     * @see Point
     * @see JXG.Point
     * @see JXG.AbstractRenderer#updatePoint
     * @see JXG.AbstractRenderer#changePointStyle
     */
    drawPoint(el) {
        var prim;
        // Sometimes el is not a real point and lacks the methods of a JXG.Point instance,
        // in these cases to not use el directly.
        let face = Options.normalizePointFace(el.evalVisProp('face'));
        // Determine how the point looks like
        if (face === "o") {
            prim = "ellipse";
        }
        else if (face === "[]") {
            prim = "rect";
        }
        else {
            // cross/x, diamond/<>, triangleup/A/^, triangledown/v, triangleleft/<,
            // triangleright/>, plus/+, |, -
            prim = "path";
        }
        console.log('drawPoint', this.createPrim(prim, el.id));
        console.log(el.evalVisProp('layer'));
        el.rendNode = this.appendChildPrim(this.createPrim(prim, el.id), el.evalVisProp('layer'));
        this.appendNodesToElement(el, prim);
        // Adjust visual properties
        this._updateVisual(el, { dash: true, shadow: true }, true);
        // By now we only created the xml nodes and set some styles, in updatePoint
        // the attributes are filled with data.
        this.updatePoint(el);
    }
    /**
     * Updates visual appearance of the renderer element assigned to the given {@link JXG.Point}.
     * @param {JXG.Point} el Reference to a {@link JXG.Point} object, that has to be updated.
     * @see Point
     * @see JXG.Point
     * @see JXG.AbstractRenderer#drawPoint
     * @see JXG.AbstractRenderer#changePointStyle
     */
    updatePoint(el) {
        var size = el.evalVisProp('size'), 
        // sometimes el is not a real point and lacks the methods of a JXG.Point instance,
        // in these cases to not use el directly.
        face = Options.normalizePointFace(el.evalVisProp('face')), unit = el.evalVisProp('sizeunit'), zoom = el.evalVisProp('zoom'), s1;
        if (!isNaN(el.coords.scrCoords[2] + el.coords.scrCoords[1])) {
            if (unit === "user") {
                size *= Math.sqrt(Math.abs(el.board.unitX * el.board.unitY));
            }
            size *= !el.board || !zoom ? 1.0 : Math.sqrt(el.board.zoomX * el.board.zoomY);
            s1 = size === 0 ? 0 : size + 1;
            if (face === "o") {
                // circle
                this.updateEllipsePrim(el.rendNode, el.coords.scrCoords[1], el.coords.scrCoords[2], s1, s1);
            }
            else if (face === "[]") {
                // rectangle
                this.updateRectPrim(el.rendNode, el.coords.scrCoords[1] - size, el.coords.scrCoords[2] - size, size * 2, size * 2);
            }
            else {
                // x, +, <>, <<>>, ^, v, <, >
                this.updatePathPrim(el.rendNode, this.updatePathStringPoint(el, size, face), el.board);
            }
            this._updateVisual(el, { dash: false, shadow: false });
            this.setShadow(el);
        }
    }
    /**
     * Changes the style of a {@link JXG.Point}. This is required because the point styles differ in what
     * elements have to be drawn, e.g. if the point is marked by a "x" or a "+" two lines are drawn, if
     * it's marked by spot a circle is drawn. This method removes the old renderer element(s) and creates
     * the new one(s).
     * @param {JXG.Point} el Reference to a {@link JXG.Point} object, that's style is changed.
     * @see Point
     * @see JXG.Point
     * @see JXG.AbstractRenderer#updatePoint
     * @see JXG.AbstractRenderer#drawPoint
     */
    changePointStyle(el) {
        var node = this.getElementById(el.id);
        // remove the existing point rendering node
        if (Type.exists(node)) {
            this.remove(node);
        }
        // and make a new one
        this.drawPoint(el);
        Type.clearVisPropOld(el);
        if (!el.visPropCalc.visible) {
            this.display(el, false);
        }
        if (el.evalVisProp('draft')) {
            this.setDraft(el);
        }
    }
    /* ********* Line related stuff *********** */
    /**
     * Draws a line on the {@link JXG.Board}.
     * @param {JXG.Line} el Reference to a line object, that has to be drawn.
     * @see Line
     * @see JXG.Line
     * @see JXG.AbstractRenderer#updateLine
     */
    drawLine(el) {
        el.rendNode = this.appendChildPrim(this.createPrim("line", el.id), el.evalVisProp('layer'));
        this.appendNodesToElement(el, "lines");
        this.updateLine(el);
    }
    /**
     * Updates visual appearance of the renderer element assigned to the given {@link JXG.Line}.
     * @param {JXG.Line} el Reference to the {@link JXG.Line} object that has to be updated.
     * @see Line
     * @see JXG.Line
     * @see JXG.AbstractRenderer#drawLine
     */
    updateLine(el) {
        this._updateVisual(el);
        this.updatePathWithArrowHeads(el); // Calls the renderer primitive
        this.setLineCap(el);
    }
    /* ********* Curve related stuff *********** */
    /**
     * Draws a {@link JXG.Curve} on the {@link JXG.Board}.
     * @param {JXG.Curve} el Reference to a graph object, that has to be plotted.
     * @see Curve
     * @see JXG.Curve
     * @see JXG.AbstractRenderer#updateCurve
     */
    drawCurve(el) {
        el.rendNode = this.appendChildPrim(this.createPrim("path", el.id), el.evalVisProp('layer'));
        this.appendNodesToElement(el, "path");
        this.updateCurve(el);
    }
    /**
     * Updates visual appearance of the renderer element assigned to the given {@link JXG.Curve}.
     * @param {JXG.Curve} el Reference to a {@link JXG.Curve} object, that has to be updated.
     * @see Curve
     * @see JXG.Curve
     * @see JXG.AbstractRenderer#drawCurve
     */
    updateCurve(el) {
        this._updateVisual(el);
        this.updatePathWithArrowHeads(el); // Calls the renderer primitive
        this.setLineCap(el);
    }
    /* ********* Arrow heads and related stuff *********** */
    /**
     * Handles arrow heads of a line or curve element and calls the renderer primitive.
     *
     * @param {JXG.GeometryElement} el Reference to a line or curve object that has to be drawn.
     * @param {Boolean} doHighlight
     *
     * @private
     * @see Line
     * @see JXG.Line
     * @see Curve
     * @see JXG.Curve
     * @see JXG.AbstractRenderer#updateLine
     * @see JXG.AbstractRenderer#updateCurve
     * @see JXG.AbstractRenderer#makeArrows
     * @see JXG.AbstractRenderer#getArrowHeadData
     */
    updatePathWithArrowHeads(el, doHighlight) {
        var hl = doHighlight ? 'highlight' : '', w, arrowData;
        if (doHighlight && el.evalVisProp('highlightstrokewidth')) {
            w = Math.max(el.evalVisProp('highlightstrokewidth'), el.evalVisProp('strokewidth'));
        }
        else {
            w = el.evalVisProp('strokewidth');
        }
        // Get information if there are arrow heads and how large they are.
        arrowData = this.getArrowHeadData(el, w, hl);
        // Create the SVG nodes if necessary
        this.makeArrows(el, arrowData);
        // Draw the paths with arrow heads
        if (el.elementClass === OBJECT_CLASS.LINE) {
            this.updateLineWithEndings(el, arrowData);
        }
        else if (el.elementClass === OBJECT_CLASS.CURVE) {
            this.updatePath(el);
        }
        this.setArrowSize(el, arrowData);
    }
    /**
     * This method determines some data about the line endings of this element.
     * If there are arrow heads, the offset is determined so that no parts of the line stroke
     * lap over the arrow head.
     * <p>
     * The returned object also contains the types of the arrow heads.
     *
     * @param {JXG.GeometryElement} el JSXGraph line or curve element
     * @param {Number} strokewidth strokewidth of the element
     * @param {String} hl Ither 'highlight' or empty string
     * @returns {Object} object containing the data
     *
     * @private
     */
    getArrowHeadData(el, strokewidth, hl) {
        var minlen = JSXMath.eps, typeFirst, typeLast, offFirst = 0, offLast = 0, sizeFirst = 0, sizeLast = 0, ev_fa = el.evalVisProp('firstarrow'), ev_la = el.evalVisProp('lastarrow'), off, size;
        /*
           Handle arrow heads.

           The default arrow head is an isosceles triangle with base length 10 units and height 10 units.
           These 10 units are scaled to strokeWidth * arrowSize pixels.
        */
        if (ev_fa || ev_la) {
            if (Type.exists(ev_fa.type)) {
                typeFirst = el.eval(ev_fa.type);
            }
            else {
                if (el.elementClass === OBJECT_CLASS.LINE) {
                    typeFirst = 1;
                }
                else {
                    typeFirst = 7;
                }
            }
            if (Type.exists(ev_la.type)) {
                typeLast = el.eval(ev_la.type);
            }
            else {
                if (el.elementClass === OBJECT_CLASS.LINE) {
                    typeLast = 1;
                }
                else {
                    typeLast = 7;
                }
            }
            if (ev_fa) {
                size = 6;
                if (Type.exists(ev_fa.size)) {
                    size = el.eval(ev_fa.size);
                }
                if (hl !== "" && Type.exists(ev_fa[hl + "size"])) {
                    size = el.eval(ev_fa[hl + "size"]);
                }
                off = strokewidth * size;
                if (typeFirst === 2) {
                    off *= 0.5;
                    minlen += strokewidth * size;
                }
                else if (typeFirst === 3) {
                    off = (strokewidth * size) / 3;
                    minlen += strokewidth;
                }
                else if (typeFirst === 4 || typeFirst === 5 || typeFirst === 6) {
                    off = (strokewidth * size) / 1.5;
                    minlen += strokewidth * size;
                }
                else if (typeFirst === 7) {
                    off = 0;
                    size = 10;
                    minlen += strokewidth;
                }
                else {
                    minlen += strokewidth * size;
                }
                offFirst += off;
                sizeFirst = size;
            }
            if (ev_la) {
                size = 6;
                if (Type.exists(ev_la.size)) {
                    size = el.eval(ev_la.size);
                }
                if (hl !== "" && Type.exists(ev_la[hl + "size"])) {
                    size = el.eval(ev_la[hl + "size"]);
                }
                off = strokewidth * size;
                if (typeLast === 2) {
                    off *= 0.5;
                    minlen += strokewidth * size;
                }
                else if (typeLast === 3) {
                    off = (strokewidth * size) / 3;
                    minlen += strokewidth;
                }
                else if (typeLast === 4 || typeLast === 5 || typeLast === 6) {
                    off = (strokewidth * size) / 1.5;
                    minlen += strokewidth * size;
                }
                else if (typeLast === 7) {
                    off = 0;
                    size = 10;
                    minlen += strokewidth;
                }
                else {
                    minlen += strokewidth * size;
                }
                offLast += off;
                sizeLast = size;
            }
        }
        el.visPropCalc.typeFirst = typeFirst;
        el.visPropCalc.typeLast = typeLast;
        return {
            evFirst: ev_fa,
            evLast: ev_la,
            typeFirst: typeFirst,
            typeLast: typeLast,
            offFirst: offFirst,
            offLast: offLast,
            sizeFirst: sizeFirst,
            sizeLast: sizeLast,
            showFirst: 1, // Show arrow head. 0 if the distance is too small
            showLast: 1, // Show arrow head. 0 if the distance is too small
            minLen: minlen,
            strokeWidth: strokewidth
        };
    }
    /**
     * Corrects the line length if there are arrow heads, such that
     * the arrow ends exactly at the intended position.
     * Calls the renderer method to draw the line.
     *
     * @param {JXG.Line} el Reference to a line object, that has to be drawn
     * @param {Object} arrowData Data concerning possible arrow heads
     *
     * @returns {JXG.AbstractRenderer} Reference to the renderer
     *
     * @private
     * @see Line
     * @see JXG.Line
     * @see JXG.AbstractRenderer#updateLine
     * @see JXG.AbstractRenderer#getPositionArrowHead
     *
     */
    updateLineWithEndings(el, arrowData) {
        var c1, c2, 
        // useTotalLength = true,
        margin = null;
        c1 = new Coords$1(COORDS_BY.USER, el.point1.coords.usrCoords, el.board);
        c2 = new Coords$1(COORDS_BY.USER, el.point2.coords.usrCoords, el.board);
        margin = el.evalVisProp('margin');
        Geometry.calcStraight(el, c1, c2, margin);
        this.handleTouchpoints(el, c1, c2, arrowData);
        this.getPositionArrowHead(el, c1, c2, arrowData);
        this.updateLinePrim(el.rendNode, c1.scrCoords[1], c1.scrCoords[2], c2.scrCoords[1], c2.scrCoords[2], el.board);
        return this;
    }
    /**
     *
     * Calls the renderer method to draw a curve.
     *
     * @param {JXG.GeometryElement} el Reference to a line object, that has to be drawn.
     * @returns {JXG.AbstractRenderer} Reference to the renderer
     *
     * @private
     * @see Curve
     * @see JXG.Curve
     * @see JXG.AbstractRenderer#updateCurve
     *
     */
    updatePath(el) {
        if (el.evalVisProp('handdrawing')) {
            this.updatePathPrim(el.rendNode, this.updatePathStringBezierPrim(el), el.board);
        }
        else {
            this.updatePathPrim(el.rendNode, this.updatePathStringPrim(el), el.board);
        }
        return this;
    }
    /**
     * Shorten the length of a line element such that the arrow head touches
     * the start or end point and such that the arrow head ends exactly
     * at the start / end position of the line.
     * <p>
     * The Coords objects c1 and c2 are changed in place. In object a, the Boolean properties
     * 'showFirst' and 'showLast' are set.
     *
     * @param  {JXG.Line} el Reference to the line object that gets arrow heads.
     * @param  {JXG.Coords} c1  Coords of the first point of the line (after {@link JXG.Math.Geometry#calcStraight}).
     * @param  {JXG.Coords} c2  Coords of the second point of the line (after {@link JXG.Math.Geometry#calcStraight}).
     * @param  {Object}  a Object { evFirst: Boolean, evLast: Boolean} containing information about arrow heads.
     * @see JXG.AbstractRenderer#getArrowHeadData
     *
     */
    getPositionArrowHead(el, c1, c2, a) {
        var d, d1x, d1y, d2x, d2y;
        //    Handle arrow heads.
        //    The default arrow head (type==1) is an isosceles triangle with base length 10 units and height 10 units.
        //    These 10 units are scaled to strokeWidth * arrowSize pixels.
        if (a.evFirst || a.evLast) {
            // Correct the position of the arrow heads
            d1x = d1y = d2x = d2y = 0.0;
            d = c1.distance(COORDS_BY.SCREEN, c2);
            if (a.evFirst && el.board.renderer.type !== "vml") {
                if (d >= a.minLen) {
                    d1x = ((c2.scrCoords[1] - c1.scrCoords[1]) * a.offFirst) / d;
                    d1y = ((c2.scrCoords[2] - c1.scrCoords[2]) * a.offFirst) / d;
                }
                else {
                    a.showFirst = 0;
                }
            }
            if (a.evLast && el.board.renderer.type !== "vml") {
                if (d >= a.minLen) {
                    d2x = ((c2.scrCoords[1] - c1.scrCoords[1]) * a.offLast) / d;
                    d2y = ((c2.scrCoords[2] - c1.scrCoords[2]) * a.offLast) / d;
                }
                else {
                    a.showLast = 0;
                }
            }
            c1.setCoordinates(COORDS_BY.SCREEN, [c1.scrCoords[1] + d1x, c1.scrCoords[2] + d1y], false, true);
            c2.setCoordinates(COORDS_BY.SCREEN, [c2.scrCoords[1] - d2x, c2.scrCoords[2] - d2y], false, true);
        }
        return this;
    }
    /**
     * Handle touchlastpoint / touchfirstpoint
     *
     * @param {JXG.GeometryElement} el
     * @param {JXG.Coords} c1 Coordinates of the start of the line. The coordinates are changed in place.
     * @param {JXG.Coords} c2 Coordinates of the end of the line. The coordinates are changed in place.
     * @param {Object} a
     * @see JXG.AbstractRenderer#getArrowHeadData
     */
    handleTouchpoints(el, c1, c2, a) {
        var s1, s2, d, d1x, d1y, d2x, d2y;
        if (a.evFirst || a.evLast) {
            d = d1x = d1y = d2x = d2y = 0.0;
            s1 = el.point1.evalVisProp('size') +
                el.point1.evalVisProp('strokewidth');
            s2 = el.point2.evalVisProp('size') +
                el.point2.evalVisProp('strokewidth');
            // Handle touchlastpoint /touchfirstpoint
            if (a.evFirst && el.evalVisProp('touchfirstpoint') &&
                el.point1.evalVisProp('visible')) {
                d = c1.distance(COORDS_BY.SCREEN, c2);
                //if (d > s) {
                d1x = ((c2.scrCoords[1] - c1.scrCoords[1]) * s1) / d;
                d1y = ((c2.scrCoords[2] - c1.scrCoords[2]) * s1) / d;
                //}
            }
            if (a.evLast && el.evalVisProp('touchlastpoint') &&
                el.point2.evalVisProp('visible')) {
                d = c1.distance(COORDS_BY.SCREEN, c2);
                //if (d > s) {
                d2x = ((c2.scrCoords[1] - c1.scrCoords[1]) * s2) / d;
                d2y = ((c2.scrCoords[2] - c1.scrCoords[2]) * s2) / d;
                //}
            }
            c1.setCoordinates(COORDS_BY.SCREEN, [c1.scrCoords[1] + d1x, c1.scrCoords[2] + d1y], false, true);
            c2.setCoordinates(COORDS_BY.SCREEN, [c2.scrCoords[1] - d2x, c2.scrCoords[2] - d2y], false, true);
        }
        return this;
    }
    /**
     * Set the arrow head size.
     *
     * @param {JXG.GeometryElement} el Reference to a line or curve object that has to be drawn.
     * @param {Object} arrowData Data concerning possible arrow heads
     * @returns {JXG.AbstractRenderer} Reference to the renderer
     *
     * @private
     * @see Line
     * @see JXG.Line
     * @see Curve
     * @see JXG.Curve
     * @see JXG.AbstractRenderer#updatePathWithArrowHeads
     * @see JXG.AbstractRenderer#getArrowHeadData
     */
    setArrowSize(el, a) {
        if (a.evFirst) {
            this._setArrowWidth(el.rendNodeTriangleStart, a.showFirst * a.strokeWidth, el.rendNode, a.sizeFirst);
        }
        if (a.evLast) {
            this._setArrowWidth(el.rendNodeTriangleEnd, a.showLast * a.strokeWidth, el.rendNode, a.sizeLast);
        }
        return this;
    }
    /* ********* Ticks related stuff *********** */
    /**
     * Creates a rendering node for ticks added to a line.
     * @param {JXG.Line} el A arbitrary line.
     * @see Line
     * @see Ticks
     * @see JXG.Line
     * @see JXG.Ticks
     * @see JXG.AbstractRenderer#updateTicks
     */
    drawTicks(el) {
        el.rendNode = this.appendChildPrim(this.createPrim("path", el.id), el.evalVisProp('layer'));
        this.appendNodesToElement(el, "path");
    }
    /* ********* Circle related stuff *********** */
    /**
     * Draws a {@link JXG.Circle}
     * @param {JXG.Circle} el Reference to a {@link JXG.Circle} object that has to be drawn.
     * @see Circle
     * @see JXG.Circle
     * @see JXG.AbstractRenderer#updateEllipse
     */
    drawEllipse(el) {
        el.rendNode = this.appendChildPrim(this.createPrim("ellipse", el.id), el.evalVisProp('layer'));
        this.appendNodesToElement(el, "ellipse");
        this.updateEllipse(el);
    }
    /**
     * Updates visual appearance of a given {@link JXG.Circle} on the {@link JXG.Board}.
     * @param {JXG.Circle} el Reference to a {@link JXG.Circle} object, that has to be updated.
     * @see Circle
     * @see JXG.Circle
     * @see JXG.AbstractRenderer#drawEllipse
     */
    updateEllipse(el) {
        this._updateVisual(el);
        var radius = el.Radius();
        if (
        /*radius > 0.0 &&*/
        Math.abs(el.center.coords.usrCoords[0]) > JSXMath.eps &&
            !isNaN(radius + el.center.coords.scrCoords[1] + el.center.coords.scrCoords[2]) &&
            radius * el.board.unitX < 2000000) {
            this.updateEllipsePrim(el.rendNode, el.center.coords.scrCoords[1], el.center.coords.scrCoords[2], radius * el.board.unitX, radius * el.board.unitY);
        }
        this.setLineCap(el);
    }
    /* ********* Polygon related stuff *********** */
    /**
     * Draws a {@link JXG.Polygon} on the {@link JXG.Board}.
     * @param {JXG.Polygon} el Reference to a Polygon object, that is to be drawn.
     * @see Polygon
     * @see JXG.Polygon
     * @see JXG.AbstractRenderer#updatePolygon
     */
    drawPolygon(el) {
        el.rendNode = this.appendChildPrim(this.createPrim("polygon", el.id), el.evalVisProp('layer'));
        this.appendNodesToElement(el, "polygon");
        this.updatePolygon(el);
    }
    /**
     * Updates properties of a {@link JXG.Polygon}'s rendering node.
     * @param {JXG.Polygon} el Reference to a {@link JXG.Polygon} object, that has to be updated.
     * @see Polygon
     * @see JXG.Polygon
     * @see JXG.AbstractRenderer#drawPolygon
     */
    updatePolygon(el) {
        // Here originally strokecolor wasn't updated but strokewidth was.
        // But if there's no strokecolor i don't see why we should update strokewidth.
        this._updateVisual(el, { stroke: true, dash: true });
        this.updatePolygonPrim(el.rendNode, el);
    }
    /* ********* Text related stuff *********** */
    /**
     * Displays a {@link JXG.Text} on the {@link JXG.Board} by putting a HTML div over it.
     * @param {JXG.Text} el Reference to an {@link JXG.Text} object, that has to be displayed
     * @see Text
     * @see JXG.Text
     * @see JXG.AbstractRenderer#drawInternalText
     * @see JXG.AbstractRenderer#updateText
     * @see JXG.AbstractRenderer#updateInternalText
     * @see JXG.AbstractRenderer#updateTextStyle
     */
    drawText(el) {
        var node, z, level, ev_visible;
        console.log('drawText', el, el.evalVisProp('display'));
        if (this.container !== null) {
            if (el.evalVisProp('display') === "html" &&
                Env.isBrowser() &&
                this.type !== "no") {
                node = this.container.ownerDocument.createElement("div");
                //node = this.container.ownerDocument.createElementNS('http://www.w3.org/1999/xhtml', 'div'); //
                node.style.position = "absolute";
                node.className = el.evalVisProp('cssclass');
                level = el.evalVisProp('layer');
                if (!Type.exists(level)) {
                    // trace nodes have level not set
                    level = 0;
                }
                if (this.container.style.zIndex === "") {
                    z = 0;
                }
                else {
                    z = parseInt(this.container.style.zIndex, 10);
                }
                node.style.zIndex = z + level;
                this.container.appendChild(node);
                el.rendNode = node; // TODO tbtb - added but i think this is wrong
                node.setAttribute("id", this.container.id + "_" + el.id);
            }
            else {
                node = this.drawInternalText(el);
                el.rendNode = node;
                el.htmlStr = "";
                // Set el.visPropCalc.visible
                if (el.visProp.islabel && Type.exists(el.visProp.anchor)) {
                    ev_visible = el.visProp.anchor.evalVisProp('visible');
                    el.prepareUpdate().updateVisibility(ev_visible);
                }
                else {
                    el.prepareUpdate().updateVisibility();
                }
                this.updateText(el);
            }
        }
        else {
            throw new Error('container was null');
        }
        return node;
    }
    /**
     * Updates visual properties of an already existing {@link JXG.Text} element.
     * @param {JXG.Text} el Reference to an {@link JXG.Text} object, that has to be updated.
     * @see Text
     * @see JXG.Text
     * @see JXG.AbstractRenderer#drawText
     * @see JXG.AbstractRenderer#drawInternalText
     * @see JXG.AbstractRenderer#updateInternalText
     * @see JXG.AbstractRenderer#updateTextStyle
     */
    updateText(el) {
        console.warn('abstract: updating Text', el.content, el);
        var content = el.plaintext, v, c, parentNode, node, 
        // scale, vshift,
        // id, wrap_id,
        ax, ay, angle, co, si, to_h, to_v;
        if (el.visPropCalc.visible) {
            this.updateTextStyle(el, false);
            if (el.evalVisProp('display') === "html" && this.type !== "no") {
                // Set the position
                if (!isNaN(el.coords.scrCoords[1] + el.coords.scrCoords[2])) {
                    // Horizontal
                    c = el.coords.scrCoords[1];
                    // webkit seems to fail for extremely large values for c.
                    c = Math.abs(c) < 1000000 ? c : 1000000;
                    ax = el.getAnchorX();
                    if (ax === "right") {
                        // v = Math.floor(el.board.canvasWidth - c);
                        v = el.board.canvasWidth - c;
                        to_h = "right";
                    }
                    else if (ax === "middle") {
                        // v = Math.floor(c - 0.5 * el.size[0]);
                        v = c - 0.5 * el.size[0];
                        to_h = "center";
                    }
                    else {
                        // 'left'
                        // v = Math.floor(c);
                        v = c;
                        to_h = "left";
                    }
                    // This may be useful for foreignObj.
                    //if (window.devicePixelRatio !== undefined) {
                    //v *= window.devicePixelRatio;
                    //}
                    if (el.visPropOld.left !== ax + v) {
                        if (ax === "right") {
                            el.rendNode.style.right = v + "px";
                            el.rendNode.style.left = "auto";
                        }
                        else {
                            el.rendNode.style.left = v + "px";
                            el.rendNode.style.right = "auto";
                        }
                        el.visPropOld.left = ax + v;
                    }
                    // Vertical
                    c = el.coords.scrCoords[2] + this.vOffsetText;
                    c = Math.abs(c) < 1000000 ? c : 1000000;
                    ay = el.getAnchorY();
                    if (ay === "bottom") {
                        // v = Math.floor(el.board.canvasHeight - c);
                        v = el.board.canvasHeight - c;
                        to_v = "bottom";
                    }
                    else if (ay === "middle") {
                        // v = Math.floor(c - 0.5 * el.size[1]);
                        v = c - 0.5 * el.size[1];
                        to_v = "center";
                    }
                    else {
                        // top
                        // v = Math.floor(c);
                        v = c;
                        to_v = "top";
                    }
                    // This may be useful for foreignObj.
                    //if (window.devicePixelRatio !== undefined) {
                    //v *= window.devicePixelRatio;
                    //}
                    if (el.visPropOld.top !== ay + v) {
                        if (ay === "bottom") {
                            el.rendNode.style.top = "auto";
                            el.rendNode.style.bottom = v + "px";
                        }
                        else {
                            el.rendNode.style.bottom = "auto";
                            el.rendNode.style.top = v + "px";
                        }
                        el.visPropOld.top = ay + v;
                    }
                }
                // Set the content
                if (el.htmlStr !== content) {
                    try {
                        if (el.type === OBJECT_TYPE.BUTTON) {
                            el.rendNodeButton.innerHTML = content;
                        }
                        else if (el.type === OBJECT_TYPE.CHECKBOX ||
                            el.type === OBJECT_TYPE.INPUT) {
                            el.rendNodeLabel.innerHTML = content;
                        }
                        else {
                            el.rendNode.innerHTML = content;
                        }
                    }
                    catch (e) {
                        // Setting innerHTML sometimes fails in IE8.
                        // A workaround is to take the node off the DOM, assign innerHTML,
                        // then append back.
                        // Works for text elements as they are absolutely positioned.
                        parentNode = el.rendNode.parentNode;
                        el.rendNode.parentNode.removeChild(el.rendNode);
                        el.rendNode.innerHTML = content;
                        parentNode.appendChild(el.rendNode);
                    }
                    el.htmlStr = content;
                    if (el.evalVisProp('usemathjax')) {
                        // Typesetting directly might not work because MathJax was not loaded completely
                        try {
                            if (Window.MathJax.typeset) {
                                // Version 3
                                Window.MathJax.typeset([el.rendNode]);
                            }
                            else {
                                // Version 2
                                Window.MathJax.Hub.Queue(["Typeset", window.MathJax.Hub, el.rendNode]);
                            }
                            // Obsolete:
                            // // Restore the transformation necessary for fullscreen mode
                            // // MathJax removes it when handling dynamic content
                            // id = el.board.container;
                            // wrap_id = "fullscreenwrap_" + id;
                            // if (document.getElementById(wrap_id)) {
                            //     scale = el.board.containerObj._cssFullscreenStore.scale;
                            //     vshift = el.board.containerObj._cssFullscreenStore.vshift;
                            //     Env.scaleJSXGraphDiv(
                            //         "#" + wrap_id,
                            //         "#" + id,
                            //         scale,
                            //         vshift
                            //     );
                            // }
                        }
                        catch (e) {
                            JXG.debug("MathJax (not yet) loaded");
                        }
                    }
                    else if (el.evalVisProp('usekatex')) {
                        try {
                            // Checkboxes et. al. do not possess rendNodeLabel during the first update.
                            // In this case node will be undefined and not rendered by KaTeX.
                            if (el.rendNode.innerHTML.indexOf('<span') === 0 &&
                                el.rendNode.innerHTML.indexOf('<label') > 0 &&
                                (el.rendNode.innerHTML.indexOf('<checkbox') > 0 ||
                                    el.rendNode.innerHTML.indexOf('<input') > 0)) {
                                node = el.rendNodeLabel;
                            }
                            else if (el.rendNode.innerHTML.indexOf('<button') === 0) {
                                node = el.rendNodeButton;
                            }
                            else {
                                node = el.rendNode;
                            }
                            if (node) {
                                /* eslint-disable no-undef */
                                window.katex.render(content, node, {
                                    macros: el.evalVisProp('katexmacros'),
                                    throwOnError: false
                                });
                                /* eslint-enable no-undef */
                            }
                        }
                        catch (e) {
                            JXG.debug("KaTeX not loaded (yet)");
                        }
                    }
                    else if (el.evalVisProp('useasciimathml')) {
                        // This is not a constructor.
                        // See http://asciimath.org/ for more information
                        // about AsciiMathML and the project's source code.
                        try {
                            window.AMprocessNode(el.rendNode, false);
                        }
                        catch (e) {
                            JXG.debug("AsciiMathML not loaded (yet)");
                        }
                    }
                }
                angle = el.evalVisProp('rotate');
                if (angle !== 0) {
                    // Don't forget to convert to rad
                    angle *= (Math.PI / 180);
                    co = Math.cos(angle);
                    si = Math.sin(angle);
                    el.rendNode.style['transform'] = 'matrix(' +
                        [co, -1 * si, si, co, 0, 0].join(',') +
                        ')';
                    el.rendNode.style['transform-origin'] = to_h + ' ' + to_v;
                }
                this.transformRect(el, el.transformations);
            }
            else {
                this.updateInternalText(el);
            }
        }
    }
    /**
     * Converts string containing CSS properties into
     * array with key-value pair objects.
     *
     * @example
     * "color:blue; background-color:yellow" is converted to
     * [{'color': 'blue'} {'backgroundColor': 'yellow'}]
     *
     * @param  {String} cssString String containing CSS properties
     * @return {Array}           Array of CSS key-value pairs
     */
    _css2js(cssString) {
        var pairs = [], i, len, key, val, s, list = Type.trim(cssString).replace(/;$/, "").split(";");
        len = list.length;
        for (i = 0; i < len; ++i) {
            if (Type.trim(list[i]) !== "") {
                s = list[i].split(":");
                key = Type.trim(s[0].replace(/-([a-z])/gi, function (match, char) {
                    return char.toUpperCase();
                }));
                val = Type.trim(s[1]);
                pairs.push({ key: key, val: val });
            }
        }
        return pairs;
    }
    /**
     * Updates font-size, color and opacity properties and CSS style properties of a {@link JXG.Text} node.
     * This function is also called by highlight() and nohighlight().
     * @param {JXG.Text} el Reference to the {@link JXG.Text} object, that has to be updated.
     * @param {Boolean} doHighlight
     * @see Text
     * @see JXG.Text
     * @see JXG.AbstractRenderer#drawText
     * @see JXG.AbstractRenderer#drawInternalText
     * @see JXG.AbstractRenderer#updateText
     * @see JXG.AbstractRenderer#updateInternalText
     * @see JXG.AbstractRenderer#updateInternalTextStyle
     */
    updateTextStyle(el, doHighlight) {
        var fs, so, sc, css, node, display = Env.isBrowser() ? el.visProp.display : "internal", nodeList = ["rendNode", "rendNodeTag", "rendNodeLabel"], lenN = nodeList.length, fontUnit = el.evalVisProp('fontunit'), cssList, prop, style, cssString, styleList = ["cssdefaultstyle", "cssstyle"], lenS = styleList.length;
        if (doHighlight) {
            sc = el.evalVisProp('highlightstrokecolor');
            so = el.evalVisProp('highlightstrokeopacity');
            css = el.evalVisProp('highlightcssclass');
        }
        else {
            sc = el.evalVisProp('strokecolor');
            so = el.evalVisProp('strokeopacity');
            css = el.evalVisProp('cssclass');
        }
        // This part is executed for all text elements except internal texts in canvas.
        // HTML-texts or internal texts in SVG or VML.
        //            HTML    internal
        //  SVG        +         +
        //  VML        +         +
        //  canvas     +         -
        //  no         -         -
        if (this.type !== "no" && (display === "html" || this.type !== "canvas")) {
            for (style = 0; style < lenS; style++) {
                // First set cssString to
                // ev.cssdefaultstyle of ev.highlightcssdefaultstyle,
                // then to
                // ev.cssstyle of ev.highlightcssstyle
                cssString = el.evalVisProp((doHighlight ? 'highlight' : '') + styleList[style]);
                // Set the CSS style properties - without deleting other properties
                for (node = 0; node < lenN; node++) {
                    if (Type.exists(el[nodeList[node]])) {
                        if (cssString !== "" && el.visPropOld[styleList[style] + '_' + node] !== cssString) {
                            cssList = this._css2js(cssString);
                            for (prop in cssList) {
                                if (cssList.hasOwnProperty(prop)) {
                                    el[nodeList[node]].style[cssList[prop].key] = cssList[prop].val;
                                }
                            }
                            el.visPropOld[styleList[style] + '_' + node] = cssString;
                        }
                    }
                    // el.visPropOld[styleList[style]] = cssString;
                }
            }
            fs = el.evalVisProp('fontsize');
            if (el.visPropOld.fontsize !== fs) {
                el.needsSizeUpdate = true;
                try {
                    for (node = 0; node < lenN; node++) {
                        if (Type.exists(el[nodeList[node]])) {
                            el[nodeList[node]].style.fontSize = fs + fontUnit;
                        }
                    }
                }
                catch (e) {
                    // IE needs special treatment.
                    for (node = 0; node < lenN; node++) {
                        if (Type.exists(el[nodeList[node]])) {
                            el[nodeList[node]].style.fontSize = fs;
                        }
                    }
                }
                el.visPropOld.fontsize = fs;
            }
        }
        this.setTabindex(el);
        this.setObjectTransition(el);
        if (display === "html" && this.type !== "no") {
            // Set new CSS class
            if (el.visPropOld.cssclass !== css) {
                el.rendNode.className = css;
                el.visPropOld.cssclass = css;
                el.needsSizeUpdate = true;
            }
            this.setObjectStrokeColor(el, sc, so);
        }
        else {
            this.updateInternalTextStyle(el, sc, so);
        }
        if (el.evalVisProp('aria.enabled')) {
            this.setARIA(el);
        }
        return this;
    }
    // /**
    //  * Set color and opacity of internal texts.
    //  * This method is used for Canvas and VML.
    //  * SVG needs its own version.
    //  * @private
    //  * @see JXG.AbstractRenderer#updateTextStyle
    //  * @see JXG.SVGRenderer#updateInternalTextStyle
    //  */
    // updateInternalTextStyle(el, strokeColor, strokeOpacity) {
    //     this.setObjectStrokeColor(el, strokeColor, strokeOpacity);
    // }
    /* ********* Image related stuff *********** */
    /**
     * Updates the properties of an {@link JXG.Image} element.
     * @param {JXG.Image} el Reference to an {@link JXG.Image} object, that has to be updated.
     * @see Image
     * @see JXG.Image
     * @see JXG.AbstractRenderer#drawImage
     */
    updateImage(el) {
        this.updateRectPrim(el.rendNode, el.coords.scrCoords[1], el.coords.scrCoords[2] - el.size[1], el.size[0], el.size[1]);
        this.updateImageURL(el);
        this.transformRect(el, el.transformations);
        this._updateVisual(el, { stroke: true, dash: true }, true);
    }
    /**
     * Multiplication of transformations without updating. That means, at that point it is expected that the
     * matrices contain numbers only. First, the origin in user coords is translated to <tt>(0,0)</tt> in screen
     * coords. Then, the stretch factors are divided out. After the transformations in user coords, the stretch
     * factors are multiplied in again, and the origin in user coords is translated back to its position. This
     * method does not have to be implemented in a new renderer.
     * @param {JXG.GeometryElement} el A JSXGraph element. We only need its board property.
     * @param {Array} transformations An array of JXG.Transformations.
     * @returns {Array} A matrix represented by a two dimensional array of numbers.
     * @see JXG.AbstractRenderer#transformRect
     */
    joinTransforms(el, transformations) {
        var i, ox = el.board.origin.scrCoords[1], oy = el.board.origin.scrCoords[2], ux = el.board.unitX, uy = el.board.unitY, len = transformations.length, 
        // Translate to 0,0 in screen coords and then scale
        m = [
            [1, 0, 0],
            [-ox / ux, 1 / ux, 0],
            [oy / uy, 0, -1 / uy]
        ];
        for (i = 0; i < len; i++) {
            m = JSXMath.matMatMult(transformations[i].matrix, m);
        }
        // Scale back and then translate back
        m = JSXMath.matMatMult([
            [1, 0, 0],
            [ox, ux, 0],
            [oy, 0, -uy]
        ], m);
        return m;
    }
    /**
     * Updates CSS style properties of a {@link JXG.Image} node.
     * In SVGRenderer opacity is the only available style element.
     * This function is called by highlight() and nohighlight().
     * This function works for VML.
     * It does not work for Canvas.
     * SVGRenderer overwrites this method.
     * @param {JXG.Text} el Reference to the {@link JXG.Image} object, that has to be updated.
     * @param {Boolean} doHighlight
     * @see Image
     * @see JXG.Image
     * @see JXG.AbstractRenderer#highlight
     * @see JXG.AbstractRenderer#noHighlight
     */
    updateImageStyle(el, doHighlight) {
        el.rendNode.className = el.evalVisProp(doHighlight ? 'highlightcssclass' : 'cssclass');
    }
    /* ********* Render primitive objects *********** */
    /* ********* Set attributes *********** */
    /**
     * Highlights an object, i.e. changes the current colors of the object to its highlighting colors
     * and highlighting strokewidth.
     * @param {JXG.GeometryElement} el Reference of the object that will be highlighted.
     * @param {Boolean} [suppressHighlightStrokeWidth=undefined] If undefined or false, highlighting also changes strokeWidth. This might not be
     * the cases for polygon borders. Thus, if a polygon is highlighted, its polygon borders change strokeWidth only if the polygon attribute
     * highlightByStrokeWidth == true.
     * @returns {JXG.AbstractRenderer} Reference to the renderer
     * @see JXG.AbstractRenderer#updateTextStyle
     */
    highlight(el, suppressHighlightStrokeWidth = false) {
        var i, do_hl, sw;
        this.setObjectTransition(el);
        if (!el.visProp.draft) {
            if (el.type === OBJECT_TYPE.POLYGON) {
                this.setObjectFillColor(el, el.evalVisProp('highlightfillcolor'), el.evalVisProp('highlightfillopacity'));
                do_hl = el.evalVisProp('highlightbystrokewidth');
                for (i = 0; i < el.borders.length; i++) {
                    this.highlight(el.borders[i], !do_hl);
                }
            }
            else {
                if (el.elementClass === OBJECT_CLASS.TEXT) {
                    this.updateTextStyle(el, true);
                }
                else if (el.type === OBJECT_TYPE.IMAGE) {
                    this.updateImageStyle(el, true);
                    this.setObjectFillColor(el, el.evalVisProp('highlightfillcolor'), el.evalVisProp('highlightfillopacity'));
                }
                else {
                    this.setObjectStrokeColor(el, el.evalVisProp('highlightstrokecolor'), el.evalVisProp('highlightstrokeopacity'));
                    this.setObjectFillColor(el, el.evalVisProp('highlightfillcolor'), el.evalVisProp('highlightfillopacity'));
                }
            }
            // Highlight strokeWidth is suppressed if
            // parameter suppressHighlightStrokeWidth is false or undefined.
            // suppressHighlightStrokeWidth is false if polygon attribute
            // highlightbystrokewidth is true.
            if (!suppressHighlightStrokeWidth && el.evalVisProp('highlightstrokewidth')) {
                sw = Math.max(el.evalVisProp('highlightstrokewidth'), el.evalVisProp('strokewidth'));
                this.setObjectStrokeWidth(el, sw);
                if (el.elementClass === OBJECT_CLASS.LINE ||
                    el.elementClass === OBJECT_CLASS.CURVE) {
                    this.updatePathWithArrowHeads(el, true);
                }
            }
        }
        this.setCssClass(el, el.evalVisProp('highlightcssclass'));
        return this;
    }
    /**
     * Uses the normal colors of an object, i.e. the opposite of {@link JXG.AbstractRenderer#highlight}.
     * @param {JXG.GeometryElement} el Reference of the object that will get its normal colors.
     * @returns {JXG.AbstractRenderer} Reference to the renderer
     * @see JXG.AbstractRenderer#updateTextStyle
     */
    noHighlight(el) {
        var i, sw;
        this.setObjectTransition(el);
        if (!el.evalVisProp('draft')) {
            if (el.type === OBJECT_TYPE.POLYGON) {
                this.setObjectFillColor(el, el.evalVisProp('fillcolor'), el.evalVisProp('fillopacity'));
                for (i = 0; i < el.borders.length; i++) {
                    this.noHighlight(el.borders[i]);
                }
            }
            else {
                if (el.elementClass === OBJECT_CLASS.TEXT) {
                    this.updateTextStyle(el, false);
                }
                else if (el.type === OBJECT_TYPE.IMAGE) {
                    this.updateImageStyle(el, false);
                    this.setObjectFillColor(el, el.evalVisProp('fillcolor'), el.evalVisProp('fillopacity'));
                }
                else {
                    this.setObjectStrokeColor(el, el.evalVisProp('strokecolor'), el.evalVisProp('strokeopacity'));
                    this.setObjectFillColor(el, el.evalVisProp('fillcolor'), el.evalVisProp('fillopacity'));
                }
            }
            sw = el.evalVisProp('strokewidth');
            this.setObjectStrokeWidth(el, sw);
            if (el.elementClass === OBJECT_CLASS.LINE ||
                el.elementClass === OBJECT_CLASS.CURVE) {
                this.updatePathWithArrowHeads(el, false);
            }
        }
        this.setCssClass(el, el.evalVisProp('cssclass'));
        return this;
    }
    /**
     * Puts an object from draft mode back into normal mode.
     * @param {JXG.GeometryElement} el Reference of the object that no longer is in draft mode.
     */
    removeDraft(el) {
        this.setObjectTransition(el);
        if (el.type === OBJECT_TYPE.POLYGON) {
            this.setObjectFillColor(el, el.evalVisProp('fillcolor'), el.evalVisProp('fillopacity'));
        }
        else {
            if (el.type === OBJECT_CLASS.POINT) {
                this.setObjectFillColor(el, el.evalVisProp('fillcolor'), el.evalVisProp('fillopacity'));
            }
            this.setObjectStrokeColor(el, el.evalVisProp('strokecolor'), el.evalVisProp('strokeopacity'));
            this.setObjectStrokeWidth(el, el.evalVisProp('strokewidth'));
        }
    }
    /**
     * Puts an object into draft mode, i.e. it's visual appearance will be changed. For GEONE<sub>x</sub>T backwards
     * compatibility.
     * @param {JXG.GeometryElement} el Reference of the object that is in draft mode.
     */
    setDraft(el) {
        if (!el.evalVisProp('draft')) {
            return;
        }
        var draftColor = el.board.options.elements.draft.color, draftOpacity = el.board.options.elements.draft.opacity;
        this.setObjectTransition(el);
        if (el.type === OBJECT_TYPE.POLYGON) {
            this.setObjectFillColor(el, draftColor, draftOpacity);
        }
        else {
            if (el.elementClass === OBJECT_CLASS.POINT) {
                this.setObjectFillColor(el, draftColor, draftOpacity);
            }
            else {
                this.setObjectFillColor(el, "none", 0);
            }
            this.setObjectStrokeColor(el, draftColor, draftOpacity);
            this.setObjectStrokeWidth(el, el.board.options.elements.draft.strokeWidth);
        }
    }
    /**
     * The tiny zoom bar shown on the bottom of a board (if board attribute "showNavigation" is true).
     * It is a div element and gets the CSS class "JXG_navigation" and the id {board id}_navigationbar.
     * <p>
     * The buttons get the CSS class "JXG_navigation_button" and the id {board_id}_name where name is
     * one of [top, down, left, right, out, 100, in, fullscreen, screenshot, reload, cleartraces].
     * <p>
     * The symbols for zoom, navigation and reload are hard-coded.
     *
     * @param {JXG.Board} board Reference to a JSXGraph board.
     * @param {Object} attr Attributes of the navigation bar
     * @private
     */
    drawNavigationBar(board, attr) {
        var doc, node, cancelbubble = function (e) {
            if (!e) {
                e = window.event;
            }
            if (e.stopPropagation) {
                // Non IE<=8
                e.stopPropagation();
            }
            else {
                e.cancelBubble = true;
            }
        };
        let createNavButton = (label, handler, board_id, type) => {
            var button;
            board_id = board_id || "";
            button = doc.createElement("span");
            button.innerHTML = label; // button.appendChild(doc.createTextNode(label));
            // Style settings are superseded by adding the CSS class below
            button.style.paddingLeft = "7px";
            button.style.paddingRight = "7px";
            if (button.classList !== undefined) {
                // classList not available in IE 9
                button.classList.add("JXG_navigation_button");
                button.classList.add("JXG_navigation_button_" + type);
            }
            // button.setAttribute('tabindex', 0);
            button.setAttribute("id", board_id + '_navigation_' + type);
            button.setAttribute("aria-hidden", 'true'); // navigation buttons should never appear in screen reader
            node.appendChild(button);
            Env.addEvent(button, "click", function (e) {
                Type.bind(handler, board)();
                return false;
            }, board);
            // prevent the click from bubbling down to the board
            Env.addEvent(button, "pointerup", cancelbubble, board);
            Env.addEvent(button, "pointerdown", cancelbubble, board);
            Env.addEvent(button, "pointerleave", cancelbubble, board);
            Env.addEvent(button, "mouseup", cancelbubble, board);
            Env.addEvent(button, "mousedown", cancelbubble, board);
            Env.addEvent(button, "touchend", cancelbubble, board);
            Env.addEvent(button, "touchstart", cancelbubble, board);
        };
        if (Env.isBrowser() && this.type !== "no") {
            doc = board.containerObj.ownerDocument;
            node = doc.createElement("div");
            node.setAttribute("id", board.container + "_navigationbar");
            // Style settings are superseded by adding the CSS class below
            node.style.color = attr.strokecolor;
            node.style.backgroundColor = attr.fillcolor;
            node.style.padding = attr.padding;
            node.style.position = attr.position;
            node.style.fontSize = attr.fontsize;
            node.style.cursor = attr.cursor;
            node.style.zIndex = attr.zindex;
            board.containerObj.appendChild(node);
            node.style.right = attr.right;
            node.style.bottom = attr.bottom;
            if (node.classList !== undefined) {
                // classList not available in IE 9
                node.classList.add("JXG_navigation");
            }
            // For XHTML we need unicode instead of HTML entities
            if (board.attr.showfullscreen) {
                createNavButton(board.attr.fullscreen.symbol, function () {
                    board.toFullscreen(board.attr.fullscreen.id);
                }, board.container, "fullscreen");
            }
            if (board.attr.showscreenshot) {
                createNavButton(board.attr.screenshot.symbol, function () {
                    window.setTimeout(function () {
                        board.renderer.screenshot(board, "", false);
                    }, 330);
                }, board.container, "screenshot");
            }
            if (board.attr.showreload) {
                // full reload circle: \u27F2
                // the board.reload() method does not exist during the creation
                // of this button. That's why this anonymous function wrapper is required.
                createNavButton("\u21BB", function () {
                    board.reload();
                }, board.container, "reload");
            }
            if (board.attr.showcleartraces) {
                // clear traces symbol (otimes): \u27F2
                createNavButton("\u2297", function () {
                    board.clearTraces();
                }, board.container, "cleartraces");
            }
            if (board.attr.shownavigation) {
                if (board.attr.showzoom) {
                    createNavButton("\u2013", board.zoomOut, board.container, "out");
                    createNavButton("o", board.zoom100, board.container, "100");
                    createNavButton("+", board.zoomIn, board.container, "in");
                }
                createNavButton("\u2190", board.clickLeftArrow, board.container, "left");
                createNavButton("\u2193", board.clickUpArrow, board.container, "down"); // Down arrow
                createNavButton("\u2191", board.clickDownArrow, board.container, "up"); // Up arrow
                createNavButton("\u2192", board.clickRightArrow, board.container, "right");
            }
        }
    }
    /**
     * Wrapper for getElementById for maybe other renderers which elements are not directly accessible by DOM
     * methods like document.getElementById().
     * @param {String} id Unique identifier for element.
     * @returns {Object} Reference to a JavaScript object. In case of SVGRenderer it's a reference to a SVG/VML node.
     */
    getElementById(id) {
        var str;
        if (Type.exists(this.container) && this.container !== null) {
            // Use querySelector over getElementById for compatibility with both 'regular' document
            // and ShadowDOM fragments.
            str = this.container.id + '_' + id;
            // Mask special symbols like '/' and '\' in id
            if (Type.exists(CSS) && Type.exists(CSS.escape)) {
                str = CSS.escape(str);
            }
            return this.container.querySelector('#' + str);
        }
        return "";
    }
    /**
     * Remove an element and provide a function that inserts it into its original position. This method
     * is taken from this article {@link https://developers.google.com/speed/articles/javascript-dom}.
     * @author KeeKim Heng, Google Web Developer
     * @param {Element} el The element to be temporarily removed
     * @returns {Function} A function that inserts the element into its original position
     */
    removeToInsertLater(el) {
        var parentNode = el.parentNode, nextSibling = el.nextSibling;
        if (parentNode === null) {
            return;
        }
        parentNode.removeChild(el);
        return function () {
            if (nextSibling) {
                parentNode.insertBefore(el, nextSibling);
            }
            else {
                parentNode.appendChild(el);
            }
        };
    }
}

/*global JXG: true, define: true, escape: true, unescape: true*/
/*jslint nomen: true, plusplus: true, bitwise: true*/
// import { JXG } from "../jxg.js";
class Encoding {
    /**
     * Encode a string to utf-8.
     * @param {String} string
     * @returns {String} utf8 encoded string
     */
    static encode(string) {
        var n, c, utftext = "", len = string.length;
        string = string.replace(/\r\n/g, "\n");
        // See
        // http://ecmanaut.blogspot.ca/2006/07/encoding-decoding-utf8-in-javascript.html
        if (typeof unescape === "function" && typeof encodeURIComponent === "function") {
            return unescape(encodeURIComponent(string));
        }
        for (n = 0; n < len; n++) {
            c = string.charCodeAt(n);
            if (c < 128) {
                utftext += String.fromCharCode(c);
            }
            else if (c > 127 && c < 2048) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            }
            else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }
        }
        return utftext;
    }
    /**
     * Decode a string from utf-8.
     * @param {String} utftext to decode
     * @returns {String} utf8 decoded string
     */
    static decode(utftext) {
        /*
                 The following code is a translation from C99 to JavaScript.

                 The original C99 code can be found at
                    https://bjoern.hoehrmann.de/utf-8/decoder/dfa/

                 Original copyright note:

                 Copyright (c) 2008-2009 Bjoern Hoehrmann <bjoern@hoehrmann.de>

                 License: MIT License (see LICENSE.MIT)
            */
        var i, charCode, type, j = 0, codepoint = 0, state = this.UTF8_ACCEPT, chars = [], len = utftext.length, results = [];
        for (i = 0; i < len; i++) {
            charCode = utftext.charCodeAt(i);
            type = this.UTF8D[charCode];
            if (state !== this.UTF8_ACCEPT) {
                codepoint = (charCode & 0x3f) | (codepoint << 6);
            }
            else {
                codepoint = (0xff >> type) & charCode;
            }
            state = this.UTF8D[256 + state + type];
            if (state === this.UTF8_ACCEPT) {
                if (codepoint > 0xffff) {
                    chars.push(0xd7c0 + (codepoint >> 10), 0xdc00 + (codepoint & 0x3ff));
                }
                else {
                    chars.push(codepoint);
                }
                j++;
                if (j % 10000 === 0) {
                    results.push(String.fromCharCode.apply(null, chars));
                    chars = [];
                }
            }
        }
        results.push(String.fromCharCode.apply(null, chars));
        return results.join("");
    }
    /**
     * Extends the standard charCodeAt() method of the String class to find the ASCII char code of
     * a character at a given position in a UTF8 encoded string.
     * @param {String} str
     * @param {Number} i position of the character
     * @returns {Number}
     */
    static asciiCharCodeAt(str, i) {
        var c = str.charCodeAt(i);
        if (c > 255) {
            switch (c) {
                case 8364:
                    c = 128;
                    break;
                case 8218:
                    c = 130;
                    break;
                case 402:
                    c = 131;
                    break;
                case 8222:
                    c = 132;
                    break;
                case 8230:
                    c = 133;
                    break;
                case 8224:
                    c = 134;
                    break;
                case 8225:
                    c = 135;
                    break;
                case 710:
                    c = 136;
                    break;
                case 8240:
                    c = 137;
                    break;
                case 352:
                    c = 138;
                    break;
                case 8249:
                    c = 139;
                    break;
                case 338:
                    c = 140;
                    break;
                case 381:
                    c = 142;
                    break;
                case 8216:
                    c = 145;
                    break;
                case 8217:
                    c = 146;
                    break;
                case 8220:
                    c = 147;
                    break;
                case 8221:
                    c = 148;
                    break;
                case 8226:
                    c = 149;
                    break;
                case 8211:
                    c = 150;
                    break;
                case 8212:
                    c = 151;
                    break;
                case 732:
                    c = 152;
                    break;
                case 8482:
                    c = 153;
                    break;
                case 353:
                    c = 154;
                    break;
                case 8250:
                    c = 155;
                    break;
                case 339:
                    c = 156;
                    break;
                case 382:
                    c = 158;
                    break;
                case 376:
                    c = 159;
                    break;
            }
        }
        return c;
    }
}
// constants
Encoding.UTF8_ACCEPT = 0;
// UTF8_REJECT = 12,
Encoding.UTF8D = [
    // The first part of the table maps bytes to character classes that
    // to reduce the size of the transition table and create bitmasks.
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9,
    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 10, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 4, 3, 3, 11, 6, 6, 6, 5, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    // The second part is a transition table that maps a combination
    // of a state of the automaton and a character class to a state.
    0, 12, 24, 36, 60, 96, 84, 12, 12, 12, 48, 72, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 0, 12, 12, 12, 12, 12, 0, 12, 0, 12, 12, 12, 24, 12, 12, 12, 12, 12, 24, 12,
    24, 12, 12, 12, 12, 12, 12, 12, 12, 12, 24, 12, 12, 12, 12, 12, 24, 12, 12, 12, 12, 12,
    12, 12, 24, 12, 12, 12, 12, 12, 12, 12, 12, 12, 36, 12, 36, 12, 12, 12, 36, 12, 12, 12,
    12, 12, 36, 12, 36, 12, 12, 12, 36, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12
];

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */
/*global JXG: true, define: true*/
/*jslint nomen: true, plusplus: true, bitwise: true*/
// import { JXG } from "../jxg.js";
/**
 * Base64 routines
 * @namespace
*/
class Base64 {
    // Local helper functions
    /**
     * Extracts one byte from a string and ensures the result is less than or equal to 255.
     * @param {String} s
     * @param {Number} i
     * @returns {Number} <= 255
     * @private
     */
    static _getByte(s, i) {
        return s.charCodeAt(i) & 0xff;
    }
    /**
     * Determines the index of a base64 character in the base64 alphabet.
     * @param {String} s
     * @param {Number} i
     * @returns {Number}
     * @throws {Error} If the character can not be found in the alphabet.
     * @private
     */
    static _getIndex(s, i) {
        return this.alphabet.indexOf(s.charAt(i));
    }
    /**
     * Encode the given string.
     * @param {String} input
     * @returns {string} base64 encoded version of the input string.
     */
    static encode(input) {
        var i, bin, len, padLen, encInput, buffer = [];
        encInput = Encoding.encode(input);
        len = encInput.length;
        padLen = len % 3;
        for (i = 0; i < len - padLen; i += 3) {
            bin =
                (this._getByte(encInput, i) << 16) |
                    (this._getByte(encInput, i + 1) << 8) |
                    this._getByte(encInput, i + 2);
            buffer.push(this.alphabet.charAt(bin >> 18), this.alphabet.charAt((bin >> 12) & 63), this.alphabet.charAt((bin >> 6) & 63), this.alphabet.charAt(bin & 63));
        }
        switch (padLen) {
            case 1:
                bin = this._getByte(encInput, len - 1);
                buffer.push(this.alphabet.charAt(bin >> 2), this.alphabet.charAt((bin << 4) & 63), this.pad, this.pad);
                break;
            case 2:
                bin = (this._getByte(encInput, len - 2) << 8) | this._getByte(encInput, len - 1);
                buffer.push(this.alphabet.charAt(bin >> 10), this.alphabet.charAt((bin >> 4) & 63), this.alphabet.charAt((bin << 2) & 63), this.pad);
                break;
        }
        return buffer.join("");
    }
    /**
     * Decode from Base64
     * @param {String} input Base64 encoded data
     * @param {Boolean} utf8 In case this parameter is true {@link JXG.Util.UTF8.decode} will be applied to
     * the result of the base64 decoder.
     * @throws {Error} If the string has the wrong length.
     * @returns {String}
     */
    static decode(input, utf8) {
        var encInput, i, len, padLen, bin, output, result = [], buffer = [];
        // deactivate regexp linting. Our regex is secure, because we replace everything with ''
        /*jslint regexp:true*/
        encInput = input.replace(/[^A-Za-z0-9+/=]/g, "");
        /*jslint regexp:false*/
        len = encInput.length;
        if (len % 4 !== 0) {
            throw new Error("JSXGraph/utils/base64: Can't decode string (invalid input length).");
        }
        if (encInput.charAt(len - 1) === this.pad) {
            padLen = 1;
            if (encInput.charAt(len - 2) === this.pad) {
                padLen = 2;
            }
            // omit the last four bytes (taken care of after the for loop)
            len -= 4;
        }
        for (i = 0; i < len; i += 4) {
            bin =
                (this._getIndex(encInput, i) << 18) |
                    (this._getIndex(encInput, i + 1) << 12) |
                    (this._getIndex(encInput, i + 2) << 6) |
                    this._getIndex(encInput, i + 3);
            buffer.push(bin >> 16, (bin >> 8) & 255, bin & 255);
            // flush the buffer, if it gets too big fromCharCode will crash
            if (i % 10000 === 0) {
                result.push(String.fromCharCode.apply(null, buffer));
                buffer = [];
            }
        }
        switch (padLen) {
            case 1:
                bin =
                    (this._getIndex(encInput, len) << 12) |
                        (this._getIndex(encInput, len + 1) << 6) |
                        this._getIndex(encInput, len + 2);
                buffer.push(bin >> 10, (bin >> 2) & 255);
                break;
            case 2:
                bin = (this._getIndex(encInput, i) << 6) | this._getIndex(encInput, i + 1);
                buffer.push(bin >> 4);
                break;
        }
        result.push(String.fromCharCode.apply(null, buffer));
        output = result.join("");
        if (utf8) {
            output = Encoding.decode(output);
        }
        return output;
    }
    /**
     * Decode the base64 input data as an array
     * @param {string} input
     * @returns {Array}
     */
    static decodeAsArray(input) {
        var i, dec = this.decode(input);
        let ar = [];
        let len = dec.length;
        for (i = 0; i < len; i++) {
            ar[i] = dec.charCodeAt(i);
        }
        return ar;
    }
}
Base64.alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
Base64.pad = "=";

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */
/*global JXG: true, define: true, AMprocessNode: true, MathJax: true, document: true */
/*jslint nomen: true, plusplus: true, newcap:true*/
/**
 * Uses SVG to implement the rendering methods defined in {@link JXG.AbstractRenderer}.
 * @class JXG.SVGRenderer
 * @augments JXG.AbstractRenderer
 * @param {Node} container Reference to a DOM node containing the board.
 * @param {Object} dim The dimensions of the board
 * @param {Number} dim.width
 * @param {Number} dim.height
 * @see JXG.AbstractRenderer
 */
class SVGRenderer extends AbstractRenderer {
    constructor(container, dim) {
        super();
        // docstring in AbstractRenderer
        this.type = "svg";
        /**
         * SVG root node
         */
        this.svgRoot = null; // not SVGElement!
        /**
         * The SVG Namespace used in JSXGraph.
         * @see http://www.w3.org/TR/SVG2/
         * @default http://www.w3.org/2000/svg
         */
        this.svgNamespace = "http://www.w3.org/2000/svg";
        this.touchpoints = [];
        /**
         * The xlink namespace. This is used for images.
         * @see http://www.w3.org/TR/xlink/
         * @default http://www.w3.org/1999/xlink
         */
        this.xlinkNamespace = "http://www.w3.org/1999/xlink";
        var i;
        // https://stackoverflow.com/questions/7944460/detect-safari-browser
        this.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        // container is documented in AbstractRenderer.
        // Type node
        this.container = container;
        // prepare the div container and the svg root node for use with JSXGraph
        this.container.style.userSelect = "none";
        this.container.style.overflow = "hidden";
        if (this.container.style.position === "") {
            this.container.style.position = "relative";
        }
        this.svgRoot = this.container.ownerDocument.createElementNS(this.svgNamespace, "svg");
        this.svgRoot.style.overflow = "hidden";
        this.svgRoot.style.display = "block";
        this.resize(dim.width, dim.height);
        //this.svgRoot.setAttributeNS(null, 'shape-rendering', 'crispEdge'); //'optimizeQuality'); //geometricPrecision');
        this.container.appendChild(this.svgRoot);
        /**
         * The <tt>defs</tt> element is a container element to reference reusable SVG elements.
         * @type Node
         * @see https://www.w3.org/TR/SVG2/struct.html#DefsElement
         */
        this.defs = this.container.ownerDocument.createElementNS(this.svgNamespace, "defs");
        this.svgRoot.appendChild(this.defs);
        /* Default shadow filter */
        this.defs.appendChild(this.createShadowFilter(this.uniqName('f1'), 'none', 1, 0.1, 3, [5, 5]));
        /**
         * JSXGraph uses a layer system to sort the elements on the board. This puts certain types of elements in front
         * of other types of elements. For the order used see {@link Options.layer}. The number of layers is documented
         * there, too. The higher the number, the "more on top" are the elements on this layer.
         * @type Array
         */
        this.layer = [];
        for (i = 0; i < Options.layer.numlayers; i++) {
            this.layer[i] = this.container.ownerDocument.createElementNS(this.svgNamespace, 'g');
            this.svgRoot.appendChild(this.layer[i]);
        }
        try {
            this.foreignObjLayer = this.container.ownerDocument.createElementNS(this.svgNamespace, "foreignObject");
            this.foreignObjLayer.setAttribute("display", "none");
            this.foreignObjLayer.setAttribute("x", 0);
            this.foreignObjLayer.setAttribute("y", 0);
            this.foreignObjLayer.setAttribute("width", "100%");
            this.foreignObjLayer.setAttribute("height", "100%");
            this.foreignObjLayer.setAttribute("id", this.uniqName('foreignObj'));
            this.svgRoot.appendChild(this.foreignObjLayer);
            this.supportsForeignObject = true;
        }
        catch (e) {
            this.supportsForeignObject = false;
        }
    }
    /** TypeScript magic - see https://mariusschulz.com/blog/assertion-functions-in-typescript */
    assertNonNullish(value, message) {
        if (value === null || value === undefined) {
            throw Error(message);
        }
    }
    /**
     * Filters are used to apply shadows.
     * @type Node
     * @see https://www.w3.org/TR/SVG2/struct.html#DefsElement
     */
    /**
     * Create an SVG shadow filter. If the object's RGB color is [r,g,b], it's opacity is op, and
     * the parameter color is given as [r', g', b'] with opacity op'
     * the shadow will have RGB color [blend*r + r', blend*g + g', blend*b + b'] and the opacity will be equal to op * op'.
     * Further, blur and offset can be adjusted.
     *
     * The shadow color is [r*ble
     * @param {String} id Node is of the filter.
     * @param {Array|String} rgb RGB value for the blend color or the string 'none' for default values. Default 'black'.
     * @param {Number} opacity Value between 0 and 1, default is 1.
     * @param {Number} blend  Value between 0 and 1, default is 0.1.
     * @param {Number} blur  Default: 3
     * @param {Array} offset [dx, dy]. Default is [5,5].
     * @returns DOM node to be added to this.defs.
     * @private
     */
    createShadowFilter(id, rgb, opacity, blend, blur, offset) {
        var feOffset, feColor, feGaussianBlur, feBlend, mat;
        this.assertNonNullish(this.container, 'expected container');
        let filter = this.container.ownerDocument.createElementNS(this.svgNamespace, 'filter');
        filter.setAttributeNS(null, 'id', id);
        filter.setAttributeNS(null, 'width', '300%');
        filter.setAttributeNS(null, 'height', '300%');
        filter.setAttributeNS(null, 'filterUnits', 'userSpaceOnUse');
        feOffset = this.container.ownerDocument.createElementNS(this.svgNamespace, 'feOffset');
        feOffset.setAttributeNS(null, 'in', 'SourceGraphic'); // b/w: SourceAlpha, Color: SourceGraphic
        feOffset.setAttributeNS(null, 'result', 'offOut');
        feOffset.setAttributeNS(null, 'dx', offset[0]);
        feOffset.setAttributeNS(null, 'dy', offset[1]);
        filter.appendChild(feOffset);
        feColor = this.container.ownerDocument.createElementNS(this.svgNamespace, 'feColorMatrix');
        feColor.setAttributeNS(null, 'in', 'offOut');
        feColor.setAttributeNS(null, 'result', 'colorOut');
        feColor.setAttributeNS(null, 'type', 'matrix');
        // See https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feColorMatrix
        if (rgb === 'none' || !Array.isArray(rgb) || rgb.length < 3) {
            feColor.setAttributeNS(null, 'values', '0.1 0 0 0 0  0 0.1 0 0 0  0 0 0.1 0 0  0 0 0 ' + opacity + ' 0');
        }
        else {
            rgb[0] /= 255;
            rgb[1] /= 255;
            rgb[2] /= 255;
            mat = blend + ' 0 0 0 ' + rgb[0] +
                '  0 ' + blend + ' 0 0 ' + rgb[1] +
                '  0 0 ' + blend + ' 0 ' + rgb[2] +
                '  0 0 0 ' + opacity + ' 0';
            feColor.setAttributeNS(null, 'values', mat);
        }
        filter.appendChild(feColor);
        feGaussianBlur = this.container.ownerDocument.createElementNS(this.svgNamespace, 'feGaussianBlur');
        feGaussianBlur.setAttributeNS(null, 'in', 'colorOut');
        feGaussianBlur.setAttributeNS(null, 'result', 'blurOut');
        feGaussianBlur.setAttributeNS(null, 'stdDeviation', blur);
        filter.appendChild(feGaussianBlur);
        feBlend = this.container.ownerDocument.createElementNS(this.svgNamespace, 'feBlend');
        feBlend.setAttributeNS(null, 'in', 'SourceGraphic');
        feBlend.setAttributeNS(null, 'in2', 'blurOut');
        feBlend.setAttributeNS(null, 'mode', 'normal');
        filter.appendChild(feBlend);
        return filter;
    }
    ;
    /**
     * Create a "unique" string id from the arguments of the function.
     * Concatenate all arguments by "_".
     * "Unique" is achieved by simply prepending the container id.
     * Do not escape the string.
     *
     * If the id is used in an "url()" call it must be eascaped.
     *
     * @params {String} one or strings which will be concatenated.
     * @return {String}
     * @private
     */
    uniqName(id) {
        this.assertNonNullish(this.container, 'expected container');
        return this.container.id + '_' +
            Array.prototype.slice.call(arguments).join('_');
    }
    ;
    /**
     * Combine arguments to a string, joined by empty string.
     * The container id needs to be escaped, as it may contain URI-unsafe characters
     *
     * @params {String} str variable number of strings
     * @returns String
     * @see JXG.SVGRenderer#toURL
     * @private
     * @example
     * this.toStr('aaa', '_', 'bbb', 'TriangleEnd')
     * // Output:
     * // xxx_bbbTriangleEnd
     */
    toStr(...args) {
        // ES6 would be [...arguments].join()
        var str = Array.prototype.slice.call(arguments).join('');
        // Mask special symbols like '/' and '\' in id
        if (Type.exists(encodeURIComponent)) {
            str = encodeURIComponent(str);
        }
        return str;
    }
    ;
    /**
     * Combine arguments to an URL string of the form
     * url(#...)
     * Masks the container id. Calls {@link JXG.SVGRenderer#toStr}.
     *
     * @params {String} str variable number of strings
     * @returns URL string
     * @see JXG.SVGRenderer#toStr
     * @private
     * @example
     * this.toURL('aaa', '_', 'bbb', 'TriangleEnd')
     * // Output:
     * // url(#xxx_bbbTriangleEnd)
     */
    toURL(...args) {
        return 'url(#' +
            this.toStr.apply(this, args) + // Pass the arguments to toStr
            ')';
    }
    ;
    /* ******************************** *
     *  This renderer does not need to
     *  override draw/update* methods
     *  since it provides draw/update*Prim
     *  methods except for some cases like
     *  internal texts or images.
     * ******************************** */
    /* ********* Arrow head related stuff *********** */
    /**
     * Creates an arrow DOM node. Arrows are displayed in SVG with a <em>marker</em> tag.
     * @private
     * @param {JXG.GeometryElement} el A JSXGraph element, preferably one that can have an arrow attached.
     * @param {String} [idAppendix=''] A string that is added to the node's id.
     * @returns {Node} Reference to the node added to the DOM.
     */
    _createArrowHead(el, idAppendix, type) {
        var node2, node3, id = el.id + "Triangle", 
        //type = null,
        v, h;
        if (Type.exists(idAppendix)) {
            id += idAppendix;
        }
        if (Type.exists(type)) {
            id += type;
        }
        node2 = this.createPrim("marker", id);
        node2.setAttributeNS(null, "stroke", el.evalVisProp('strokecolor'));
        node2.setAttributeNS(null, "stroke-opacity", el.evalVisProp('strokeopacity'));
        node2.setAttributeNS(null, "fill", el.evalVisProp('strokecolor'));
        node2.setAttributeNS(null, "fill-opacity", el.evalVisProp('strokeopacity'));
        node2.setAttributeNS(null, "stroke-width", 0); // this is the stroke-width of the arrow head.
        // Should be zero to simplify the calculations
        node2.setAttributeNS(null, "orient", "auto");
        node2.setAttributeNS(null, "markerUnits", "strokeWidth"); // 'strokeWidth' 'userSpaceOnUse');
        /*
           Types 1, 2:
           The arrow head is an isosceles triangle with base length 10 and height 10.

           Type 3:
           A rectangle

           Types 4, 5, 6:
           Defined by Bezier curves from mp_arrowheads.html

           In any case but type 3 the arrow head is 10 units long,
           type 3 is 10 units high.
           These 10 units are scaled to strokeWidth * arrowSize pixels, see
           this._setArrowWidth().

           See also abstractRenderer.updateLine() where the line path is shortened accordingly.

           Changes here are also necessary in setArrowWidth().

           So far, lines with arrow heads are shortenend to avoid overlapping of
           arrow head and line. This is not the case for curves, yet.
           Therefore, the offset refX has to be adapted to the path type.
        */
        this.assertNonNullish(this.container, 'expected container');
        node3 = this.container.ownerDocument.createElementNS(this.svgNamespace, "path");
        h = 5;
        if (idAppendix === "Start") {
            // First arrow
            v = 0;
            if (type === 2) {
                node3.setAttributeNS(null, "d", "M 10,0 L 0,5 L 10,10 L 5,5 z");
            }
            else if (type === 3) {
                node3.setAttributeNS(null, "d", "M 0,0 L 3.33,0 L 3.33,10 L 0,10 z");
            }
            else if (type === 4) {
                // insetRatio:0.8 tipAngle:45 wingCurve:15 tailCurve:0
                h = 3.31;
                node3.setAttributeNS(null, "d", "M 0.00,3.31 C 3.53,3.84 7.13,4.50 10.00,6.63 C 9.33,5.52 8.67,4.42 8.00,3.31 C 8.67,2.21 9.33,1.10 10.00,0.00 C 7.13,2.13 3.53,2.79 0.00,3.31");
            }
            else if (type === 5) {
                // insetRatio:0.9 tipAngle:40 wingCurve:5 tailCurve:15
                h = 3.28;
                node3.setAttributeNS(null, "d", "M 0.00,3.28 C 3.39,4.19 6.81,5.07 10.00,6.55 C 9.38,5.56 9.00,4.44 9.00,3.28 C 9.00,2.11 9.38,0.99 10.00,0.00 C 6.81,1.49 3.39,2.37 0.00,3.28");
            }
            else if (type === 6) {
                // insetRatio:0.9 tipAngle:35 wingCurve:5 tailCurve:0
                h = 2.84;
                node3.setAttributeNS(null, "d", "M 0.00,2.84 C 3.39,3.59 6.79,4.35 10.00,5.68 C 9.67,4.73 9.33,3.78 9.00,2.84 C 9.33,1.89 9.67,0.95 10.00,0.00 C 6.79,1.33 3.39,2.09 0.00,2.84");
            }
            else if (type === 7) {
                // insetRatio:0.9 tipAngle:60 wingCurve:30 tailCurve:0
                h = 5.2;
                node3.setAttributeNS(null, "d", "M 0.00,5.20 C 4.04,5.20 7.99,6.92 10.00,10.39 M 10.00,0.00 C 7.99,3.47 4.04,5.20 0.00,5.20");
            }
            else {
                // type == 1 or > 6
                node3.setAttributeNS(null, "d", "M 10,0 L 0,5 L 10,10 z");
            }
            if (
            // !Type.exists(el.rendNode.getTotalLength) &&
            el.elementClass === OBJECT_CLASS.LINE) {
                if (type === 2) {
                    v = 4.9;
                }
                else if (type === 3) {
                    v = 3.3;
                }
                else if (type === 4 || type === 5 || type === 6) {
                    v = 6.66;
                }
                else if (type === 7) {
                    v = 0.0;
                }
                else {
                    v = 10.0;
                }
            }
        }
        else {
            // Last arrow
            v = 10.0;
            if (type === 2) {
                node3.setAttributeNS(null, "d", "M 0,0 L 10,5 L 0,10 L 5,5 z");
            }
            else if (type === 3) {
                v = 3.3;
                node3.setAttributeNS(null, "d", "M 0,0 L 3.33,0 L 3.33,10 L 0,10 z");
            }
            else if (type === 4) {
                // insetRatio:0.8 tipAngle:45 wingCurve:15 tailCurve:0
                h = 3.31;
                node3.setAttributeNS(null, "d", "M 10.00,3.31 C 6.47,3.84 2.87,4.50 0.00,6.63 C 0.67,5.52 1.33,4.42 2.00,3.31 C 1.33,2.21 0.67,1.10 0.00,0.00 C 2.87,2.13 6.47,2.79 10.00,3.31");
            }
            else if (type === 5) {
                // insetRatio:0.9 tipAngle:40 wingCurve:5 tailCurve:15
                h = 3.28;
                node3.setAttributeNS(null, "d", "M 10.00,3.28 C 6.61,4.19 3.19,5.07 0.00,6.55 C 0.62,5.56 1.00,4.44 1.00,3.28 C 1.00,2.11 0.62,0.99 0.00,0.00 C 3.19,1.49 6.61,2.37 10.00,3.28");
            }
            else if (type === 6) {
                // insetRatio:0.9 tipAngle:35 wingCurve:5 tailCurve:0
                h = 2.84;
                node3.setAttributeNS(null, "d", "M 10.00,2.84 C 6.61,3.59 3.21,4.35 0.00,5.68 C 0.33,4.73 0.67,3.78 1.00,2.84 C 0.67,1.89 0.33,0.95 0.00,0.00 C 3.21,1.33 6.61,2.09 10.00,2.84");
            }
            else if (type === 7) {
                // insetRatio:0.9 tipAngle:60 wingCurve:30 tailCurve:0
                h = 5.2;
                node3.setAttributeNS(null, "d", "M 10.00,5.20 C 5.96,5.20 2.01,6.92 0.00,10.39 M 0.00,0.00 C 2.01,3.47 5.96,5.20 10.00,5.20");
            }
            else {
                // type == 1 or > 6
                node3.setAttributeNS(null, "d", "M 0,0 L 10,5 L 0,10 z");
            }
            if (
            // !Type.exists(el.rendNode.getTotalLength) &&
            el.elementClass === OBJECT_CLASS.LINE) {
                if (type === 2) {
                    v = 5.1;
                }
                else if (type === 3) {
                    v = 0.02;
                }
                else if (type === 4 || type === 5 || type === 6) {
                    v = 3.33;
                }
                else if (type === 7) {
                    v = 10.0;
                }
                else {
                    v = 0.05;
                }
            }
        }
        if (type === 7) {
            node2.setAttributeNS(null, "fill", "none");
            node2.setAttributeNS(null, "stroke-width", 1); // this is the stroke-width of the arrow head.
        }
        node2.setAttributeNS(null, "refY", h);
        node2.setAttributeNS(null, "refX", v);
        node2.appendChild(node3);
        return node2;
    }
    /**
     * Updates color of an arrow DOM node.
     * @param {Node} node The arrow node.
     * @param {String} color Color value in a HTML compatible format, e.g. <tt>#00ff00</tt> or <tt>green</tt> for green.
     * @param {Number} opacity
     * @param {JXG.GeometryElement} el The element the arrows are to be attached to
     */
    _setArrowColor(node, color, opacity, el, type) {
        if (node) {
            if (Type.isString(color)) {
                if (type !== 7) {
                    this._setAttribute(function () {
                        node.setAttributeNS(null, "stroke", color);
                        node.setAttributeNS(null, "fill", color);
                        node.setAttributeNS(null, "stroke-opacity", opacity);
                        node.setAttributeNS(null, "fill-opacity", opacity);
                    }, el.visPropOld.fillcolor);
                }
                else {
                    this._setAttribute(function () {
                        node.setAttributeNS(null, "fill", "none");
                        node.setAttributeNS(null, "stroke", color);
                        node.setAttributeNS(null, "stroke-opacity", opacity);
                    }, el.visPropOld.fillcolor);
                }
            }
            if (this.isSafari) {
                // Necessary, since Safari is the new IE (11.2024)
                el.rendNode.parentNode.insertBefore(el.rendNode, el.rendNode);
            }
        }
    }
    /**
     * Updates width of an arrow DOM node. Used in
     * @param {Node} node The arrow node.
     * @param {Number} width
     * @param {Node} parentNode Used in IE only
     */
    _setArrowWidth(node, width, parentNode, size) {
        var s, d;
        if (node) {
            // if (width === 0) {
            //     // display:none does not work well in webkit
            //     node.setAttributeNS(null, 'display', 'none');
            // } else {
            s = width;
            d = s * size;
            node.setAttributeNS(null, "viewBox", 0 + " " + 0 + " " + s * 10 + " " + s * 10);
            node.setAttributeNS(null, "markerHeight", d);
            node.setAttributeNS(null, "markerWidth", d);
            node.setAttributeNS(null, "display", "inherit");
            // }
            if (this.isSafari) {
                // Necessary, since Safari is the new IE (11.2024)
                parentNode.parentNode.insertBefore(parentNode, parentNode);
            }
        }
    }
    /* ********* Line related stuff *********** */
    /**
     * Update {@link Ticks} on a {@link JXG.Line}. This method is only a stub and has to be implemented
     * in any descendant renderer class.
     * @param {JXG.Ticks} el Reference of a ticks object that has to be updated.
     * @see Line
     * @see Ticks
     * @see JXG.Line
     * @see JXG.Ticks
     * @see JXG.AbstractRenderer#drawTicks
     */
    updateTicks(ticks) {
        var i, j, c, node, x, y, tickStr = "", len = ticks.ticks.length, len2, str, isReal = true;
        for (i = 0; i < len; i++) {
            c = ticks.ticks[i];
            x = c[0];
            y = c[1];
            len2 = x.length;
            str = " M " + x[0] + " " + y[0];
            if (!Type.isNumber(x[0])) {
                isReal = false;
            }
            for (j = 1; isReal && j < len2; ++j) {
                if (Type.isNumber(x[j])) {
                    str += " L " + x[j] + " " + y[j];
                }
                else {
                    isReal = false;
                }
            }
            if (isReal) {
                tickStr += str;
            }
        }
        node = ticks.rendNode;
        if (!Type.exists(node)) {
            node = this.createPrim("path", ticks.id);
            this.appendChildPrim(node, ticks.evalVisProp('layer'));
            ticks.rendNode = node;
        }
        node.setAttributeNS(null, "stroke", ticks.evalVisProp('strokecolor'));
        node.setAttributeNS(null, "fill", "none");
        // node.setAttributeNS(null, 'fill', ticks.evalVisProp('fillcolor'));
        // node.setAttributeNS(null, 'fill-opacity', ticks.evalVisProp('fillopacity'));
        node.setAttributeNS(null, "stroke-opacity", ticks.evalVisProp('strokeopacity'));
        node.setAttributeNS(null, "stroke-width", ticks.evalVisProp('strokewidth'));
        this.updatePathPrim(node, tickStr, ticks.board);
    }
    /* ********* Text related stuff *********** */
    /**
     * Shows a small copyright notice in the top left corner of the board.
     * @param {String} str The copyright notice itself
     * @param {Number} fontsize Size of the font the copyright notice is written in
     * @see JXG.AbstractRenderer#displayLogo
     * @see Text#fontSize
     */
    displayCopyright(str, fontsize) {
        var node, t, x = 4 + 1.8 * fontsize, y = 6 + fontsize, alpha = 0.2;
        this.assertNonNullish(this.container, 'expected container');
        node = this.createPrim("text", 'licenseText');
        node.setAttributeNS(null, 'x', x + 'px');
        node.setAttributeNS(null, 'y', y + 'px');
        node.setAttributeNS(null, 'style', 'font-family:Arial,Helvetica,sans-serif; font-size:' +
            fontsize + 'px; opacity:' + alpha + ';');
        // fill:#356AA0;
        node.setAttributeNS(null, 'aria-hidden', 'true');
        t = this.container.ownerDocument.createTextNode(str);
        node.appendChild(t);
        this.appendChildPrim(node, 0);
    }
    /**
     * Shows a small JSXGraph logo in the top left corner of the board.
     * @param {String} str The data-URL of the logo
     * @param {Number} fontsize Size of the font the copyright notice is written in
     * @see JXG.AbstractRenderer#displayCopyright
     * @see Text#fontSize
     */
    displayLogo(str, fontsize) {
        var node, s = 1.5 * fontsize, alpha = 0.2;
        node = this.createPrim("image", 'licenseLogo');
        node.setAttributeNS(null, 'x', '5px');
        node.setAttributeNS(null, 'y', '5px');
        node.setAttributeNS(null, 'width', s + 'px');
        node.setAttributeNS(null, 'height', s + 'px');
        node.setAttributeNS(null, "preserveAspectRatio", "none");
        node.setAttributeNS(null, 'style', 'opacity:' + alpha + ';');
        node.setAttributeNS(null, 'aria-hidden', 'true');
        node.setAttributeNS(this.xlinkNamespace, "xlink:href", str);
        this.appendChildPrim(node, 0);
    }
    /**
     * An internal text is a {@link JXG.Text} element which is drawn using only
     * the given renderer but no HTML. This method is only a stub, the drawing
     * is done in the special renderers.
     * @param {JXG.Text} el Reference to a {@link JXG.Text} object
     * @see Text
     * @see JXG.Text
     * @see JXG.AbstractRenderer#updateInternalText
     * @see JXG.AbstractRenderer#drawText
     * @see JXG.AbstractRenderer#updateText
     * @see JXG.AbstractRenderer#updateTextStyle
     */
    drawInternalText(el) {
        console.log('drawInternalText', el);
        var node = this.createPrim("text", el.id);
        this.assertNonNullish(this.container, 'expected container');
        //node.setAttributeNS(null, "style", "alignment-baseline:middle"); // Not yet supported by Firefox
        // Preserve spaces
        //node.setAttributeNS("http://www.w3.org/XML/1998/namespace", "space", "preserve");
        node.style.whiteSpace = "nowrap";
        el.rendNodeText = this.container.ownerDocument.createTextNode("");
        node.appendChild(el.rendNodeText);
        this.appendChildPrim(node, el.evalVisProp('layer'));
        console.log(node);
        return node;
    }
    /**
     * Updates visual properties of an already existing {@link JXG.Text} element.
     * @param {JXG.Text} el Reference to an {@link JXG.Text} object, that has to be updated.
     * @see Text
     * @see JXG.Text
     * @see JXG.AbstractRenderer#drawInternalText
     * @see JXG.AbstractRenderer#drawText
     * @see JXG.AbstractRenderer#updateText
     * @see JXG.AbstractRenderer#updateTextStyle
     */
    updateInternalText(el) {
        var content = el.plaintext, v, css, ev_ax = el.getAnchorX(), ev_ay = el.getAnchorY();
        css = el.evalVisProp('cssclass');
        if (el.rendNode.getAttributeNS(null, "class") !== css) {
            el.rendNode.setAttributeNS(null, "class", css);
            el.needsSizeUpdate = true;
        }
        if (!isNaN(el.coords.scrCoords[1] + el.coords.scrCoords[2])) {
            // Horizontal
            v = el.coords.scrCoords[1];
            if (el.visPropOld.left !== ev_ax + v) {
                el.rendNode.setAttributeNS(null, "x", v + "px");
                if (ev_ax === "left") {
                    el.rendNode.setAttributeNS(null, "text-anchor", "start");
                }
                else if (ev_ax === "right") {
                    el.rendNode.setAttributeNS(null, "text-anchor", "end");
                }
                else if (ev_ax === "middle") {
                    el.rendNode.setAttributeNS(null, "text-anchor", "middle");
                }
                el.visPropOld.left = ev_ax + v;
            }
            // Vertical
            v = el.coords.scrCoords[2];
            if (el.visPropOld.top !== ev_ay + v) {
                el.rendNode.setAttributeNS(null, "y", v + this.vOffsetText * 0.5 + "px");
                // Not supported by IE, edge
                // el.rendNode.setAttributeNS(null, "dy", "0");
                // if (ev_ay === "bottom") {
                //     el.rendNode.setAttributeNS(null, 'dominant-baseline', 'text-after-edge');
                // } else if (ev_ay === "top") {
                //     el.rendNode.setAttributeNS(null, 'dominant-baseline', 'text-before-edge');
                // } else if (ev_ay === "middle") {
                //     el.rendNode.setAttributeNS(null, 'dominant-baseline', 'middle');
                // }
                if (ev_ay === "bottom") {
                    el.rendNode.setAttributeNS(null, "dy", "0");
                    el.rendNode.setAttributeNS(null, 'dominant-baseline', 'auto');
                }
                else if (ev_ay === "top") {
                    el.rendNode.setAttributeNS(null, "dy", "1.6ex");
                    el.rendNode.setAttributeNS(null, 'dominant-baseline', 'auto');
                }
                else if (ev_ay === "middle") {
                    el.rendNode.setAttributeNS(null, "dy", "0.6ex");
                    el.rendNode.setAttributeNS(null, 'dominant-baseline', 'auto');
                }
                el.visPropOld.top = ev_ay + v;
            }
        }
        if (el.htmlStr !== content) {
            el.rendNodeText.data = content;
            el.htmlStr = content;
        }
        this.transformRect(el, el.transformations);
    }
    /**
     * Set color and opacity of internal texts.
     * @private
     * @see JXG.AbstractRenderer#updateTextStyle
     * @see JXG.AbstractRenderer#updateInternalTextStyle
     */
    updateInternalTextStyle(el, strokeColor, strokeOpacity) {
        this.setObjectFillColor(el, strokeColor, strokeOpacity);
    }
    /* ********* Image related stuff *********** */
    /**
     * Draws an {@link JXG.Image} on a board; This is just a template that has to be implemented by special
     * renderers.
     * @param {JXG.Image} el Reference to the image object that is to be drawn
     * @see Image
     * @see JXG.Image
     * @see JXG.AbstractRenderer#updateImage
     */
    drawImage(el) {
        var node = this.createPrim("image", el.id);
        node.setAttributeNS(null, "preserveAspectRatio", "none");
        this.appendChildPrim(node, el.evalVisProp('layer'));
        el.rendNode = node;
        this.updateImage(el);
    }
    /**
     * Applies transformations on images and text elements. This method has to implemented in
     * all descendant classes where text and image transformations are to be supported.
     * <p>
     * Only affine transformation are supported, no proper projective transformations. This means, the
     * respective entries of the transformation matrix are simply ignored.
     *
     * @param {JXG.Image|JXG.Text} el A {@link JXG.Image} or {@link JXG.Text} object.
     * @param {Array} transformations An array of {@link JXG.Transformation} objects. This is usually the
     * transformations property of the given element <tt>el</tt>.
     */
    transformRect(el, t) {
        var s, m, node, str = "", cx, cy, len = t.length;
        if (len > 0) {
            node = el.rendNode;
            m = this.joinTransforms(el, t);
            s = [m[1][1], m[2][1], m[1][2], m[2][2], m[1][0], m[2][0]].join(",");
            if (s.indexOf('NaN') === -1) {
                str += " matrix(" + s + ") ";
                if (el.elementClass === OBJECT_CLASS.TEXT && el.visProp.display === 'html') {
                    node.style.transform = str;
                    cx = -el.coords.scrCoords[1];
                    cy = -el.coords.scrCoords[2];
                    switch (el.evalVisProp('anchorx')) {
                        case 'right':
                            cx += el.size[0];
                            break;
                        case 'middle':
                            cx += el.size[0] * 0.5;
                            break;
                    }
                    switch (el.evalVisProp('anchory')) {
                        case 'bottom':
                            cy += el.size[1];
                            break;
                        case 'middle':
                            cy += el.size[1] * 0.5;
                            break;
                    }
                    node.style['transform-origin'] = (cx) + 'px ' + (cy) + 'px';
                }
                else {
                    // Images and texts with display:'internal'
                    node.setAttributeNS(null, "transform", str);
                }
            }
        }
    }
    /**
     * If the URL of the image is provided by a function the URL has to be updated during updateImage()
     * @param {JXG.Image} el Reference to an image object.
     * @see JXG.AbstractRenderer#updateImage
     */
    updateImageURL(el) {
        var url = el.eval(el.url);
        if (el._src !== url) {
            el.imgIsLoaded = false;
            el.rendNode.setAttributeNS(this.xlinkNamespace, "xlink:href", url);
            el._src = url;
            return true;
        }
        return false;
    }
    // Already documented in JXG.AbstractRenderer
    updateImageStyle(el, doHighlight) {
        var css = el.evalVisProp(doHighlight ? 'highlightcssclass' : 'cssclass');
        el.rendNode.setAttributeNS(null, "class", css);
    }
    // Already documented in JXG.AbstractRenderer
    drawForeignObject(el) {
        el.rendNode = this.appendChildPrim(this.createPrim("foreignObject", el.id), el.evalVisProp('layer'));
        this.appendNodesToElement(el, "foreignObject");
        this.updateForeignObject(el);
    }
    // Already documented in JXG.AbstractRenderer
    updateForeignObject(el) {
        if (el._useUserSize) {
            el.rendNode.style.overflow = "hidden";
        }
        else {
            el.rendNode.style.overflow = "visible";
        }
        this.updateRectPrim(el.rendNode, el.coords.scrCoords[1], el.coords.scrCoords[2] - el.size[1], el.size[0], el.size[1]);
        if (el.evalVisProp('evaluateOnlyOnce') !== true || !el.renderedOnce) {
            el.rendNode.innerHTML = el.content;
            el.renderedOnce = true;
        }
        this._updateVisual(el, { stroke: true, dash: true }, true);
    }
    /* ********* Render primitive objects *********** */
    /**
    * Stores the rendering nodes. This is an abstract method which has to be implemented in all renderers that use
    * the <tt>createPrim</tt> method.
    * @param {JXG.GeometryElement} el A JSXGraph element.
    * @param {String} type The XML node name. Only used in VMLRenderer.
    */
    appendNodesToElement(el, type) { } // TODO: this was never implemented !!
    /**
     * Appends a node to a specific layer level. This is just an abstract method and has to be implemented
     * in all renderers that want to use the <tt>createPrim</tt> model to draw.
     * @param {Node} node A DOM tree node.
     * @param {Number} level The layer the node is attached to. This is the index of the layer in
     * {@link JXG.SVGRenderer#layer} or the <tt>z-index</tt> style property of the node in SVGRenderer.
     */
    appendChildPrim(node, level = 0) {
        console.log('appendChildPrim', level, node);
        if (typeof level !== 'number') { // someone is misbehaving
            console.warn('level is not a number', level);
            level = 0;
        }
        if (!Type.exists(level)) {
            level = 0;
        }
        else if (level >= Options.layer.numlayers) {
            level = Options.layer.numlayers - 1;
        }
        this.layer[level].appendChild(node);
        return node;
    }
    /**
     * Creates a node of a given type with a given id.
     * @param  type The type of the node to create.
     * @param  id Set the id attribute to this.
     * @returns {Node} Reference to the created node.
     */
    createPrim(type, id) {
        this.assertNonNullish(this.container, 'expected container');
        let node = this.container.ownerDocument.createElementNS(this.svgNamespace, type);
        node.setAttributeNS(null, "id", this.uniqName(id));
        node.style.position = "absolute";
        if (type === "path") {
            node.setAttributeNS(null, "stroke-linecap", "round");
            node.setAttributeNS(null, "stroke-linejoin", "round");
            node.setAttributeNS(null, "fill-rule", "evenodd");
        }
        return node;
    }
    /**
     * Removes an element node.
     * @param {Node} node The node to remove.
     */
    remove(shape) {
        if (Type.exists(shape) && Type.exists(shape.parentNode)) {
            shape.parentNode.removeChild(shape);
        }
    }
    /**
     * Move element into new layer. This is trivial for canvas, but needs more effort in SVG.
     * Does not work dynamically, i.e. if level is a function.
     *
     * @param  el Element which is put into different layer
     * @param  value Layer number
     * @private
     */
    setLayer(el, level) {
        if (!Type.exists(level)) {
            level = 0;
        }
        else if (level >= Options.layer.numlayers) {
            level = Options.layer.numlayers - 1;
        }
        this.layer[level].appendChild(el.rendNode);
    }
    /**
     * Can be used to create the nodes to display arrows. This is an abstract method which has to be implemented
     * in any descendant renderer.
     * @param {JXG.GeometryElement} el The element the arrows are to be attached to.
     * @param {Object} arrowData Data concerning possible arrow heads
    *
     */
    makeArrows(el, a) {
        var node2, str, ev_fa = a.evFirst, ev_la = a.evLast;
        this.assertNonNullish(el.rendNode, 'expected node');
        this.assertNonNullish(el.rendNode.parentNode, 'expected node');
        this.assertNonNullish(this.container, 'expected container');
        if (this.isSafari && el.visPropCalc.visible && (ev_fa || ev_la)) {
            // Necessary, since Safari is the new IE (11.2024)
            el.rendNode.parentNode.insertBefore(el.rendNode, el.rendNode);
            return;
        }
        // We can not compare against visPropOld if there is need for a new arrow head,
        // since here visPropOld and ev_fa / ev_la already have the same value.
        // This has been set in _updateVisual.
        //
        node2 = el.rendNodeTriangleStart;
        if (ev_fa) {
            str = this.toStr(this.container.id, '_', el.id, 'TriangleStart', a.typeFirst);
            // If we try to set the same arrow head as is already set, we can bail out now
            if (!Type.exists(node2) || node2.id !== str) {
                node2 = this.container.ownerDocument.getElementById(str);
                // Check if the marker already exists.
                // If not, create a new marker
                if (node2 === null) {
                    node2 = this._createArrowHead(el, "Start", a.typeFirst);
                    this.defs.appendChild(node2);
                }
                el.rendNodeTriangleStart = node2;
                el.rendNode.setAttributeNS(null, "marker-start", this.toURL(str));
            }
        }
        else {
            if (Type.exists(node2)) {
                this.remove(node2);
                el.rendNodeTriangleStart = null;
            }
            el.rendNode.setAttributeNS(null, "marker-start", '');
        }
        node2 = el.rendNodeTriangleEnd;
        if (ev_la) {
            str = this.toStr(this.container.id, '_', el.id, 'TriangleEnd', a.typeLast);
            // If we try to set the same arrow head as is already set, we can bail out now
            if (!Type.exists(node2) || node2.id !== str) {
                node2 = this.container.ownerDocument.getElementById(str);
                // Check if the marker already exists.
                // If not, create a new marker
                if (node2 === null) {
                    node2 = this._createArrowHead(el, "End", a.typeLast);
                    this.defs.appendChild(node2);
                }
                el.rendNodeTriangleEnd = node2;
                el.rendNode.setAttributeNS(null, "marker-end", this.toURL(str));
            }
        }
        else {
            if (Type.exists(node2)) {
                this.remove(node2);
                el.rendNodeTriangleEnd = null;
            }
            el.rendNode.setAttributeNS(null, "marker-end", '');
        }
    }
    /**
     * Updates an ellipse node primitive. This is an abstract method which has to be implemented in all renderers
     * that use the <tt>createPrim</tt> method.
     * @param {Node} node Reference to the node.
     * @param {Number} x Centre X coordinate
     * @param {Number} y Centre Y coordinate
     * @param {Number} rx The x-axis radius.
     * @param {Number} ry The y-axis radius.
     */
    updateEllipsePrim(node, x, y, rx, ry) {
        var huge = 1000000;
        huge = 200000; // IE
        // webkit does not like huge values if the object is dashed
        // iE doesn't like huge values above 216000
        x = Math.abs(x) < huge ? x : (huge * x) / Math.abs(x);
        y = Math.abs(y) < huge ? y : (huge * y) / Math.abs(y);
        rx = Math.abs(rx) < huge ? rx : (huge * rx) / Math.abs(rx);
        ry = Math.abs(ry) < huge ? ry : (huge * ry) / Math.abs(ry);
        node.setAttributeNS(null, "cx", x);
        node.setAttributeNS(null, "cy", y);
        node.setAttributeNS(null, "rx", Math.abs(rx));
        node.setAttributeNS(null, "ry", Math.abs(ry));
    }
    /**
     * Refreshes a line node. This is an abstract method which has to be implemented in all renderers that use
     * the <tt>createPrim</tt> method.
     * @param {Node} node The node to be refreshed.
     * @param {Number} p1x The first point's x coordinate.
     * @param {Number} p1y The first point's y coordinate.
     * @param {Number} p2x The second point's x coordinate.
     * @param {Number} p2y The second point's y coordinate.
     * @param {JXG.Board} board
     */
    updateLinePrim(node, p1x, p1y, p2x, p2y) {
        var huge = 1000000;
        huge = 200000; //IE
        if (!isNaN(p1x + p1y + p2x + p2y)) {
            // webkit does not like huge values if the object is dashed
            // IE doesn't like huge values above 216000
            p1x = Math.abs(p1x) < huge ? p1x : (huge * p1x) / Math.abs(p1x);
            p1y = Math.abs(p1y) < huge ? p1y : (huge * p1y) / Math.abs(p1y);
            p2x = Math.abs(p2x) < huge ? p2x : (huge * p2x) / Math.abs(p2x);
            p2y = Math.abs(p2y) < huge ? p2y : (huge * p2y) / Math.abs(p2y);
            node.setAttributeNS(null, "x1", p1x);
            node.setAttributeNS(null, "y1", p1y);
            node.setAttributeNS(null, "x2", p2x);
            node.setAttributeNS(null, "y2", p2y);
        }
    }
    /**
     * Updates a path element. This is an abstract method which has to be implemented in all renderers that use
     * the <tt>createPrim</tt> method.
     * @param {Node} node The path node.
     * @param {String} pathString A string formatted like e.g. <em>'M 1,2 L 3,1 L5,5'</em>. The format of the string
     * depends on the rendering engine.
     * @param {JXG.Board} board Reference to the element's board.
     */
    updatePathPrim(node, pointString, board) {
        if (pointString === "") {
            pointString = "M 0 0";
        }
        node.setAttributeNS(null, "d", pointString);
    }
    /**
     * Builds a path data string to draw a point with a face other than <em>rect</em> and <em>circle</em>. Since
     * the format of such a string usually depends on the renderer this method
     * is only an abstract method. Therefore, it has to be implemented in the descendant renderer itself unless
     * the renderer does not use the createPrim interface but the draw* interfaces to paint.
     * @param {JXG.Point} el The point element
     * @param {Number} size A positive number describing the size. Usually the half of the width and height of
     * the drawn point.
     * @param {String} type A string describing the point's face. This method only accepts the shortcut version of
     * each possible face: <tt>x, +, |, -, [], <>, <<>>,^, v, >, < </tt>
     */
    updatePathStringPoint(el, size, type) {
        var s = "", scr = el.coords.scrCoords, sqrt32 = size * Math.sqrt(3) * 0.5, s05 = size * 0.5;
        if (type === "x") {
            s =
                " M " +
                    (scr[1] - size) +
                    " " +
                    (scr[2] - size) +
                    " L " +
                    (scr[1] + size) +
                    " " +
                    (scr[2] + size) +
                    " M " +
                    (scr[1] + size) +
                    " " +
                    (scr[2] - size) +
                    " L " +
                    (scr[1] - size) +
                    " " +
                    (scr[2] + size);
        }
        else if (type === "+") {
            s =
                " M " +
                    (scr[1] - size) +
                    " " +
                    scr[2] +
                    " L " +
                    (scr[1] + size) +
                    " " +
                    scr[2] +
                    " M " +
                    scr[1] +
                    " " +
                    (scr[2] - size) +
                    " L " +
                    scr[1] +
                    " " +
                    (scr[2] + size);
        }
        else if (type === "|") {
            s =
                " M " +
                    scr[1] +
                    " " +
                    (scr[2] - size) +
                    " L " +
                    scr[1] +
                    " " +
                    (scr[2] + size);
        }
        else if (type === "-") {
            s =
                " M " +
                    (scr[1] - size) +
                    " " +
                    scr[2] +
                    " L " +
                    (scr[1] + size) +
                    " " +
                    scr[2];
        }
        else if (type === "<>" || type === "<<>>") {
            if (type === "<<>>") {
                size *= 1.41;
            }
            s =
                " M " +
                    (scr[1] - size) +
                    " " +
                    scr[2] +
                    " L " +
                    scr[1] +
                    " " +
                    (scr[2] + size) +
                    " L " +
                    (scr[1] + size) +
                    " " +
                    scr[2] +
                    " L " +
                    scr[1] +
                    " " +
                    (scr[2] - size) +
                    " Z ";
        }
        else if (type === "^") {
            s =
                " M " +
                    scr[1] +
                    " " +
                    (scr[2] - size) +
                    " L " +
                    (scr[1] - sqrt32) +
                    " " +
                    (scr[2] + s05) +
                    " L " +
                    (scr[1] + sqrt32) +
                    " " +
                    (scr[2] + s05) +
                    " Z "; // close path
        }
        else if (type === "v") {
            s =
                " M " +
                    scr[1] +
                    " " +
                    (scr[2] + size) +
                    " L " +
                    (scr[1] - sqrt32) +
                    " " +
                    (scr[2] - s05) +
                    " L " +
                    (scr[1] + sqrt32) +
                    " " +
                    (scr[2] - s05) +
                    " Z ";
        }
        else if (type === ">") {
            s =
                " M " +
                    (scr[1] + size) +
                    " " +
                    scr[2] +
                    " L " +
                    (scr[1] - s05) +
                    " " +
                    (scr[2] - sqrt32) +
                    " L " +
                    (scr[1] - s05) +
                    " " +
                    (scr[2] + sqrt32) +
                    " Z ";
        }
        else if (type === "<") {
            s =
                " M " +
                    (scr[1] - size) +
                    " " +
                    scr[2] +
                    " L " +
                    (scr[1] + s05) +
                    " " +
                    (scr[2] - sqrt32) +
                    " L " +
                    (scr[1] + s05) +
                    " " +
                    (scr[2] + sqrt32) +
                    " Z ";
        }
        return s;
    }
    /**
     * Builds a path data string from a {@link JXG.Curve} element. Since the path data strings heavily depend on the
     * underlying rendering technique this method is just a stub. Although such a path string is of no use for the
     * CanvasRenderer, this method is used there to draw a path directly.
     * @param {JXG.GeometryElement} el
     */
    updatePathStringPrim(el) {
        var i, scr, len, symbm = " M ", symbl = " L ", symbc = " C ", nextSymb = symbm, maxSize = 5000.0, pStr = "";
        if (el.numberPoints <= 0) {
            return "";
        }
        len = Math.min(el.points.length, el.numberPoints);
        if (el.bezierDegree === 1) {
            for (i = 0; i < len; i++) {
                scr = el.points[i].scrCoords;
                if (isNaN(scr[1]) || isNaN(scr[2])) {
                    // PenUp
                    nextSymb = symbm;
                }
                else {
                    // Chrome has problems with values being too far away.
                    scr[1] = Math.max(Math.min(scr[1], maxSize), -maxSize);
                    scr[2] = Math.max(Math.min(scr[2], maxSize), -maxSize);
                    // Attention: first coordinate may be inaccurate if far way
                    //pStr += [nextSymb, scr[1], ' ', scr[2]].join('');
                    pStr += nextSymb + scr[1] + " " + scr[2]; // Seems to be faster now (webkit and firefox)
                    nextSymb = symbl;
                }
            }
        }
        else if (el.bezierDegree === 3) {
            i = 0;
            while (i < len) {
                scr = el.points[i].scrCoords;
                if (isNaN(scr[1]) || isNaN(scr[2])) {
                    // PenUp
                    nextSymb = symbm;
                }
                else {
                    pStr += nextSymb + scr[1] + " " + scr[2];
                    if (nextSymb === symbc) {
                        i += 1;
                        scr = el.points[i].scrCoords;
                        pStr += " " + scr[1] + " " + scr[2];
                        i += 1;
                        scr = el.points[i].scrCoords;
                        pStr += " " + scr[1] + " " + scr[2];
                    }
                    nextSymb = symbc;
                }
                i += 1;
            }
        }
        return pStr;
    }
    /**
     * Builds a path data string from a {@link JXG.Curve} element such that the curve looks like hand drawn. Since
     * the path data strings heavily depend on the underlying rendering technique this method is just a stub.
     * Although such a path string is of no use for the CanvasRenderer, this method is used there to draw a path
     * directly.
     * @param  {JXG.GeometryElement} el
     */
    updatePathStringBezierPrim(el) {
        var i, j, k, scr, lx, ly, len, symbm = " M ", symbl = " C ", nextSymb = symbm, maxSize = 5000.0, pStr = "", f = el.evalVisProp('strokewidth'), isNoPlot = el.evalVisProp('curvetype') !== "plot";
        if (el.numberPoints <= 0) {
            return "";
        }
        if (isNoPlot && el.board.options.curve.RDPsmoothing) {
            el.points = Numerics.RamerDouglasPeucker(el.points, 0.5);
        }
        len = Math.min(el.points.length, el.numberPoints);
        for (j = 1; j < 3; j++) {
            nextSymb = symbm;
            for (i = 0; i < len; i++) {
                scr = el.points[i].scrCoords;
                if (isNaN(scr[1]) || isNaN(scr[2])) {
                    // PenUp
                    nextSymb = symbm;
                }
                else {
                    // Chrome has problems with values being too far away.
                    scr[1] = Math.max(Math.min(scr[1], maxSize), -maxSize);
                    scr[2] = Math.max(Math.min(scr[2], maxSize), -maxSize);
                    // Attention: first coordinate may be inaccurate if far way
                    if (nextSymb === symbm) {
                        //pStr += [nextSymb, scr[1], ' ', scr[2]].join('');
                        pStr += nextSymb + scr[1] + " " + scr[2]; // Seems to be faster now (webkit and firefox)
                    }
                    else {
                        k = 2 * j;
                        pStr += [
                            nextSymb,
                            lx + (scr[1] - lx) * 0.333 + f * (k * Math.random() - j),
                            " ",
                            ly + (scr[2] - ly) * 0.333 + f * (k * Math.random() - j),
                            " ",
                            lx + (scr[1] - lx) * 0.666 + f * (k * Math.random() - j),
                            " ",
                            ly + (scr[2] - ly) * 0.666 + f * (k * Math.random() - j),
                            " ",
                            scr[1],
                            " ",
                            scr[2]
                        ].join("");
                    }
                    nextSymb = symbl;
                    lx = scr[1];
                    ly = scr[2];
                }
            }
        }
        return pStr;
    }
    /**
     * Update a polygon primitive.
     * @param {Node} node
     * @param {JXG.Polygon} el A JSXGraph element of type {@link JXG.Polygon}
     */
    updatePolygonPrim(node, el) {
        var i, pStr = "", scrCoords, len = el.vertices.length;
        node.setAttributeNS(null, "stroke", "none");
        node.setAttributeNS(null, "fill-rule", "evenodd");
        if (el.elType === "polygonalchain") {
            len++;
        }
        for (i = 0; i < len - 1; i++) {
            if (el.vertices[i].isReal) {
                scrCoords = el.vertices[i].coords.scrCoords;
                pStr = pStr + scrCoords[1] + "," + scrCoords[2];
            }
            else {
                node.setAttributeNS(null, "points", "");
                return;
            }
            if (i < len - 2) {
                pStr += " ";
            }
        }
        if (pStr.indexOf("NaN") === -1) {
            node.setAttributeNS(null, "points", pStr);
        }
    }
    /**
     * Update a rectangle primitive. This is used only for points with face of type 'rect'.
     * @param {Node} node The node yearning to be updated.
     * @param {Number} x x coordinate of the top left vertex.
     * @param {Number} y y coordinate of the top left vertex.
     * @param {Number} w Width of the rectangle.
     * @param {Number} h The rectangle's height.
     */
    updateRectPrim(node, x, y, w, h) {
        node.setAttributeNS(null, "x", x);
        node.setAttributeNS(null, "y", y);
        node.setAttributeNS(null, "width", w);
        node.setAttributeNS(null, "height", h);
    }
    /* ********* Set attributes *********** */
    /**
     * Call user-defined function to set visual attributes.
     * If "testAttribute" is the empty string, the function
     * is called immediately, otherwise it is called in a timeOut.
     *
     * This is necessary to realize smooth transitions but avoid transitions
     * when first creating the objects.
     *
     * Usually, the string in testAttribute is the visPropOld attribute
     * of the values which are set.
     *
     * @param {Function} setFunc       Some function which usually sets some attributes
     * @param {String} testAttribute If this string is the empty string  the function is called immediately,
     *                               otherwise it is called in a setImeout.
     * @see JXG.SVGRenderer#setObjectFillColor
     * @see JXG.SVGRenderer#setObjectStrokeColor
     * @see JXG.SVGRenderer#_setArrowColor
     * @private
     */
    _setAttribute(setFunc, testAttribute) {
        if (testAttribute === "") {
            setFunc();
        }
        else {
            window.setTimeout(setFunc, 1);
        }
    }
    /**
    * Shows or hides an element on the canvas; Only a stub, requires implementation in the derived renderer.
    * @param {JXG.GeometryElement} el Reference to the object that has to appear.
    * @param {Boolean} value true to show the element, false to hide the element.
    */
    display(el, value) {
        if (el) {
            el.visPropOld.visible = value;
        }
        ///////////////////// tbtb - this was in svg.js, but above code implement in abstract.js
        // var node;
        // if (el && el.rendNode) {
        //     el.visPropOld.visible = val;
        //     node = el.rendNode;
        //     if (val) {
        //         node.setAttributeNS(null, "display", "inline");
        //         node.style.visibility = "inherit";
        //     } else {
        //         node.setAttributeNS(null, "display", "none");
        //         node.style.visibility = "hidden";
        //     }
        // }
    }
    /**
     * Hides an element on the canvas; Only a stub, requires implementation in the derived renderer.
     *
     * Please use JXG.AbstractRenderer#display instead
     * @param {JXG.GeometryElement} el Reference to the geometry element that has to disappear.
     * @see JXG.AbstractRenderer#show
     * @deprecated
     */
    hide(el) {
        JXG.deprecated("Board.renderer.hide()", "Board.renderer.display()");
        this.display(el, false);
    }
    /**
     * Set ARIA related properties of an element. The attribute "aria" of an element contains at least the
     * properties "enabled", "label", and "live". Additionally, all available properties from
     * {@link https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA} may be set.
     * <p>
     * In JSXGraph, the available properties are used without the leading 'aria-'.
     * For example, the value of the JSXGraph attribute 'aria.label' will be set to the
     * HTML attribute 'aria-label'.
     *
     * @param {JXG.GeometryElement} el Reference of the object that wants new
     *        ARIA attributes.
     */
    setARIA(el) {
        // This method is only called in abstractRenderer._updateVisual() if aria.enabled == true.
        var key, k, v;
        // this.setPropertyPrim(el.rendNode, 'aria-label', el.evalVisProp('aria.label'));
        // this.setPropertyPrim(el.rendNode, 'aria-live', el.evalVisProp('aria.live'));
        for (key in el.visProp.aria) {
            if (el.visProp.aria.hasOwnProperty(key) && key !== 'enabled') {
                k = 'aria.' + key;
                v = el.evalVisProp('aria.' + key);
                if (el.visPropOld[k] !== v) {
                    this.setPropertyPrim(el.rendNode, 'aria-' + key, v);
                    el.visPropOld[k] = v;
                }
            }
        }
    }
    /**
     * Sets the buffering as recommended by SVGWG. Until now only Opera supports this and will be ignored by other
     * browsers. Although this feature is only supported by SVG we have this method in {@link JXG.AbstractRenderer}
     * because it is called from outside the renderer.
     * @param {Node} node The SVG DOM Node which buffering type to update.
     * @param {String} type Either 'auto', 'dynamic', or 'static'. For an explanation see
     *   {@link https://www.w3.org/TR/SVGTiny12/painting.html#BufferedRenderingProperty}.
     */
    setBuffering(el, type) {
        el.rendNode.setAttribute("buffered-rendering", type);
    }
    /**
     * Sets CSS classes for elements (relevant for SVG only).
     *
     * @param {JXG.GeometryElement} el Reference of the object that wants a
     *         new set of CSS classes.
     * @param {String} cssClass String containing a space separated list of CSS classes.
     */
    setCssClass(el, cssClass) {
        if (el.visPropOld.cssclass !== cssClass) {
            this.setPropertyPrim(el.rendNode, 'class', cssClass);
            el.visPropOld.cssclass = cssClass;
        }
    }
    /**
     * Sets an element's dash style.
     * @param {JXG.GeometryElement} el An JSXGraph element.
     */
    setDashStyle(el) {
        var dashStyle = el.evalVisProp('dash'), ds = el.evalVisProp('dashscale'), sw = ds ? 0.5 * el.evalVisProp('strokewidth') : 1, node = el.rendNode;
        if (dashStyle > 0) {
            node.setAttributeNS(null, "stroke-dasharray", 
            // sw could distinguish highlighting or not.
            // But it seems to preferable to ignore this.
            this.dashArray[dashStyle - 1].map(function (x) { return x * sw; }).join(','));
        }
        else {
            if (node.hasAttributeNS(null, "stroke-dasharray")) {
                node.removeAttributeNS(null, "stroke-dasharray");
            }
        }
    }
    /**
     * Sets up nodes for rendering a gradient fill.
     * @param {JXG.GeometryElement}  el Reference of the object which gets the gradient
     */
    setGradient(el) {
        var fillNode = el.rendNode, node, node2, node3, ev_g = el.evalVisProp('gradient');
        if (ev_g === "linear" || ev_g === "radial") {
            node = this.createPrim(ev_g + "Gradient", el.id + "_gradient");
            node2 = this.createPrim("stop", el.id + "_gradient1");
            node3 = this.createPrim("stop", el.id + "_gradient2");
            node.appendChild(node2);
            node.appendChild(node3);
            this.defs.appendChild(node);
            this.assertNonNullish(this.container, 'expected container');
            fillNode.setAttributeNS(null, 'style', 
            // "fill:url(#" + this.container.id + "_" + el.id + "_gradient)"
            'fill:' + this.toURL(this.container.id + '_' + el.id + '_gradient'));
            el.gradNode1 = node2;
            el.gradNode2 = node3;
            el.gradNode = node;
        }
        else {
            fillNode.removeAttributeNS(null, "style");
        }
    }
    /**
     * Update the line endings (linecap) of a straight line from its attribute
     * 'linecap'.
     * Possible values for the attribute 'linecap' are: 'butt', 'round', 'square'.
     * The default value is 'butt'. Not available for VML renderer.
     *
     * @param {JXG.Line} element A arbitrary line.
     * @see Line
     * @see JXG.Line
     * @see JXG.AbstractRenderer#updateLine
     */
    setLineCap(el) {
        var capStyle = el.evalVisProp('linecap');
        if (capStyle === undefined ||
            capStyle === "" ||
            el.visPropOld.linecap === capStyle ||
            !Type.exists(el.rendNode)) {
            return;
        }
        this.setPropertyPrim(el.rendNode, "stroke-linecap", capStyle);
        el.visPropOld.linecap = capStyle;
    }
    /**
     * Sets an objects fill color.
     * @param {JXG.GeometryElement} el Reference of the object that wants a new fill color.
     * @param {String} color Color in a HTML/CSS compatible format. If you don't want any fill color at all, choose
     * 'none'.
     * @param {Number} opacity Opacity of the fill color. Must be between 0 and 1.
     */
    setObjectFillColor(el, color, opacity, rendNode) {
        var node, c, rgbo, oo, rgba = color, o = opacity, grad = el.evalVisProp('gradient');
        o = o > 0 ? o : 0;
        // TODO  save gradient and gradientangle
        if (el.visPropOld.fillcolor === rgba &&
            el.visPropOld.fillopacity === o &&
            grad === null) {
            return;
        }
        if (Type.exists(rgba) && rgba !== 'none') {
            if (rgba.length !== 9) {
                // RGB, not RGBA
                c = rgba;
                oo = o;
            }
            else {
                // True RGBA, not RGB
                rgbo = Color.rgba2rgbo(rgba);
                c = rgbo[0];
                oo = o * rgbo[1];
            }
            if (rendNode === undefined) {
                node = el.rendNode;
            }
            else {
                node = rendNode;
            }
            if (c !== "none" && c !== "" && c !== false) {
                this._setAttribute(function () {
                    node.setAttributeNS(null, "fill", c);
                }, el.visPropOld.fillcolor);
            }
            if (el.type === OBJECT_TYPE.IMAGE) {
                this._setAttribute(function () {
                    node.setAttributeNS(null, "opacity", oo);
                }, el.visPropOld.fillopacity);
                //node.style['opacity'] = oo;  // This would overwrite values set by CSS class.
            }
            else {
                if (c === "none") {
                    // This is done only for non-images
                    // because images have no fill color.
                    oo = 0;
                    // This is necessary if there is a foreignObject below.
                    node.setAttributeNS(null, "pointer-events", "visibleStroke");
                }
                else {
                    // This is the default
                    node.setAttributeNS(null, "pointer-events", "visiblePainted");
                }
                this._setAttribute(function () {
                    node.setAttributeNS(null, "fill-opacity", oo);
                }, el.visPropOld.fillopacity);
            }
            if (grad === "linear" || grad === "radial") {
                this.updateGradient(el);
            }
        }
        el.visPropOld.fillcolor = rgba;
        el.visPropOld.fillopacity = o;
    }
    /**
     * Changes an objects stroke color to the given color.
     * @param {JXG.GeometryElement} el Reference of the {@link JXG.GeometryElement} that gets a new stroke
     * color.
     * @param {String} color Color value in a HTML compatible format, e.g. <strong>#00ff00</strong> or
     * <strong>green</strong> for green.
     * @param {Number} opacity Opacity of the fill color. Must be between 0 and 1.
     */
    setObjectStrokeColor(el, color, opacity) {
        var rgba = color, c, rgbo, o = opacity, oo, node;
        o = o > 0 ? o : 0;
        if (el.visPropOld.strokecolor === rgba && el.visPropOld.strokeopacity === o) {
            return;
        }
        if (Type.exists(rgba) && rgba !== false) {
            if (rgba.length !== 9) {
                // RGB, not RGBA
                c = rgba;
                oo = o;
            }
            else {
                // True RGBA, not RGB
                rgbo = Color.rgba2rgbo(rgba);
                c = rgbo[0];
                oo = o * rgbo[1];
            }
            node = el.rendNode;
            if (el.elementClass === OBJECT_CLASS.TEXT) {
                if (el.evalVisProp('display') === "html") {
                    this._setAttribute(function () {
                        node.style.color = c;
                        node.style.opacity = oo;
                    }, el.visPropOld.strokecolor);
                }
                else {
                    this._setAttribute(function () {
                        node.setAttributeNS(null, "style", "fill:" + c);
                        node.setAttributeNS(null, "style", "fill-opacity:" + oo);
                    }, el.visPropOld.strokecolor);
                }
            }
            else {
                this._setAttribute(function () {
                    node.setAttributeNS(null, "stroke", c);
                    node.setAttributeNS(null, "stroke-opacity", oo);
                }, el.visPropOld.strokecolor);
            }
            if (el.elementClass === OBJECT_CLASS.CURVE ||
                el.elementClass === OBJECT_CLASS.LINE) {
                if (el.evalVisProp('firstarrow')) {
                    this._setArrowColor(el.rendNodeTriangleStart, c, oo, el, el.visPropCalc.typeFirst);
                }
                if (el.evalVisProp('lastarrow')) {
                    this._setArrowColor(el.rendNodeTriangleEnd, c, oo, el, el.visPropCalc.typeLast);
                }
            }
        }
        el.visPropOld.strokecolor = rgba;
        el.visPropOld.strokeopacity = o;
    }
    /**
     * Sets an element's stroke width.
     * @param {JXG.GeometryElement} el Reference to the geometry element.
     * @param {Number} width The new stroke width to be assigned to the element.
     */
    setObjectStrokeWidth(el, width) {
        var node, w = width;
        if (isNaN(w) || el.visPropOld.strokewidth === w) {
            return;
        }
        node = el.rendNode;
        this.setPropertyPrim(node, "stroked", "true");
        if (Type.exists(w)) {
            this.setPropertyPrim(node, "stroke-width", w + "px");
            // if (el.elementClass === Const.OBJECT_CLASS_CURVE ||
            // el.elementClass === Const.OBJECT_CLASS_LINE) {
            //     if (el.evalVisProp('firstarrow')) {
            //         this._setArrowWidth(el.rendNodeTriangleStart, w, el.rendNode);
            //     }
            //
            //     if (el.evalVisProp('lastarrow')) {
            //         this._setArrowWidth(el.rendNodeTriangleEnd, w, el.rendNode);
            //     }
            // }
        }
        el.visPropOld.strokewidth = w;
    }
    /**
     * Sets the transition duration (in milliseconds) for fill color and stroke
     * color and opacity.
     * @param {JXG.GeometryElement} el Reference of the object that wants a
     *         new transition duration.
     * @param {Number} duration (Optional) duration in milliseconds. If not given,
     *        element.visProp.transitionDuration is taken. This is the default.
     */
    setObjectTransition(el, duration) {
        var node, props, transitionArr = [], transitionStr, i, len = 0, nodes = ["rendNode", "rendNodeTriangleStart", "rendNodeTriangleEnd"];
        if (duration === undefined) {
            duration = el.evalVisProp('transitionduration');
        }
        props = el.evalVisProp('transitionproperties');
        if (duration === el.visPropOld.transitionduration &&
            props === el.visPropOld.transitionproperties) {
            return;
        }
        // if (
        //     el.elementClass === Const.OBJECT_CLASS_TEXT &&
        //     el.evalVisProp('display') === "html"
        // ) {
        //     // transitionStr = " color " + duration + "ms," +
        //     //     " opacity " + duration + "ms";
        //     transitionStr = " all " + duration + "ms ease";
        // } else {
        //     transitionStr =
        //         " fill " + duration + "ms," +
        //         " fill-opacity " + duration + "ms," +
        //         " stroke " + duration + "ms," +
        //         " stroke-opacity " + duration + "ms," +
        //         " stroke-width " + duration + "ms," +
        //         " width " + duration + "ms," +
        //         " height " + duration + "ms," +
        //         " rx " + duration + "ms," +
        //         " ry " + duration + "ms";
        // }
        if (Type.exists(props)) {
            len = props.length;
        }
        for (i = 0; i < len; i++) {
            transitionArr.push(props[i] + ' ' + duration + 'ms');
        }
        transitionStr = transitionArr.join(', ');
        len = nodes.length;
        for (i = 0; i < len; ++i) {
            if (el[nodes[i]]) {
                node = el[nodes[i]];
                node.style.transition = transitionStr;
            }
        }
        el.visPropOld.transitionduration = duration;
        el.visPropOld.transitionproperties = props;
    }
    /**
     * Sets the shadow properties to a geometry element. This method is only a stub, it is implemented in the actual
     * renderers.
     * @param {JXG.GeometryElement} el Reference to a geometry object, that should get a shadow
     */
    setShadow(el) {
        var ev_s = el.evalVisProp('shadow'), ev_s_json, c, b, bl, o, op, id, node, use_board_filter = true, show = false;
        ev_s_json = JSON.stringify(ev_s);
        if (ev_s_json === el.visPropOld.shadow) {
            return;
        }
        if (typeof ev_s === 'boolean') {
            use_board_filter = true;
            show = ev_s;
            c = 'none';
            b = 3;
            bl = 0.1;
            o = [5, 5];
            op = 1;
        }
        else {
            if (el.evalVisProp('shadow.enabled')) {
                use_board_filter = false;
                show = true;
                c = Color.rgbParser(el.evalVisProp('shadow.color'));
                b = el.evalVisProp('shadow.blur');
                bl = el.evalVisProp('shadow.blend');
                o = el.evalVisProp('shadow.offset');
                op = el.evalVisProp('shadow.opacity');
            }
            else {
                show = false;
            }
        }
        if (Type.exists(el.rendNode)) {
            if (show) {
                this.assertNonNullish(this.container, 'expected container');
                if (use_board_filter) {
                    el.rendNode.setAttributeNS(null, 'filter', this.toURL(this.container.id + '_' + 'f1'));
                    // 'url(#' + this.container.id + '_' + 'f1)');
                }
                else {
                    node = this.container.ownerDocument.getElementById(id);
                    if (node) {
                        this.defs.removeChild(node);
                    }
                    id = el.rendNode.id + '_' + 'f1';
                    this.defs.appendChild(this.createShadowFilter(id, c, op, bl, b, o));
                    el.rendNode.setAttributeNS(null, 'filter', this.toURL(id));
                    // 'url(#' + id + ')');
                }
            }
            else {
                el.rendNode.removeAttributeNS(null, 'filter');
            }
        }
        el.visPropOld.shadow = ev_s_json;
    }
    /**
     * Set the attribute `tabindex` to the attribute `tabindex` of an element.
     * This is only relevant for the SVG renderer.
     *
     * @param {JXG.GeometryElement} el
     */
    setTabindex(el) {
        var val;
        if (el.board.attr.keyboard.enabled && Type.exists(el.rendNode)) {
            val = el.evalVisProp('tabindex');
            if (!el.visPropCalc.visible /* || el.evalVisProp('fixed') */) {
                val = null;
            }
            if (val !== el.visPropOld.tabindex) {
                el.rendNode.setAttribute("tabindex", val);
                el.visPropOld.tabindex = val;
            }
        }
    }
    /**
     * Sets a node's attribute.
     * @param {Node} node The node that is to be updated.
     * @param {String} key Name of the attribute.
     * @param {String} val New value for the attribute.
     */
    setPropertyPrim(node, key, val) {
        if (key === "stroked") {
            return;
        }
        node.setAttributeNS(null, key, val);
    }
    /**
     * Shows a hidden element on the canvas; Only a stub, requires implementation in the derived renderer.
     *
     * Please use JXG.AbstractRenderer#display instead
     * @param {JXG.GeometryElement} el Reference to the object that has to appear.
     * @see JXG.AbstractRenderer#hide
     * @deprecated
     */
    show(el) {
        JXG.deprecated("Board.renderer.show()", "Board.renderer.display()");
        this.display(el, true);
        // var node;
        //
        // if (el && el.rendNode) {
        //     node = el.rendNode;
        //     node.setAttributeNS(null, 'display', 'inline');
        //     node.style.visibility = "inherit";
        // }
    }
    /**
     * Updates the gradient fill.
     * @param {JXG.GeometryElement} el An JSXGraph element with an area that can be filled.
     */
    updateGradient(el) {
        var col, op, node2 = el.gradNode1, node3 = el.gradNode2, ev_g = el.evalVisProp('gradient');
        if (!Type.exists(node2) || !Type.exists(node3)) {
            return;
        }
        op = el.evalVisProp('fillopacity');
        op = op > 0 ? op : 0;
        col = el.evalVisProp('fillcolor');
        node2.setAttributeNS(null, "style", "stop-color:" + col + ";stop-opacity:" + op);
        node3.setAttributeNS(null, "style", "stop-color:" +
            el.evalVisProp('gradientsecondcolor') +
            ";stop-opacity:" +
            el.evalVisProp('gradientsecondopacity'));
        node2.setAttributeNS(null, "offset", el.evalVisProp('gradientstartoffset') * 100 + "%");
        node3.setAttributeNS(null, "offset", el.evalVisProp('gradientendoffset') * 100 + "%");
        if (ev_g === "linear") {
            this.updateGradientAngle(el.gradNode, el.evalVisProp('gradientangle'));
        }
        else if (ev_g === "radial") {
            this.updateGradientCircle(el.gradNode, el.evalVisProp('gradientcx'), el.evalVisProp('gradientcy'), el.evalVisProp('gradientr'), el.evalVisProp('gradientfx'), el.evalVisProp('gradientfy'), el.evalVisProp('gradientfr'));
        }
    }
    /**
     * Set the gradient angle for linear color gradients.
     *
     * @private
     * @param {SVGnode} node SVG gradient node of an arbitrary JSXGraph element.
     * @param {Number} radians angle value in radians. 0 is horizontal from left to right, Pi/4 is vertical from top to bottom.
     */
    updateGradientAngle(node, radians) {
        // Angles:
        // 0: ->
        // 90: down
        // 180: <-
        // 90: up
        var f = 1.0, co = Math.cos(radians), si = Math.sin(radians);
        if (Math.abs(co) > Math.abs(si)) {
            f /= Math.abs(co);
        }
        else {
            f /= Math.abs(si);
        }
        if (co >= 0) {
            node.setAttributeNS(null, "x1", 0);
            node.setAttributeNS(null, "x2", co * f);
        }
        else {
            node.setAttributeNS(null, "x1", -co * f);
            node.setAttributeNS(null, "x2", 0);
        }
        if (si >= 0) {
            node.setAttributeNS(null, "y1", 0);
            node.setAttributeNS(null, "y2", si * f);
        }
        else {
            node.setAttributeNS(null, "y1", -si * f);
            node.setAttributeNS(null, "y2", 0);
        }
    }
    /**
     * Set circles for radial color gradients.
     *
     * @private
     * @param {SVGnode} node SVG gradient node
     * @param {Number} cx SVG value cx (value between 0 and 1)
     * @param {Number} cy  SVG value cy (value between 0 and 1)
     * @param {Number} r  SVG value r (value between 0 and 1)
     * @param {Number} fx  SVG value fx (value between 0 and 1)
     * @param {Number} fy  SVG value fy (value between 0 and 1)
     * @param {Number} fr  SVG value fr (value between 0 and 1)
     */
    updateGradientCircle(node, cx, cy, r, fx, fy, fr) {
        node.setAttributeNS(null, "cx", cx * 100 + "%"); // Center first color
        node.setAttributeNS(null, "cy", cy * 100 + "%");
        node.setAttributeNS(null, "r", r * 100 + "%");
        node.setAttributeNS(null, "fx", fx * 100 + "%"); // Center second color / focal point
        node.setAttributeNS(null, "fy", fy * 100 + "%");
        node.setAttributeNS(null, "fr", fr * 100 + "%");
    }
    /* ********* Renderer control *********** */
    /**
      * Stop redraw. This method is called before every update, so a non-vector-graphics based renderer can use this
      * method to delete the contents of the drawing panel. This is an abstract method every descendant renderer
      * should implement, if appropriate.
      * @see JXG.AbstractRenderer#unsuspendRedraw
      */
    suspendRedraw() {
        // It seems to be important for the Linux version of firefox
        console.warn('suspendRedraw is Depreciated');
        // this.suspendHandle = this.svgRoot.suspendRedraw(10000);
    }
    /**
     * Restart redraw. This method is called after updating all the rendering node attributes.
     * @see JXG.AbstractRenderer#suspendRedraw
     */
    unsuspendRedraw() {
        console.warn('suspendRedraw is Depreciated');
        // this.svgRoot.unsuspendRedraw(this.suspendHandle);
    }
    /**
     * Resizes the rendering element
     * @param {Number} w New width
     * @param {Number} h New height
     */
    resize(w, h) {
        this.assertNonNullish(this.svgRoot, "Expected a node");
        this.svgRoot.setAttribute("width", w.toString());
        this.svgRoot.setAttribute("height", h.toString());
    }
    /**
     * Create crosshair elements (Fadenkreuz) for presentations.
     * @param {Number} n Number of crosshairs.
     */
    createTouchpoints(n) {
        var i, na1, na2, node;
        this.touchpoints = [];
        for (i = 0; i < n; i++) {
            na1 = "touchpoint1_" + i;
            node = this.createPrim("path", na1);
            this.appendChildPrim(node, 19);
            node.setAttributeNS(null, "d", "M 0 0");
            this.touchpoints.push(node);
            this.setPropertyPrim(node, "stroked", "true");
            this.setPropertyPrim(node, "stroke-width", "1px");
            node.setAttributeNS(null, "stroke", "#000000");
            node.setAttributeNS(null, "stroke-opacity", 1.0);
            node.setAttributeNS(null, "display", "none");
            na2 = "touchpoint2_" + i;
            node = this.createPrim("ellipse", na2);
            this.appendChildPrim(node, 19);
            this.updateEllipsePrim(node, 0, 0, 0, 0);
            this.touchpoints.push(node);
            this.setPropertyPrim(node, "stroked", "true");
            this.setPropertyPrim(node, "stroke-width", "1px");
            node.setAttributeNS(null, "stroke", "#000000");
            node.setAttributeNS(null, "stroke-opacity", 1.0);
            node.setAttributeNS(null, "fill", "#ffffff");
            node.setAttributeNS(null, "fill-opacity", 0.0);
            node.setAttributeNS(null, "display", "none");
        }
    }
    /**
     * Show a specific crosshair.
     * @param {Number} i Number of the crosshair to show
     */
    showTouchpoint(i) {
        if (this.touchpoints && i >= 0 && 2 * i < this.touchpoints.length) {
            this.touchpoints[2 * i].setAttributeNS(null, "display", "inline");
            this.touchpoints[2 * i + 1].setAttributeNS(null, "display", "inline");
        }
    }
    /**
     * Hide a specific crosshair.
     * @param {Number} i Number of the crosshair to show
     */
    hideTouchpoint(i) {
        if (this.touchpoints && i >= 0 && 2 * i < this.touchpoints.length) {
            this.touchpoints[2 * i].setAttributeNS(null, "display", "none");
            this.touchpoints[2 * i + 1].setAttributeNS(null, "display", "none");
        }
    }
    /**
     * Move a specific crosshair.
     * @param {Number} i Number of the crosshair to show
     * @param {Array} pos New positon in screen coordinates
     */
    updateTouchpoint(i, pos) {
        var x, y, d = 37;
        if (this.touchpoints && i >= 0 && 2 * i < this.touchpoints.length) {
            x = pos[0];
            y = pos[1];
            this.touchpoints[2 * i].setAttributeNS(null, "d", "M " +
                (x - d) +
                " " +
                y +
                " " +
                "L " +
                (x + d) +
                " " +
                y +
                " " +
                "M " +
                x +
                " " +
                (y - d) +
                " " +
                "L " +
                x +
                " " +
                (y + d));
            this.updateEllipsePrim(this.touchpoints[2 * i + 1], pos[0], pos[1], 25, 25);
        }
    }
    /* ********* Dump related stuff *********** */
    /**
     * Walk recursively through the DOM subtree of a node and collect all
     * value attributes together with the id of that node.
     * <b>Attention:</b> Only values of nodes having a valid id are taken.
     * @param  {Node} node   root node of DOM subtree that will be searched recursively.
     * @return {Array}      Array with entries of the form [id, value]
     * @private
     */
    _getValuesOfDOMElements(node) {
        var values = [];
        if (node.nodeType === 1) {
            node = node.firstChild;
            while (node) {
                if (node.id !== undefined && node.value !== undefined) {
                    values.push([node.id, node.value]);
                }
                Type.concat(values, this._getValuesOfDOMElements(node));
                node = node.nextSibling;
            }
        }
        return values;
    }
    // _getDataUri(url, callback) {
    //     var image = new Image();
    //     image.onload = function () {
    //         var canvas = document.createElement("canvas");
    //         canvas.width = this.naturalWidth; // or 'width' if you want a special/scaled size
    //         canvas.height = this.naturalHeight; // or 'height' if you want a special/scaled size
    //         canvas.getContext("2d").drawImage(this, 0, 0);
    //         callback(canvas.toDataURL("image/png"));
    //         canvas.remove();
    //     };
    //     image.src = url;
    // }
    _getImgDataURL(svgRoot) {
        var images, len, canvas, ctx, ur, i;
        images = svgRoot.getElementsByTagName("image");
        len = images.length;
        if (len > 0) {
            canvas = document.createElement("canvas");
            //img = new Image();
            for (i = 0; i < len; i++) {
                images[i].setAttribute("crossorigin", "anonymous");
                //img.src = images[i].href;
                //img.onload = function() {
                // img.crossOrigin = "anonymous";
                ctx = canvas.getContext("2d");
                canvas.width = images[i].getAttribute("width");
                canvas.height = images[i].getAttribute("height");
                try {
                    ctx.drawImage(images[i], 0, 0, canvas.width, canvas.height);
                    // If the image is not png, the format must be specified here
                    ur = canvas.toDataURL();
                    images[i].setAttribute("xlink:href", ur);
                }
                catch (err) {
                    console.log("CORS problem! Image can not be used", err);
                }
            }
            //canvas.remove();
        }
        return true;
    }
    /**
     * Return a data URI of the SVG code representing the construction.
     * The SVG code of the construction is base64 encoded. The return string starts
     * with "data:image/svg+xml;base64,...".
     *
     * @param {Boolean} ignoreTexts If true, the foreignObject tag is set to display=none.
     * This is necessary for older versions of Safari. Default: false
     * @returns {String}  data URI string
     *
     * @example
     * var A = board.create('point', [2, 2]);
     *
     * var txt = board.renderer.dumpToDataURI(false);
     * // txt consists of a string of the form
     * // data:image/svg+xml;base64,PHN2Zy. base64 encoded SVG..+PC9zdmc+
     * // Behind the comma, there is the base64 encoded SVG code
     * // which is decoded with atob().
     * // The call of decodeURIComponent(escape(...)) is necessary
     * // to handle unicode strings correctly.
     * var ar = txt.split(',');
     * document.getElementById('output').value = decodeURIComponent(escape(atob(ar[1])));
     *
     * </pre><div id="JXG1bad4bec-6d08-4ce0-9b7f-d817e8dd762d" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <textarea id="output2023" rows="5" cols="50"></textarea>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG1bad4bec-6d08-4ce0-9b7f-d817e8dd762d',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var A = board.create('point', [2, 2]);
     *
     *     var txt = board.renderer.dumpToDataURI(false);
     *     // txt consists of a string of the form
     *     // data:image/svg+xml;base64,PHN2Zy. base64 encoded SVG..+PC9zdmc+
     *     // Behind the comma, there is the base64 encoded SVG code
     *     // which is decoded with atob().
     *     // The call of decodeURIComponent(escape(...)) is necessary
     *     // to handle unicode strings correctly.
     *     var ar = txt.split(',');
     *     document.getElementById('output2023').value = decodeURIComponent(escape(atob(ar[1])));
     *
     *     })();
     *
     * </script><pre>
     *
     */
    dumpToDataURI(ignoreTexts) {
        let btoa = window.btoa || Base64.encode, svg, i, len, values = [];
        var svgRoot = this.svgRoot;
        this.assertNonNullish(svgRoot, "Expected a node");
        // Move all HTML tags (beside the SVG root) of the container
        // to the foreignObject element inside of the svgRoot node
        // Problem:
        // input values are not copied. This can be verified by looking at an innerHTML output
        // of an input element. Therefore, we do it "by hand".
        this.assertNonNullish(this.container, "Expected a node");
        if (this.container.hasChildNodes() && Type.exists(this.foreignObjLayer)) {
            if (!ignoreTexts) {
                this.foreignObjLayer.setAttribute("display", "inline");
            }
            while (svgRoot.nextSibling) {
                // Copy all value attributes
                Type.concat(values, this._getValuesOfDOMElements(svgRoot.nextSibling));
                this.foreignObjLayer.appendChild(svgRoot.nextSibling);
            }
        }
        this._getImgDataURL(svgRoot);
        // Convert the SVG graphic into a string containing SVG code
        svgRoot.setAttribute("xmlns", "http://www.w3.org/2000/svg");
        svg = new XMLSerializer().serializeToString(svgRoot);
        if (ignoreTexts !== true) {
            // Handle SVG texts
            // Insert all value attributes back into the svg string
            len = values.length;
            for (i = 0; i < len; i++) {
                svg = svg.replace('id="' + values[i][0] + '"', 'id="' + values[i][0] + '" value="' + values[i][1] + '"');
            }
        }
        // if (false) {
        //     // Debug: use example svg image
        //     svg = '<svg xmlns="http://www.w3.org/2000/svg" version="1.0" width="220" height="220"><rect width="66" height="30" x="21" y="32" stroke="#204a87" stroke-width="2" fill="none" /></svg>';
        // }
        // In IE we have to remove the namespace again.
        // Since 2024 we have to check if the namespace attribute appears twice in one tag, because
        // there might by a svg inside of the svg, e.g. the screenshot icon.
        if (this.isSafari &&
            (svg.match(/xmlns="http:\/\/www.w3.org\/2000\/svg"\s+xmlns="http:\/\/www.w3.org\/2000\/svg"/g) || []).length > 1) {
            svg = svg.replace(/xmlns="http:\/\/www.w3.org\/2000\/svg"\s+xmlns="http:\/\/www.w3.org\/2000\/svg"/g, "");
        }
        // Safari fails if the svg string contains a "&nbsp;"
        // Obsolete with Safari 12+
        svg = svg.replace(/&nbsp;/g, " ");
        // Replacing &quot;s might be necessary for older Safari versions
        // svg = svg.replace(/url\(&quot;(.*)&quot;\)/g, "url($1)"); // Bug: does not replace matching &quot;s
        // svg = svg.replace(/&quot;/g, "");
        // Move all HTML tags back from
        // the foreignObject element to the container
        if (Type.exists(this.foreignObjLayer) && this.foreignObjLayer.hasChildNodes()) {
            // Restore all HTML elements
            while (this.foreignObjLayer.firstChild) {
                this.assertNonNullish(this.container, "Expected a node");
                this.container.appendChild(this.foreignObjLayer.firstChild);
            }
            this.foreignObjLayer.setAttribute("display", "none");
        }
        return "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svg)));
    }
    /**
     * Convert the SVG construction into an HTML canvas image.
     * This works for all SVG supporting browsers. Implemented as Promise.
     * <p>
     * Might fail if any text element or foreign object element contains SVG. This
     * is the case e.g. for the default fullscreen symbol.
     * <p>
     * For IE, it is realized as function.
     * It works from version 9, with the exception that HTML texts
     * are ignored on IE. The drawing is done with a delay of
     * 200 ms. Otherwise there would be problems with IE.
     *
     * @param {String} canvasId Id of an HTML canvas element
     * @param {Number} w Width in pixel of the dumped image, i.e. of the canvas tag.
     * @param {Number} h Height in pixel of the dumped image, i.e. of the canvas tag.
     * @param {Boolean} ignoreTexts If true, the foreignObject tag is taken out from the SVG root.
     * This is necessary for older versions of Safari. Default: false
     * @returns {Promise}  Promise object
     *
     * @example
     * 	board.renderer.dumpToCanvas('canvas').then(function() { console.log('done'); });
     *
     * @example
     *  // IE 11 example:
     * 	board.renderer.dumpToCanvas('canvas');
     * 	setTimeout(function() { console.log('done'); } 400);
     */
    dumpToCanvas(canvasId, w, h, ignoreTexts) {
        var svg, tmpImg, cv, ctx;
        this.assertNonNullish(this.container, "Expected a node");
        let doc = this.container.ownerDocument;
        // Prepare the canvas element
        cv = doc.getElementById(canvasId);
        // Clear the canvas
        /* eslint-disable no-self-assign */
        cv.width = cv.width;
        /* eslint-enable no-self-assign */
        ctx = cv.getContext("2d");
        if (w !== undefined && h !== undefined) {
            cv.style.width = parseFloat(w) + "px";
            cv.style.height = parseFloat(h) + "px";
            // Scale twice the CSS size to make the image crisp
            // cv.setAttribute('width', 2 * parseFloat(wOrg));
            // cv.setAttribute('height', 2 * parseFloat(hOrg));
            // ctx.scale(2 * wOrg / w, 2 * hOrg / h);
            cv.setAttribute("width", parseFloat(w));
            cv.setAttribute("height", parseFloat(h));
        }
        // Display the SVG string as data-uri in an HTML img.
        /**
         * @type {Image}
         * @ignore
         * {ignore}
         */
        tmpImg = new Image();
        svg = this.dumpToDataURI(ignoreTexts);
        tmpImg.src = svg;
        // Finally, draw the HTML img in the canvas.
        if (!("Promise" in window)) {
            /**
             * @function
             * @ignore
             */
            tmpImg.onload = function () {
                // IE needs a pause...
                // Seems to be broken
                window.setTimeout(function () {
                    try {
                        ctx.drawImage(tmpImg, 0, 0, w, h);
                    }
                    catch (err) {
                        console.log("screenshots not longer supported on IE");
                    }
                }, 200);
            };
            return new Promise(() => { }); // TODO:  this is wrong, but caller expects a promise...
        }
        return new Promise(function (resolve, reject) {
            try {
                tmpImg.onload = function () {
                    ctx.drawImage(tmpImg, 0, 0, w, h);
                    this.resolve();
                };
            }
            catch (e) {
                reject(e);
            }
        });
    }
    /**
     * Display SVG image in html img-tag which enables
     * easy download for the user.
     *
     * Support:
     * <ul>
     * <li> IE: No
     * <li> Edge: full
     * <li> Firefox: full
     * <li> Chrome: full
     * <li> Safari: full (No text support in versions prior to 12).
     * </ul>
     *
     * @param {JXG.Board} board Link to the board.
     * @param {String} imgId Optional id of an img object. If given and different from the empty string,
     * the screenshot is copied to this img object. The width and height will be set to the values of the
     * JSXGraph container.
     * @param {Boolean} ignoreTexts If set to true, the foreignObject is taken out of the
     *  SVGRoot and texts are not displayed. This is mandatory for Safari. Default: false
     * @return {Object}       the svg renderer object
     */
    screenshot(board, imgId, ignoreTexts) {
        var node, 
        // cPos,
        // cssTxt,
        canvas, id, img, button, buttonText, w, h, bas = board.attr.screenshot, navbar, navbarDisplay, insert, newImg = false, _copyCanvasToImg;
        this.assertNonNullish(this.container, "Expected a node");
        let doc = this.container.ownerDocument;
        this.assertNonNullish(doc, "Expected a node");
        let parent = this.container.parentNode;
        this.assertNonNullish(parent, "Expected a node");
        if (this.type === "no") {
            return this;
        }
        this.assertNonNullish(this.container.getBoundingClientRect(), "Expected a node");
        w = bas.scale * this.container.getBoundingClientRect().width;
        h = bas.scale * this.container.getBoundingClientRect().height;
        if (imgId === undefined || imgId === "") {
            newImg = true;
            img = new Image(); //doc.createElement('img');
            img.style.width = w + "px";
            img.style.height = h + "px";
        }
        else {
            newImg = false;
            img = doc.getElementById(imgId);
        }
        // img.crossOrigin = 'anonymous';
        // Create div which contains canvas element and close button
        if (newImg) {
            node = doc.createElement("div");
            node.style.cssText = bas.css;
            node.style.width = w + "px";
            node.style.height = h + "px";
            this.assertNonNullish(this.container, "Expected a node");
            node.style.zIndex = this.container.style.zIndex + 120;
            // Try to position the div exactly over the JSXGraph board
            node.style.position = "absolute";
            node.style.top = this.container.offsetTop + "px";
            node.style.left = this.container.offsetLeft + "px";
        }
        {
            // Create canvas element and add it to the DOM
            // It will be removed after the image has been stored.
            canvas = doc.createElement("canvas");
            id = Math.random().toString(36).slice(2, 7);
            canvas.setAttribute("id", id);
            canvas.setAttribute("width", w);
            canvas.setAttribute("height", h);
            canvas.style.width = w + "px";
            canvas.style.height = w + "px";
            canvas.style.display = "none";
            this.assertNonNullish(parent, "Expected a node");
            this.assertNonNullish(parent, "Expected a node");
            parent.appendChild(canvas);
        }
        if (newImg) {
            // Create close button
            button = doc.createElement("span");
            buttonText = doc.createTextNode("\u2716");
            button.style.cssText = bas.cssButton;
            button.appendChild(buttonText);
            button.onclick = function () {
                node.parentNode.removeChild(node);
            };
            // Add all nodes
            node.appendChild(img);
            node.appendChild(button);
            this.assertNonNullish(this.container, "Expected a container");
            this.assertNonNullish(parent, "Expected a node");
            parent.insertBefore(node, this.container.nextSibling);
        }
        // Hide navigation bar in board
        navbar = doc.getElementById(this.uniqName('navigationbar'));
        if (Type.exists(navbar)) {
            navbarDisplay = navbar.style.display;
            navbar.style.display = "none";
            insert = this.removeToInsertLater(navbar);
        }
        _copyCanvasToImg = function () {
            // Show image in img tag
            img.src = canvas.toDataURL("image/png");
            // Remove canvas node
            if (parent !== null) {
                parent.removeChild(canvas);
            }
        };
        // Create screenshot in image element
        // if ("Promise" in window) {
        this.dumpToCanvas(id, w, h, ignoreTexts).then(_copyCanvasToImg);
        // } else {
        //     // IE
        //     this.dumpToCanvas(id, w, h, ignoreTexts);
        //     window.setTimeout(_copyCanvasToImg, 200);
        // }
        // Reinsert navigation bar in board
        if (Type.exists(navbar)) {
            navbar.style.display = navbarDisplay;
            insert();
        }
        return this;
    }
}

/*
    Copyright 2008-2025
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>
    and <https://opensource.org/licenses/MIT/>.
 */
/*global JXG: true, document:true, jQuery:true, define: true, window: true*/
/*jslint nomen: true, plusplus: true*/
/**
 * @fileoverview The JSXGraph object is defined in this file. JXG.JSXGraph controls all boards.
 * It has methods to create, save, load and free boards. Additionally some helper functions are
 * defined in this file directly in the JXG namespace.
 *
 */
// import CanvasRenderer from './renderer/canvas.js';
// import NoRenderer from './renderer/no.js';
/**
 * Constructs a new JSXGraph singleton object.
 * @class The JXG.JSXGraph singleton stores all properties required
 * to load, save, create and free a board.
 */
class JSXGraph {
    // constructor() {
    //     this.rendererType = this.setRendererType();
    // }
    static setRendererType() {
        Options.board.renderer = 'no';
        if (Env.supportsCanvas()) {
            Options.board.renderer = 'canvas';
        }
        if (Env.supportsSVG()) {
            Options.board.renderer = 'svg';
        }
        // we are inside node
        if (Env.isNode() && Env.supportsCanvas()) {
            Options.board.renderer = 'canvas';
        }
        if (Env.isNode() || Options.board.renderer === 'no') {
            Options.text.display = 'internal';
            Options.infobox.display = 'internal';
        }
        return Options.board.renderer;
    }
    /**
     * Initialize the rendering engine
     *
     * @param  {String} box        id of or reference to the div element which hosts the JSXGraph construction
     * @param  {Object} dim        The dimensions of the board
     * @param  {Object} doc        Usually, this is document object of the browser window.  If false or null, this defaults
     * to the document object of the browser.
     * @param  {Object} attrRenderer Attribute 'renderer', specifies the rendering engine. Possible values are 'auto', 'svg',
     *  'canvas', 'no', and 'vml'.
     * @returns {Object}           Reference to the rendering engine object.
     * @private
     */
    static initRenderer(box, dim, doc = null, attrRenderer = 'svg') {
        var boxid, renderer;
        // Former version:
        // doc = doc || document
        if ((!Type.exists(doc) || doc === false) && typeof document === 'object') {
            doc = document;
        }
        if (typeof doc === 'object' && box !== null) {
            boxid = Type.isString(box) ? doc.getElementById(box) : box;
            // Remove everything from the container before initializing the renderer and the board
            while (boxid.fievenrstChild) {
                boxid.removeChild(boxid.firstChild);
            }
        }
        else {
            boxid = box;
        }
        // If attrRenderer is not supplied take the first available renderer
        if (attrRenderer === undefined || attrRenderer === 'auto') {
            attrRenderer = this.rendererType;
        }
        // create the renderer
        if (attrRenderer === 'svg') {
            renderer = new SVGRenderer(boxid, dim);
            // } else if (attrRenderer === 'canvas') {      // TODO
            //     renderer = new CanvasRenderer(boxid, dim);
            // } else {
            //     renderer = new NoRenderer();
        }
        return renderer;
    }
    /**
     * Merge the user supplied attributes with the attributes in options.js
     *
     * @param {Object} attributes User supplied attributes
     * @returns {Object} Merged attributes for the board
     *
     * @private
     */
    static _setAttributes(attributes, options = {}) {
        // merge attributes
        let attr = Type.copyAttributes(attributes, options, 'board'), 
        // These attributes - which are objects - have to be copied separately.
        list = [
            'drag',
            'fullscreen',
            'intl',
            'keyboard',
            'logging',
            'pan',
            'resize',
            'screenshot',
            'selection',
            'zoom',
        ], len = list.length, i, key;
        for (i = 0; i < len; i++) {
            key = list[i];
            attr[key] = Type.copyAttributes(attr, options, 'board', key);
        }
        attr.navbar = Type.copyAttributes(attr.navbar, options, 'navbar');
        // Treat moveTarget separately, because deepCopy will not work here.
        // Reason: moveTarget will be an HTML node and it is prevented that Type.deepCopy will copy it.
        attr.movetarget =
            attributes.moveTarget ||
                attributes.movetarget ||
                Options.board.moveTarget;
        return attr;
    }
    /**
     * Further initialization of the board. Set some properties from attribute values.
     *
     * @param {JXG.Board} board
     * @param {Object} attr attributes object
     * @param {Object} dimensions Object containing dimensions of the canvas
     *
     * @private
     */
    static _fillBoard(board, attr, dimensions) {
        board.initInfobox(attr.infobox);
        board.maxBoundingBox = attr.maxBoundingBox;
        board.resizeContainer(dimensions.width, dimensions.height, true, true);
        board._createSelectionPolygon(attr);
        board.renderer.drawNavigationBar(board, attr.navbar);
        JXG.boards[board.id] = board;
    }
    /**
     *
     * @param {String|Object} container id of or reference to the HTML element in which the board is painted.
     * @param {Object} attr An object that sets some of the board properties.
     *
     * @private
     */
    static _setARIA(container, attr) {
        let doc = attr.document;
        // Unused variables, made obsolete in db3e50f4dfa8b86b1ff619b578e243a97b41151c
        // doc_glob,
        // newNode,
        // parent,
        // id_label,
        // id_description;
        if (!doc) {
            if (!Env.isBrowser) {
                return;
            }
            doc = document;
        }
        let node_jsx = Type.isString(container)
            ? doc.getElementById(container)
            : container;
        node_jsx.setAttribute('role', 'region');
        node_jsx.setAttribute('aria-label', attr.title); // set by initBoard( {title:})
        // doc_glob = node_jsx.ownerDocument; // This is the window.document element, needed below.
        // parent = node_jsx.parentNode;
    }
    /**
     * Remove the two corresponding ARIA divs when freeing a board
     *
     * @param {JXG.Board} board
     *
     * @private
     */
    static _removeARIANodes(board) {
        var node, id, doc;
        doc = board.document || document;
        if (typeof doc !== 'object') {
            return;
        }
        id = board.containerObj.getAttribute('aria-labelledby');
        node = doc.getElementById(id);
        if (node && node.parentNode) {
            node.parentNode.removeChild(node);
        }
        id = board.containerObj.getAttribute('aria-describedby');
        node = doc.getElementById(id);
        if (node && node.parentNode) {
            node.parentNode.removeChild(node);
        }
    }
    /**
     * Initialize a new board.
     * @param {String|Object} box id of or reference to the HTML element in which the board is painted.
     * @param {Object} attributes An object that sets some of the board properties. Most of these properties can be set via JXG.Options.
     * @param {Array} [attributes.boundingbox=[-5, 5, 5, -5]] An array containing four numbers describing the left, top, right and bottom boundary of the board in user coordinates
     * @param {Boolean} [attributes.keepaspectratio=false] If <tt>true</tt>, the bounding box is adjusted to the same aspect ratio as the aspect ratio of the div containing the board.
     * @param {Boolean} [attributes.showCopyright=false] Show the copyright string in the top left corner.
     * @param {Boolean} [attributes.showNavigation=false] Show the navigation buttons in the bottom right corner.
     * @param {Object} [attributes.zoom] Allow the user to zoom with the mouse wheel or the two-fingers-zoom gesture.
     * @param {Object} [attributes.pan] Allow the user to pan with shift+drag mouse or two-fingers-pan gesture.
     * @param {Object} [attributes.drag] Allow the user to drag objects with a pointer device.
     * @param {Object} [attributes.keyboard] Allow the user to drag objects with arrow keys on keyboard.
     * @param {Boolean} [attributes.axis=false] If set to true, show the axis. Can also be set to an object that is given to both axes as an attribute object.
     * @param {Boolean|Object} [attributes.grid] If set to true, shows the grid. Can also be set to an object that is given to the grid as its attribute object.
     * @param {Boolean} [attributes.registerEvents=true] Register mouse / touch events.
     * @returns {JXG.Board} Reference to the created board.
     *
     * @see JXG.AbstractRenderer#drawNavigationBar
     */
    static initBoard(box, attributes) {
        var originX, originY, unitX, unitY, w, h, offX = 0, offY = 0, renderer, dimensions, bbox, attr, axattr, axattr_x, axattr_y, options, theme = {};
        attributes = attributes || {};
        // Merge a possible theme
        if (attributes.theme !== 'default' &&
            Type.exists(JXG.themes[attributes.theme])) {
            theme = JXG.themes[attributes.theme];
        }
        options = Type.deepCopy(Options, theme);
        attr = this._setAttributes(attributes, options);
        dimensions = Env.getDimensions(box, attr.document);
        if (attr.unitx || attr.unity) {
            originX = Type.def(attr.originx, 150);
            originY = Type.def(attr.originy, 150);
            unitX = Type.def(attr.unitx, 50);
            unitY = Type.def(attr.unity, 50);
        }
        else {
            bbox = attr.boundingbox;
            console.log(attr);
            if (bbox[0] < attr.maxboundingbox[0]) {
                bbox[0] = attr.maxboundingbox[0];
            }
            if (bbox[1] > attr.maxboundingbox[1]) {
                bbox[1] = attr.maxboundingbox[1];
            }
            if (bbox[2] > attr.maxboundingbox[2]) {
                bbox[2] = attr.maxboundingbox[2];
            }
            if (bbox[3] < attr.maxboundingbox[3]) {
                bbox[3] = attr.maxboundingbox[3];
            }
            // Size of HTML div.
            // If zero, the size is set to a small value to avoid
            // division by zero.
            // w = Math.max(parseInt(dimensions.width, 10), JSXMath.eps);
            // h = Math.max(parseInt(dimensions.height, 10), JSXMath.eps);
            w = parseInt(dimensions.width, 10);
            h = parseInt(dimensions.height, 10);
            if (Type.exists(bbox) && attr.keepaspectratio) {
                /*
                 * If the boundingbox attribute is given and the ratio of height and width of the
                 * sides defined by the bounding box and the ratio of the dimensions of the div tag
                 * which contains the board do not coincide, then the smaller side is chosen.
                 */
                unitX = w / (bbox[2] - bbox[0]);
                unitY = h / (bbox[1] - bbox[3]);
                if (Math.abs(unitX) < Math.abs(unitY)) {
                    unitY = (Math.abs(unitX) * unitY) / Math.abs(unitY);
                    // Add the additional units in equal portions above and below
                    offY = (h / unitY - (bbox[1] - bbox[3])) * 0.5;
                }
                else {
                    unitX = (Math.abs(unitY) * unitX) / Math.abs(unitX);
                    // Add the additional units in equal portions left and right
                    offX = (w / unitX - (bbox[2] - bbox[0])) * 0.5;
                }
            }
            else {
                unitX = w / (bbox[2] - bbox[0]);
                unitY = h / (bbox[1] - bbox[3]);
            }
            originX = -unitX * (bbox[0] - offX);
            originY = unitY * (bbox[1] + offY);
        }
        renderer = this.initRenderer(box, dimensions, attr.document, attr.renderer);
        this._setARIA(box, attr);
        // Create the board.
        // board.options will contain the user supplied board attributes
        let board = new Board(box, renderer, attr.id, [originX, originY], 
        /*attr.zoomfactor * */ attr.zoomx, 
        /*attr.zoomfactor * */ attr.zoomy, unitX, unitY, dimensions.width, dimensions.height, attr);
        // TODO:  board.keepaspectratio = attr.keepaspectratio;
        this._fillBoard(board, attr, dimensions);
        // Create elements like axes, grid, navigation, ...
        board.suspendUpdate();
        attr = board.attr;
        if (attr.axis) {
            axattr = typeof attr.axis === 'object' ? attr.axis : {};
            // The defaultAxes attributes are overwritten by user supplied axis object.
            axattr_x = Type.deepCopy(options.board.defaultaxes.x, axattr);
            axattr_y = Type.deepCopy(options.board.defaultaxes.y, axattr);
            // The user supplied defaultAxes attributes are merged in.
            if (attr.defaultaxes.x) {
                axattr_x = Type.deepCopy(axattr_x, attr.defaultaxes.x);
            }
            if (attr.defaultaxes.y) {
                axattr_y = Type.deepCopy(axattr_y, attr.defaultaxes.y);
            }
            Options.board.defaultAxes = {};
            Options.board.defaultAxes.x = board.create('axis', [
                [0, 0],
                [1, 0],
            ], axattr_x);
            Options.board.defaultAxes.y = board.create('axis', [
                [0, 0],
                [0, 1],
            ], axattr_y);
        }
        if (attr.grid) {
            board.create('grid', [], typeof attr.grid === 'object' ? attr.grid : {});
        }
        board.unsuspendUpdate();
        return board;
    }
    /**
     * Load a board from a file containing a construction made with either GEONExT,
     * Intergeo, Geogebra, or Cinderella.
     * @param {String|Object} box id of or reference to the HTML element in which the board is painted.
     * @param {String} file base64 encoded string.
     * @param {String} format containing the file format: 'Geonext' or 'Intergeo'.
     * @param {Object} attributes Attributes for the board and 'encoding'.
     *  Compressed files need encoding 'iso-8859-1'. Otherwise it probably is 'utf-8'.
     * @param {Function} callback
     * @returns {JXG.Board} Reference to the created board.
     * @see JXG.FileReader
     * @see JXG.GeonextReader
     * @see JXG.GeogebraReader
     * @see JXG.IntergeoReader
     * @see JXG.CinderellaReader
     *
     * @example
     * // Uncompressed file
     * var board = JXG.JSXGraph.loadBoardFromFile('jxgbox', 'filename', 'geonext',
     *      {encoding: 'utf-8'}
     *      function (board) { console.log("Done loading"); }
     * );
     * // Compressed file
     * var board = JXG.JSXGraph.loadBoardFromFile('jxgbox', 'filename', 'geonext',
     *      {encoding: 'iso-8859-1'}
     *      function (board) { console.log("Done loading"); }
     * );
     *
     * @example
     * // From <input type="file" id="localfile" />
     * var file = document.getElementById('localfile').files[0];
     * JXG.JSXGraph.loadBoardFromFile('jxgbox', file, 'geonext',
     *      {encoding: 'utf-8'}
     *      function (board) { console.log("Done loading"); }
     * );
     */
    static loadBoardFromFile(box, file, format, attributes, callback) {
        var attr, renderer, board, dimensions, encoding;
        attributes = attributes || {};
        attr = this._setAttributes(attributes);
        dimensions = Env.getDimensions(box, attr.document);
        renderer = this.initRenderer(box, dimensions, attr.document, attr.renderer);
        this._setARIA(box, attr);
        /* User default parameters, in parse* the values in the gxt files are submitted to board */
        board = new Board(box, renderer, '', [150, 150], 1, 1, 50, 50, dimensions.width, dimensions.height, attr);
        this._fillBoard(board, attr, dimensions);
        encoding = attr.encoding || 'iso-8859-1';
        JSXFileReader.parseFileContent(file, board, format, true, encoding, callback);
        return board;
    }
    /**
     * Load a board from a base64 encoded string containing a construction made with either GEONExT,
     * Intergeo, Geogebra, or Cinderella.
     * @param {String|Object} box id of or reference to the HTML element in which the board is painted.
     * @param {String} string base64 encoded string.
     * @param {String} format containing the file format: 'Geonext', 'Intergeo', 'Geogebra'.
     * @param {Object} attributes Attributes for the board and 'encoding'.
     *  Compressed files need encoding 'iso-8859-1'. Otherwise it probably is 'utf-8'.
     * @param {Function} callback
     * @returns {JXG.Board} Reference to the created board.
     * @see JXG.FileReader
     * @see JXG.GeonextReader
     * @see JXG.GeogebraReader
     * @see JXG.IntergeoReader
     * @see JXG.CinderellaReader
     */
    static loadBoardFromString(box, string, format, attributes, callback) {
        var attr, renderer, board, dimensions;
        attributes = attributes || {};
        attr = this._setAttributes(attributes);
        dimensions = Env.getDimensions(box, attr.document);
        renderer = this.initRenderer(box, dimensions, attr.document, attr.renderer);
        this._setARIA(box, attr);
        /* User default parameters, in parse* the values in the gxt files are submitted to board */
        board = new Board(box, renderer, '', [150, 150], 1.0, 1.0, 50, 50, dimensions.width, dimensions.height, attr);
        this._fillBoard(board, attr, dimensions);
        JSXFileReader.parseString(string, board, format, callback);
        return board;
    }
    /**
     * Delete a board and all its contents.
     * @param {JXG.Board|String} board id of or reference to the DOM element in which the board is drawn.
     *
     */
    static freeBoard(board) {
        var el;
        if (typeof board === 'string') {
            board = JXG.boards[board];
        }
        this._removeARIANodes(board);
        board.removeEventHandlers();
        board.suspendUpdate();
        // Remove all objects from the board.
        for (el in board.objects) {
            if (board.objects.hasOwnProperty(el)) {
                board.objects[el].remove();
            }
        }
        // Remove all the other things, left on the board, XHTML save
        while (board.containerObj.firstChild) {
            board.containerObj.removeChild(board.containerObj.firstChild);
        }
        // Tell the browser the objects aren't needed anymore
        for (el in board.objects) {
            if (board.objects.hasOwnProperty(el)) {
                delete board.objects[el];
            }
        }
        // Free the renderer and the algebra object
        delete board.renderer;
        // clear the creator cache
        board.jc.creator.clearCache();
        delete board.jc;
        // Finally remove the board itself from the boards array
        delete JXG.boards[board.id];
    }
    /**
     * @deprecated Use JXG#registerElement
     * @param element
     * @param creator
     */
    static registerElement(element, creator) {
        JXG.deprecated('JXG.JSXGraph.registerElement()', 'JXG.registerElement()');
        JXG.registerElement(element, creator);
    }
}
/**
 * Stores the renderer that is used to draw the boards.
 * @type String
 */
JSXGraph.rendererType = 'svg'; // tbtb for

exports.JSXGraph = JSXGraph;
